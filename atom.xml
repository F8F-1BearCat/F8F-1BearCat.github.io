<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Magical Cat</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-29T02:50:52.136Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>F8F-1BearCat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Boot集成RocketMQ的设计与实现</title>
    <link href="http://yoursite.com/2019/03/28/Spring%20Boot%E9%9B%86%E6%88%90RocketMQ%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/03/28/Spring Boot集成RocketMQ的设计与实现/</id>
    <published>2019-03-28T02:10:19.653Z</published>
    <updated>2019-03-29T02:50:52.136Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/03/28/5c9c80dda5387.png" alt="RocketMQ.png"></p><h2 id="文章概要"><a href="#文章概要" class="headerlink" title="文章概要"></a>文章概要</h2><p>最近看了阿里中间件团队的几篇技术博客，详情见：<a href="http://jm.taobao.org/" target="_blank" rel="noopener">阿里中间件团队博客</a>，其中有关RocketMQ的几篇文章写得很好。还是那句话，学习本身就是一个不断获取知识然后投入实践的过程，本文就组内项目中使用的RocketMQ集成Spring Boot框架来实现消息发送消费的解决方案进行一个简单的梳理。鉴于自身当前对中间件优化方面还没有太深的接触，文中有可能会出现一些理解错误，难免不贻笑大方，所以权当成个人的学习笔记，方便记忆和以后的深入学习。</p><a id="more"></a><h2 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>为什么选择 Spring Boot集成RocketMQ作为行情组合计算服务的消息队列解决方案？迫于排版限制，其原因我放在了文章最后的补充目录下，下面是跳转链接：</p><p><a href="#jumpSpringAbout">关于Spring Boot</a></p><p><a href="#jumpCompare">Kafka、RocketMQ、RabbitMQ的比较</a></p><p>同时你也可以获取一些RocketMQ的简单介绍：</p><p><a href="#jumpRocketmqConcept">关于RocketMQ的一些概念</a></p><p>下面我将开门见山地对其实现细节进行介绍：</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ol><li>配置pom.xml文件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;rocketmq.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>spring-boot应用中对应的配置文件：src/main/resources/application.properties.</li></ol><p>生产端的配置文件application.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 定义name-server地址</span><br><span class="line">rocketmq.cluster.nameServer.addr=localhost:9876</span><br><span class="line"># 定义发布者组名</span><br><span class="line">rocketmq.message.producerGroup=result-message-producer</span><br><span class="line"># 定义要发送的topic</span><br><span class="line">rocketmq.message.producer.topic=result-topic</span><br></pre></td></tr></table></figure><p>消费端的配置文件application.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 定义name-server地址</span><br><span class="line">rocketmq.cluster.nameServer.addr=localhost:9876</span><br><span class="line"># 定义发布者组名</span><br><span class="line">rocketmq.message.result.consumerGroup=result-message-consumer</span><br><span class="line"># 定义要发送的topic</span><br><span class="line">rocketmq.message.result.topic=result-topic</span><br></pre></td></tr></table></figure><h3 id="消息生产端的设计实现"><a href="#消息生产端的设计实现" class="headerlink" title="消息生产端的设计实现"></a>消息生产端的设计实现</h3><p>生产端的Java代码如下：</p><p><strong>消息生产者类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQPushProducer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MQPushProducer</span><span class="params">(String nameServers, String producerGroup, String topic, String tag, <span class="keyword">int</span> maxMessageSize)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        producer = <span class="keyword">new</span> DefaultMQProducer(producerGroup);</span><br><span class="line">        producer.setNamesrvAddr(nameServers);</span><br><span class="line">        producer.setMaxMessageSize(maxMessageSize);</span><br><span class="line">        producer.setRetryTimesWhenSendFailed(retryTimesWhenSendFailed);</span><br><span class="line">        producer.setSendMsgTimeout(sendMsgTimeout);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            producer.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(String tag, Collection&lt;T&gt; msgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (producer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SendResult result = producer.send(<span class="keyword">new</span> Message(topic, tag, JSONObject.toJSONString(msgs).getBytes()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Collection&lt;T&gt; msgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (producer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SendResult result = producer.send(<span class="keyword">new</span> Message(topic, tag, JSONObject.toJSONString(msgs).getBytes()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RocketMQ通过轮询所有队列的方式来确定消息被发送到哪一个队列（负载均衡策略）。可以根据业务实现自己的MessageQueueSelector()发送顺序消息。</p><p>MQPushProducerOrderly类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQPushProducerOrderly</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">MQPushProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MQPushProducerOrderly</span><span class="params">(String nameServers, String producerGroup, String topic, String tag, <span class="keyword">int</span> maxMessageSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(nameServers, producerGroup, topic, tag, maxMessageSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Collection&lt;T&gt; msgs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (producer != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">for</span> (T msg : msgs)&#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] msgBytes = JSONObject.toJSONString(msg).getBytes();</span><br><span class="line">                    <span class="comment">// RocketMQ通过MessageQueueSelector中实现的算法来确定消息发送到哪一个队列上</span></span><br><span class="line"><span class="comment">// RocketMQ默认提供了两种MessageQueueSelector实现：随机/Hash</span></span><br><span class="line"><span class="comment">// 可以根据业务实现自己的MessageQueueSelector来决定消息按照何种策略发送到消息队列中</span></span><br><span class="line">                    SendResult result = producer.send(<span class="keyword">new</span> Message(topic, tag, msgBytes), <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">                            Integer id = (Integer) arg;</span><br><span class="line">        <span class="keyword">int</span> index = id % mqs.size();</span><br><span class="line">        <span class="keyword">return</span> mqs.get(index);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消息生产端启动类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="comment">/*packages...*/</span>&#125;,</span><br><span class="line">        excludeFilters = &#123;<span class="meta">@ComponentScan</span>.Filter(type = FilterType.CUSTOM, classes = ApplicationExcludeFilter.class)&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerApplication</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用application.properties里定义的topic属性</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.cluster.nameServer.addr&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String nameServers;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.message.producer.topic&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String resultTopic;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.message.producerGroup&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String resultConsumerGroupName;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.setProperty(CLIENT_LOG_USESLF4J,<span class="string">"true"</span>);</span><br><span class="line">        SpringApplication.run(ProducerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... strings)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//初始化发送生产者队列</span></span><br><span class="line">MQPushProducerOrderly&lt;...&gt; producer = <span class="keyword">new</span> MQPushProducerOrderly(nameServers, producerGroup, topic, tag, maxMessageSize);</span><br><span class="line">        <span class="comment">//整个应用生命周期内，只需要初始化1次</span></span><br><span class="line">        producer.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//启动消息计算发送主线程</span></span><br><span class="line">        ...</span><br><span class="line">            producer.push(msgs);</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//清理资源，关闭网络连接，注销自己</span></span><br><span class="line">        producer.shutdown(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于@SpringBootApplication注解相关参见：<a href="#jumpSpringBootApplication">@SpringBootApplication 注解简析</a></p><p>在整个应用生命周期内，生产者需要调用一次start方法来初始化，初始化主要完成的任务有：</p><ol><li>如果没有指定namesrv地址，将会自动寻址；</li><li>启动定时任务：更新namesrv地址、从namsrv更新topic路由信息、清理已经挂掉的broker、向所有broker发送心跳等；</li><li>启动负载均衡的服务。</li></ol><p>如果Producer发送消息失败，会自动重试，重试的策略：</p><ol><li><p>重试次数 &lt; retryTimesWhenSendFailed（可配置）；</p></li><li><p>总的耗时（包含重试n次的耗时） &lt; sendMsgTimeout（发送消息时传入的参数）；</p></li><li><p>同时满足上面两个条件后，Producer会选择另外一个队列发送消息。</p></li></ol><h3 id="消息消费端设计实现"><a href="#消息消费端设计实现" class="headerlink" title="消息消费端设计实现"></a>消息消费端设计实现</h3><p>消息消费端代码如下：</p><p><strong>消息消费者类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MQPushConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MQPushConsumer</span><span class="params">(String nameServers, String consumerGroup, String topic, String tag, <span class="keyword">int</span> consumeMessageBatchMaxSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> consumeThreadMin, <span class="keyword">int</span> consumeThreadMax, <span class="keyword">int</span> pullBatchSize, MessageModel messageModel, ConsumeFromWhere offset)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(consumerGroup);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            consumer.setNamesrvAddr(nameServers);</span><br><span class="line">            consumer.subscribe(topic, tag);<span class="comment">//可订阅多个tag，但是一个消息只能有一个tag</span></span><br><span class="line">            consumer.setConsumeThreadMin(consumeThreadMin);</span><br><span class="line">            consumer.setConsumeThreadMax(consumeThreadMax);</span><br><span class="line">            consumer.setConsumeFromWhere(offset);</span><br><span class="line">            consumer.setConsumeMessageBatchMaxSize(consumeMessageBatchMaxSize);</span><br><span class="line">            consumer.setPullBatchSize(pullBatchSize);</span><br><span class="line">            consumer.setMessageModel(messageModel);</span><br><span class="line">            consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!poll(list))&#123;</span><br><span class="line">                        <span class="keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            consumer.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MQPushConsumerOrderly类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MQPushConsumerOrderly</span> <span class="keyword">extends</span> <span class="title">MQPushConsumer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MQPushConsumerOrderly</span><span class="params">(String nameServers, String consumerGroup, String topic, String tag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> consumeMessageBatchMaxSize, <span class="keyword">int</span> consumeThreadMin, <span class="keyword">int</span> consumeThreadMax,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> pullBatchSize, MessageModel messageModel, ConsumeFromWhere offset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(nameServers, consumerGroup, topic, tag, consumeMessageBatchMaxSize, consumeThreadMin, consumeThreadMax, pullBatchSize, messageModel, offset);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(consumerGroup);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            consumer.setNamesrvAddr(nameServers);</span><br><span class="line">            consumer.subscribe(topic, tag);<span class="comment">//可订阅多个tag，但是一个消息只能有一个tag</span></span><br><span class="line">            consumer.setConsumeThreadMin(consumeThreadMin);</span><br><span class="line">            consumer.setConsumeThreadMax(consumeThreadMax);</span><br><span class="line">            consumer.setConsumeFromWhere(offset);</span><br><span class="line">            consumer.setConsumeMessageBatchMaxSize(consumeMessageBatchMaxSize);</span><br><span class="line">            consumer.setPullBatchSize(pullBatchSize);</span><br><span class="line">            consumer.setMessageModel(messageModel);</span><br><span class="line">            <span class="comment">//注册监听类的时候，不能使用匿名内部类。不然的话只消费一次消费者就挂了, 监听类要单独写。</span></span><br><span class="line">            MQMessageListenerOrderly listener = <span class="keyword">new</span> MQMessageListenerOrderly(<span class="keyword">this</span>);</span><br><span class="line">            consumer.registerMessageListener(listener);</span><br><span class="line">            consumer.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册监听类的时候，不能使用匿名内部类。不然的话只消费一次消费者就挂了, 监听类要单独写。</p><p><strong>自定义监听类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQMessageListenerOrderly</span> <span class="keyword">implements</span>  <span class="title">MessageListenerOrderly</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置自动提交</span></span><br><span class="line">        context.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">            System.out.println(msg + <span class="string">",内容："</span> + <span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消息消费端启动类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="comment">/*packages...*/</span>&#125;,</span><br><span class="line">        excludeFilters = &#123;<span class="meta">@ComponentScan</span>.Filter(type = FilterType.CUSTOM, classes = ApplicationExcludeFilter.class)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerApplication</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用application.properties里定义的topic属性</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.cluster.nameServer.addr&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String nameServers;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.message.result.topic&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String resultTopic;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.message.result.consumerGroup&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String resultConsumerGroupName;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.setProperty(CLIENT_LOG_USESLF4J,<span class="string">"true"</span>);</span><br><span class="line">        SpringApplication.run(ConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... strings)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//从MQ队列消费计算结果</span></span><br><span class="line">        consumer = <span class="keyword">new</span> MQPushConsumerOrderly(nameServers, consumerGroup, topic, tag, consumeMessageBatchMaxSize, consumeThreadMin,</span><br><span class="line">                consumeThreadMax, pullBatchSize, messageModel, offset) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">poll</span><span class="params">(List&lt;MessageExt&gt; messageExts)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : messageExts) &#123;</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是一个简单的使用Spring Boot框架集成RocketMQ实现基本的消息发送和接收的实例，在以后的工作中对RocketMQ的事务消费、消息存储有深入的理解再另行整理。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h4 id="关于Spring-Boot"><a href="#关于Spring-Boot" class="headerlink" title="关于Spring Boot"></a><span id="jumpSpringAbout">关于Spring Boot</span></h4><p>Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot 致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。</p><p>Spring Boot基于“约定大于配置”（Convention over configuration)这一理念来快速地开发、测试、运行和部署Spring应用，并能通过简单地与各种启动器(如 spring-boot-web-starter)结合，让应用直接以命令行的方式运行，不需再部署到独立容器中。这种简便直接快速构建和开发应用的过程，可以使用约定的配置并且简化部署，受到越来越多的开发者的欢迎。</p><h4 id="Kafka、RocketMQ、RabbitMQ的比较"><a href="#Kafka、RocketMQ、RabbitMQ的比较" class="headerlink" title="Kafka、RocketMQ、RabbitMQ的比较"></a><span id="jumpCompare">Kafka、RocketMQ、RabbitMQ的比较</span></h4><ul><li><p>Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache顶级项目。Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。</p><p>大型公司建议可以选用，如果有日志采集功能，肯定是首选kafka了。</p></li><li><p>RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。</p><p>结合erlang语言本身的并发优势，性能较好，社区活跃度也比较高，但是不利于做二次开发和维护。不过，RabbitMQ的社区十分活跃，可以解决开发过程中遇到的bug。</p><p>如果你的数据量没有那么大，小公司优先选择功能比较完备的RabbitMQ。</p></li><li><p>RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景。</p><p>天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。</p><p>RoketMQ在稳定性上可能更值得信赖，这些业务场景在阿里双11已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择RocketMQ。</p></li></ul><h4 id="关于RocketMQ的一些概念"><a href="#关于RocketMQ的一些概念" class="headerlink" title="关于RocketMQ的一些概念"></a><span id="jumpRocketmqConcept">关于RocketMQ的一些概念</span></h4><p><strong>Producer</strong>：消息生产者，生产者的作用就是将消息发送到 MQ，生产者本身既可以产生消息，如读取文本信息等。也可以对外提供接口，由外部应用来调用接口，再由生产者将收到的消息发送到 MQ。</p><p><strong>Producer Group</strong>：生产者组，简单来说就是多个发送同一类消息的生产者称之为一个生产者组。在这里可以不用关心，只要知道有这么一个概念即可。</p><p><strong>Consumer</strong>：消息消费者，简单来说，消费 MQ 上的消息的应用程序就是消费者，至于消息是否进行逻辑处理，还是直接存储到数据库等取决于业务需要。</p><p><strong>Consumer Group</strong>：消费者组，和生产者类似，消费同一类消息的多个 consumer 实例组成一个消费者组。</p><p><strong>Topic</strong>：Topic 是一种消息的逻辑分类，比如说你有订单类的消息，也有库存类的消息，那么就需要进行分类，一个是订单 Topic 存放订单相关的消息，一个是库存 Topic 存储库存相关的消息。</p><p><strong>Message</strong>：Message 是消息的载体。一个 Message 必须指定 topic，相当于寄信的地址。Message 还有一个可选的 tag 设置，以便消费端可以基于 tag 进行过滤消息。也可以添加额外的键值对，例如你需要一个业务 key 来查找 broker 上的消息，方便在开发过程中诊断问题。</p><p><strong>Tag</strong>：标签可以被认为是对 Topic 进一步细化。一般在相同业务模块中通过引入标签来标记不同用途的消息。</p><p><strong>Broker</strong>：Broker 是 RocketMQ 系统的主要角色，其实就是前面一直说的 MQ。Broker 接收来自生产者的消息，储存以及为消费者拉取消息的请求做好准备。</p><p><strong>Name Server</strong>：Name Server 为 producer 和 consumer 提供路由信息。</p><p><strong>RocketMQ的概念模型如下：</strong> </p><p><img src="https://i.loli.net/2019/03/28/5c9c7b4c6f381.jpg" alt="RocketMQModel.jpg"></p><p><strong>RocketMQ的部署模型如下：</strong> </p><p><img src="https://i.loli.net/2019/03/28/5c9c7b4c651ee.jpg" alt="RocketMQBuild.jpg"></p><h4 id="SpringBootApplication-注解简析"><a href="#SpringBootApplication-注解简析" class="headerlink" title="@SpringBootApplication 注解简析"></a><span id="jumpSpringBootApplication">@SpringBootApplication 注解简析</span></h4><p>@SpringBootApplication = @SpringBootConfiguration + @EnableAutoConfiguration + @ComponentScan。</p><p>因为@SpringBootConfiguration ,@EnableAutoConfiguration,@ComponentScan这些注解一般都是一起使用来注解mian()方法所在的类，所以Spring Boot提供了一个统一的注解@SpringBootApplication。</p><ul><li><code>@SpringBootConfiguration</code>继承自<code>@Configuration</code>，二者功能也一致，标注当前类是配置类，并会将当前类内声明的一个或多个以<code>@Bean</code>注解标记的方法的实例纳入到Spring容器中，并且实例名就是方法名。</li><li>@EnableAutoConfiguration的作用启动自动的配置，@EnableAutoConfiguration注解的意思就是Springboot根据你添加的jar包来配置你项目的默认配置，比如根据spring-boot-starter-web，来判断你的项目是否需要添加了webmvc和tomcat，就会自动的帮你配置web项目中所需要的默认配置。在下面博客会具体分析这个注解，快速入门的demo实际没有用到该注解。</li><li>@ComponentScan，扫描当前包及其子包下被@Component，@Controller，@Service，@Repository注解标记的类并纳入到spring容器中进行管理。是以前的<code>&lt;context:component-scan&gt;</code>（以前使用在xml中使用的标签，用来扫描包配置的平行支持）。所以本demo中的User为何会被spring容器管理。</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="http://jm.taobao.org/2018/11/28/%E6%88%91%E7%94%A8%E8%BF%99%E7%A7%8D%E6%96%B9%E6%B3%95/#more" target="_blank" rel="noopener">如何在优雅地Spring 中实现消息的发送和消费</a></li><li><a href="http://jm.taobao.org/2018/11/06/%E6%BB%B4%E6%BB%B4%E5%87%BA%E8%A1%8C%E5%9F%BA%E4%BA%8ERocketMQ%E6%9E%84%E5%BB%BA%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%9E%E8%B7%B5/#more" target="_blank" rel="noopener">滴滴出行基于RocketMQ构建企业级消息队列服务的实践</a></li><li><a href="http://www.10tiao.com/html/683/201811/2650718577/1.html" target="_blank" rel="noopener">一文讲透Apache RocketMQ技术精华</a></li><li><a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">分布式开放消息系统(RocketMQ)的原理与实践</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/28/5c9c80dda5387.png&quot; alt=&quot;RocketMQ.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章概要&quot;&gt;&lt;a href=&quot;#文章概要&quot; class=&quot;headerlink&quot; title=&quot;文章概要&quot;&gt;&lt;/a&gt;文章概要&lt;/h2&gt;&lt;p&gt;最近看了阿里中间件团队的几篇技术博客，详情见：&lt;a href=&quot;http://jm.taobao.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阿里中间件团队博客&lt;/a&gt;，其中有关RocketMQ的几篇文章写得很好。还是那句话，学习本身就是一个不断获取知识然后投入实践的过程，本文就组内项目中使用的RocketMQ集成Spring Boot框架来实现消息发送消费的解决方案进行一个简单的梳理。鉴于自身当前对中间件优化方面还没有太深的接触，文中有可能会出现一些理解错误，难免不贻笑大方，所以权当成个人的学习笔记，方便记忆和以后的深入学习。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="中间件" scheme="http://yoursite.com/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="Spring Boot" scheme="http://yoursite.com/tags/Spring-Boot/"/>
    
      <category term="RocketMQ" scheme="http://yoursite.com/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>OpenJDK12的新特性（下）</title>
    <link href="http://yoursite.com/2019/03/26/OpenJDK12%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2019/03/26/OpenJDK12的新特性（下）/</id>
    <published>2019-03-26T07:27:18.412Z</published>
    <updated>2019-04-03T06:09:24.942Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/03/28/5c9c829850beb.jpg" alt="OpenJDK.jpg"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>OpenJDK 12是由JSR 386在Java Community Process中指定的Java SE平台的版本12的开源参考实现，于2019年3月19日达到General Availability版本。GPL(General Public License)协议下的生产就绪二进制文件可从Oracle获得；其他供应商的二进制文件很快就会出现。</p><p>该版本的功能和时间表是通过JEP流程提出和跟踪的，并由JEP 2.0提案进行了修订。该版本使用JDK Release Process（JEP 3）生成发布。</p><p>本文根据OpenJDK 12的官方文档：<a href="http://openjdk.java.net/projects/jdk/12/" target="_blank" rel="noopener">OpenJDK 12</a>，对其新特性进行整理，受本人翻译水平所限，难免有翻译或理解错误，望不吝指正。上篇看这里：<a href="https://f8f-1bearcat.github.io/2019/03/26/OpenJDK12%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/#jump334" target="_blank" rel="noopener">OpenJDK12的新特性（上）</a>。</p><a id="more"></a><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><table><thead><tr><th>JEP</th><th>Features</th></tr></thead><tbody><tr><td>189:</td><td><a href="#jump189">Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)</a></td></tr><tr><td>230:</td><td><a href="#jump230">Microbenchmark Suite</a></td></tr><tr><td>325:</td><td><a href="#jump325">Switch Expressions (Preview)</a></td></tr><tr><td>334:</td><td><a href="#jump334">JVM Constants API</a></td></tr><tr><td>340:</td><td><a href="#jump340">One AArch64 Port, Not Two</a></td></tr><tr><td>341:</td><td><a href="#jump341">Default CDS Archives</a></td></tr><tr><td>344:</td><td><a href="#jump344">Abortable Mixed Collections for G1</a></td></tr><tr><td>346:</td><td><a href="#jump346">Promptly Return Unused Committed Memory from G1</a></td></tr></tbody></table><h4 id="JEP340-One-AArch64-Port-Not-Two"><a href="#JEP340-One-AArch64-Port-Not-Two" class="headerlink" title="JEP340: One AArch64 Port, Not Two"></a><span id="jump340">JEP340: One AArch64 Port, Not Two</span></h4><p><strong>摘要</strong>：</p><p>删除与arm64端口相关的所有源，同时保留32位ARM端口和64位aarch64端口。</p><p><strong>动机</strong>：</p><p>删除此端口将允许所有贡献者将他们的精力集中在单个64位ARM实现上，并消除维护两个端口所需的重复工作。</p><p><strong>描述</strong>：</p><p>JDK中存在两个64位ARM端口。 这些的主要来源是<code>src/hotspot/cpu/arm</code>和<code>open/src/hotspot/cpu/aarch64</code>目录。虽然这两个端口都产生了aarch64实现，但是为了这个JEP，我们将引用前者arm64，它由Oracle提供，后者是aarch64。</p><p>以下是将作为此JEP的一部分完成的任务：</p><ul><li>在<code>open/src/hotspot/cpu/arm</code>中删除所有与<code>arm64-specific</code>的源和与64位而不是32位构建相关的<code>#ifdefs</code>；</li><li>扫描与此端口相关的<code>#ifdefs</code>的剩余JDK源；</li><li>删除构建此端口的build option，使aarch64端口成为64位ARM体系结构的默认构建；</li><li>验证剩余的32位ARM端口是否继续构建并运行一致性测试。</li></ul><h4 id="JEP341-Default-CDS-Archives"><a href="#JEP341-Default-CDS-Archives" class="headerlink" title="JEP341: Default CDS Archives"></a><span id="jump341">JEP341: Default CDS Archives</span></h4><p><strong>摘要</strong>：</p><p>在64位平台上使用默认类列表，增强JDK build process以生成 class data-sharing（CDS）存档。</p><p><strong>目标</strong>：</p><ul><li>改善开箱即用的启动时间</li><li>消除用户运行<code>-Xshare:dump</code>以从CDS中受益的需要</li></ul><p><strong>非目标</strong>：</p><ul><li>我们将仅为native builds生成默认存档，而不是针对交叉编译的构建。</li><li>我们将仅为64位版本生成默认存档，稍后可能会添加对32位版本的支持。</li></ul><p><strong>动机</strong>：</p><p>自JDK 8u40以来，许多增强功能被添加到基本CDS特性中。启用CDS提供的启动时间和内存共享优势显着增加。 使用JDK 11早期访问版本14在Linux/x64上完成的测量显示运行HelloWorld的启动时间缩短了32％。 在其他64位平台上，已观察到类似或更高的启动性能增益。</p><p>目前，JDK映像包括在lib目录中构建时生成的默认类列表。想要利用CDS的用户，即使只使用JDK中提供的默认类列表，也必须运行<code>java -Xshare:dump</code>作为额外步骤。此选项已记录在案，但许多用户并未意识到这一点。</p><p><strong>描述</strong>：</p><p>修改JDK构建以在链接图像后运行<code>java -Xshare:dump</code>，（可以包括附加的命令行选项以微调GC堆大小等，以便为常见情况获得更好的内存布局）将生成的CDS存档保留在<code>lib/server</code>目录中。</p><p>用户将自动受益于CDS功能，因为默认情况下为JDK 11（JDK-8197967）中的服务VM启用了<code>-Xshare:auto</code>。 要禁用CDS，请使用<code>-Xshare:off</code>运行。</p><p>具有更高级要求的用户（例如，使用包括应用程序类、不同GC配置等的自定义类列表）仍然可以像以前一样创建自定义CDS存档。</p><p><strong>选择</strong>：略</p><p><strong>测试</strong>：</p><p>启用CDS的现有自动化测试已足够。</p><h4 id="JEP344-Abortable-Mixed-Collections-for-G1"><a href="#JEP344-Abortable-Mixed-Collections-for-G1" class="headerlink" title="JEP344: Abortable Mixed Collections for G1"></a><span id="jump344">JEP344: Abortable Mixed Collections for G1</span></h4><p><strong>摘要</strong>：</p><p>如果G1 mixed 收集可能超过停顿目标，则使其可以中止。</p><p><strong>非目标</strong>：</p><p>使G1中的所有停顿都可以中止。</p><p><strong>动机</strong>：</p><p>G1的目标之一是满足用户提供的暂停时间目标的条件的时候暂停其收集。G1使用高级分析引擎来选择在收集期间要完成的工作（这部分基于应用程序行为），此选择的结果是一组称为<em>collection set</em>的区域。一旦确定了collection set并且已经开始收集工作，则G1必须不停地收集collection set的所有region中的所有存活的对象。如果heuristics选择过大的collection set，则此行为可能导致G1超过停顿时间目标，例如，如果应用程序的行为发生变化，使得heuristics选择在”陈旧“数据进行处理，则可能发生这种情况。特别是在mixed收集期间可以观察到这种情况，期间collection set通常会包含很多old region。需要一种机制来检测heuristics何时反复为收集选择错误的工作量，如果此现象存在的话，则让G1逐步递增地执行收集工作，并且可以在每个步骤之后中止收集。这种机制将允许G1更易于满足停顿时间目标。</p><p><strong>描述</strong>：</p><p>如果G1发现collection set选择heuristics重复选择错误的区域数，则切换到更复杂的方式来执行mixed收集：将collection set拆分为两个部分：强制部分和可选部分。强制性部分包括G1不能递增地处理的collection set的部分（例如young regions），但也可以包含old region以提高效率。例如，预计的collection set的80％构成强制性部分，剩余的20％（仅由old region组成）构成可选部分。</p><p>G1完成强制部分的收集后，如果还有剩余时间，G1会以更细粒度的级别开始收集可选部分。此可选部分的集合粒度取决于剩余的时间量，一次最多只能到一个region。完成对可选collection set所有部分的收集后，G1可以根据剩余时间决定停止收集。</p><p>随着预测再次变得更准确，一次收集的可选部分变得越来越小，直到强制部分再次包括所有collection set（即，G1完全依赖于其heuristics）。如果预测再次变得不准确，则下一次收集将再次包含强制和可选部分。</p><p><strong>选择</strong>：</p><ul><li><p>改进分析引擎和heuristics，以便他们不会做出错误的预测。由于heuristics方法依赖于之前应用程序的行为，因此无法获得100％准确的heuristics方法。但是，改进的heuristics方法将自动减少对此机制的需求。</p></li><li><p>始终使用与预测有关的“安全边际”。例如，如果预测返回x，则始终使用0.8 * x（20％的安全范围）。这可能在大多数情况下都有效，但是当预测有效时会导致sub-optimal 性能，因为这意味着G1只会使用80％的停顿目标。</p></li><li><p>重用现有的疏散失败机制来中止mixed收集。这已被拒绝作为替代方案，因为在这样的中止时，不能保证该次收集释放任何region。我们提出的机制通过回收region基础（G1的空间回收粒度）上的collection set的空间来保证空间回收的进展。</p></li></ul><p><strong>测试</strong>：</p><p>构成实现的各个C++部分应该使用C++单元测试进行测试。由于可中止的mixed收集代码将是G1 GC的组成部分，因此只需运行现有测试即可执行代码。</p><p><strong>风险和假设</strong>：</p><ul><li><p>将collection set拆分为必需和可选部分时，需要为可选collection set部分维护一些其他数据。 这会产生轻微的CPU开销，小于1％，并且仅适用于使用可选collection set部分的mixed收集。</p></li><li><p>使用可选collection set部分的mixed收集期间的本机内存使用量也可能增加。这是因为在mixed收集期间必须跟踪到可选部分中的区域的一些附加传入指针。</p></li></ul><h4 id="JEP346-Promptly-Return-Unused-Committed-Memory-from-G1"><a href="#JEP346-Promptly-Return-Unused-Committed-Memory-from-G1" class="headerlink" title="JEP346: Promptly Return Unused Committed Memory from G1"></a><span id="jump346">JEP346: Promptly Return Unused Committed Memory from G1</span></h4><p><strong>摘要</strong>：</p><p>增强G1垃圾收集器，以便在空闲时自动将Java堆内存返回给操作系统。</p><p><strong>非目标</strong>：</p><ul><li><p>在Java进程之间共享已提交但空的页面。应将内存返回（未提交）到操作系统。</p></li><li><p>回馈内存的过程不需要节省CPU资源，也不需要是瞬时的。</p></li><li><p>使用不同的方法返回除可用内存以外的内存。</p></li><li><p>支持除G1之外的其他收集器。</p></li></ul><p><strong>成功标准</strong>：</p><p>如果应用程序活动非常低，G1应该在合理的时间段内释放未使用的Java堆内存。</p><p><strong>动机</strong>：</p><p>目前G1垃圾收集器可能无法及时将已提交的Java堆内存返回给操作系统。G1仅在full GC或并发周期内从Java堆返回内存。由于G1很难完全避免full GC，并且只触发基于Java堆占用和分配活动的并发周期，因此除非在外部强制执行，否则在许多情况下它不会返回Java堆内存。</p><p>在使用资源支付的容器环境中，这种行为特别不利。即使在VM由于不活动而仅使用其分配的内存资源的一小部分的阶段，G1也将保留所有Java堆。这导致客户始终为所有资源付费，云提供商无法充分利用其硬件。</p><p>如果VM能够检测到Java堆的利用率不足（“空闲”阶段），并在此期间自动减少其堆使用量，则两者都将受益。</p><p>Shenandoah和OpenJ9的GenCon收集器已经提供了类似的功能。</p><p>在<a href="http://www.gsd.inesc-id.pt/~rbruno/publications/rbruno-ismm18.pdf" target="_blank" rel="noopener">Bruno et al., section 5.5</a>中使用原型进行的测试表明，基于在白天为HTTP请求提供服务的Tomcat服务器的实际利用情况（夜间大部分空闲），此解决方案可以将Java VM提交的内存量减少85％。</p><p><strong>描述</strong>：</p><p>为了实现向操作系统返回最大内存量的目标，G1将在应用程序不活动期间定期尝试继续或触发并发周期以确定整体Java堆使用情况。这将导致它自动将Java堆的未使用部分返回给操作系统。（可选）在用户控制下，可以执行full GC以最大化返回的内存量。</p><p>如果以下两者都发生，应用程序将被视为非活动状态，并且G1会触发定期垃圾收集：</p><ul><li><p>自任何先前的垃圾收集停顿以来已超过<code>G1PeriodicGCInterval</code>毫秒，此时没有正在进行的并发周期。值为零表示禁用快速回收内存的定期垃圾收集。</p></li><li><p>JVM主机系统（例如容器）上的<code>getloadavg()</code>调用返回的平均一分钟系统负载值低于<code>G1PeriodicGCSystemLoadThreshold</code>。如果<code>G1PeriodicGCSystemLoadThreshold</code>为零，则忽略此条件。</p></li></ul><p>如果不满足这些条件中的任何一个，则取消当前的预期定期垃圾收集。下次<code>G1PeriodicGCInterval</code>时间过去时，将重新考虑定期垃圾收集。</p><p>周期性垃圾收集的类型由<code>G1PeriodicGCInvokesConcurrent</code>选项的值确定：如果设置，G1继续或启动并发周期，否则G1执行full GC。在任一收集过程的末尾，G1调整当前的Java堆大小，可能会将内存返回给操作系统。新的Java堆大小由用于调整Java堆大小的现有配置确定，包括但不限于<code>MinHeapFreeRatio</code>，<code>MaxHeapFreeRatio</code>以及最小和最大堆大小配置。</p><p>默认情况下，G1在此定期垃圾回收期间启动或继续并发循环。这最大限度地减少了应用程序的中断，但与完整收集相比，最终可能无法返回尽可能多的内存。</p><p>由此机制触发的任何垃圾收集都使用<code>G1 Periodic Collection</code>进行标记。此类日志示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(1) [6.084s][debug][gc,periodic ] Checking for periodic GC.</span><br><span class="line">    [6.086s][info ][gc          ] GC(13) Pause Young (Concurrent Start) (G1 Periodic Collection) 37M-&gt;36M(78M) 1.786ms</span><br><span class="line">(2) [9.087s][debug][gc,periodic ] Checking for periodic GC.</span><br><span class="line">    [9.088s][info ][gc          ] GC(15) Pause Young (Prepare Mixed) (G1 Periodic Collection) 9M-&gt;9M(32M) 0.722ms</span><br><span class="line">(3) [12.089s][debug][gc,periodic ] Checking for periodic GC.</span><br><span class="line">    [12.091s][info ][gc          ] GC(16) Pause Young (Mixed) (G1 Periodic Collection) 9M-&gt;5M(32M) 1.776ms</span><br><span class="line">(4) [15.092s][debug][gc,periodic ] Checking for periodic GC.</span><br><span class="line">    [15.097s][info ][gc          ] GC(17) Pause Young (Mixed) (G1 Periodic Collection) 5M-&gt;1M(32M) 4.142ms</span><br><span class="line">(5) [18.098s][debug][gc,periodic ] Checking for periodic GC.</span><br><span class="line">    [18.100s][info ][gc          ] GC(18) Pause Young (Concurrent Start) (G1 Periodic Collection) 1M-&gt;1M(32M) 1.685ms</span><br><span class="line">(6) [21.101s][debug][gc,periodic ] Checking for periodic GC.</span><br><span class="line">    [21.102s][info ][gc          ] GC(20) Pause Young (Concurrent Start) (G1 Periodic Collection) 1M-&gt;1M(32M) 0.868ms</span><br><span class="line">(7) [24.104s][debug][gc,periodic ] Checking for periodic GC.</span><br><span class="line">    [24.104s][info ][gc          ] GC(22) Pause Young (Concurrent Start) (G1 Periodic Collection) 1M-&gt;1M(32M) 0.778ms</span><br></pre></td></tr></table></figure><p>在上面的示例中，使用<code>G1PeriodicGCInterval</code>为3000ms运行，在步骤（1）G1中，在应用程序不活动之后，启动并发周期，如（<code>Concurrent Start</code>）和（<code>G1 Periodic Collection</code>）所示。 该并发周期最初返回一些内存，通过从（1）到（2）的容量数（78M）和（32M）的减少来表示。 在（2）到（4）之间的间隔中，触发更多的周期性收集，这次触发mixed collection以对堆进行整理。（5）到（7）启动并发周期，因为G1策略确定当时在老年代中没有足够的垃圾来启动mixed GC阶段。在这种情况下，定期垃圾收集（5）到（7）不会进一步缩小堆，因为已经达到最小堆大小。</p><p>在应用程序不活动期间对对象活跃性的改变（例如，由于软引用到期）可以在空闲期间触发进一步缩小已提交的Java堆。</p><p><strong>选择</strong>：</p><p>可以从VM外部实现类似的功能，例如，通过jcmd工具或注入VM的一些代码。这有隐藏的成本：假设使用cron-based任务执行检查，如果节点上有数百或数千个容器，这可能意味着堆压缩操作由许多这些容器同时执行， 导致主机上出现非常大的CPU峰值。</p><p>另一种替代方法是Java代理，它自动附加到每个Java进程。然后，当容器在不同的时间开始时，检查的时间会自然分配，而且由于没有启动任何新进程，因此在CPU上的成本更低。然而，这种方法为用户增加了显著的复杂性，这可能会阻碍采用。</p><p>给定的用例，及时缩小Java堆，被认为是一个相当常见的用例，需要在VM中提供特殊支持。</p><p><strong>风险和假设</strong>：</p><p>在配置的默认值中，我们禁用此功能。 这导致延迟或吞吐量敏感应用程序的VM行为没有意外更改。启用后，我们假设通常需要将Java堆内存返回给操作系统，并且所产生的并发周期或其继续对应用程序吞吐量的影响可以忽略不计。</p><p>启用此功能后，VM将在上述条件下运行这些定期收集，而不管其他option如何。 例如，VM可以假设如果用户将<code>-Xms</code>设置为-<code>Xmx</code>和其他（组合）选项以获得最小且一致的垃圾收集暂停。出于一致性原因，情况并非如此。</p><p>如果定期垃圾收集仍然会太干扰程序执行，我们提供控制以让决策考虑整个系统CPU负载，或让用户完全禁用定期垃圾收集。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/28/5c9c829850beb.jpg&quot; alt=&quot;OpenJDK.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;OpenJDK 12是由JSR 386在Java Community Process中指定的Java SE平台的版本12的开源参考实现，于2019年3月19日达到General Availability版本。GPL(General Public License)协议下的生产就绪二进制文件可从Oracle获得；其他供应商的二进制文件很快就会出现。&lt;/p&gt;
&lt;p&gt;该版本的功能和时间表是通过JEP流程提出和跟踪的，并由JEP 2.0提案进行了修订。该版本使用JDK Release Process（JEP 3）生成发布。&lt;/p&gt;
&lt;p&gt;本文根据OpenJDK 12的官方文档：&lt;a href=&quot;http://openjdk.java.net/projects/jdk/12/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OpenJDK 12&lt;/a&gt;，对其新特性进行整理，受本人翻译水平所限，难免有翻译或理解错误，望不吝指正。上篇看这里：&lt;a href=&quot;https://f8f-1bearcat.github.io/2019/03/26/OpenJDK12%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/#jump334&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OpenJDK12的新特性（上）&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="OpenJDK" scheme="http://yoursite.com/tags/OpenJDK/"/>
    
  </entry>
  
  <entry>
    <title>OpenJDK12的新特性（上）</title>
    <link href="http://yoursite.com/2019/03/26/OpenJDK12%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://yoursite.com/2019/03/26/OpenJDK12的新特性（上）/</id>
    <published>2019-03-26T07:27:06.771Z</published>
    <updated>2019-04-03T06:09:27.158Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/03/28/5c9c829850beb.jpg" alt="OpenJDK.jpg"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>OpenJDK 12是由JSR 386在Java Community Process中指定的Java SE平台的版本12的开源参考实现，于2019年3月19日达到General Availability版本。GPL(General Public License)协议下的生产就绪二进制文件可从Oracle获得；其他供应商的二进制文件很快就会出现。</p><p>该版本的功能和时间表是通过JEP流程提出和跟踪的，并由JEP 2.0提案进行了修订。该版本使用JDK Release Process（JEP 3）生成发布。</p><p>本文根据OpenJDK 12的官方文档：<a href="http://openjdk.java.net/projects/jdk/12/" target="_blank" rel="noopener">OpenJDK 12</a>，对其新特性进行整理，受本人翻译水平所限，难免有翻译或理解错误，望不吝指正。</p><a id="more"></a><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><table><thead><tr><th>JEP</th><th>Features</th></tr></thead><tbody><tr><td>189:</td><td><a href="#jump189">Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)</a></td></tr><tr><td>230:</td><td><a href="#jump230">Microbenchmark Suite</a></td></tr><tr><td>325:</td><td><a href="#jump325">Switch Expressions (Preview)</a></td></tr><tr><td>334:</td><td><a href="#jump334">JVM Constants API</a></td></tr><tr><td>340:</td><td><a href="#jump340">One AArch64 Port, Not Two</a></td></tr><tr><td>341:</td><td><a href="#jump341">Default CDS Archives</a></td></tr><tr><td>344:</td><td><a href="#jump344">Abortable Mixed Collections for G1</a></td></tr><tr><td>346:</td><td><a href="#jump346">Promptly Return Unused Committed Memory from G1</a></td></tr></tbody></table><p><strong>注意</strong>：因篇幅限制，下文将对OpenJDK 12的新特性：189、230、325、334进行整理，剩余特性的整理请见下篇：<a href="https://f8f-1bearcat.github.io/2019/03/26/OpenJDK12%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8B%EF%BC%89/#more" target="_blank" rel="noopener">OpenJDK12的新特性（下）</a>。</p><h4 id="JEP189-Shenandoah-A-Low-Pause-Time-Garbage-Collector-Experimental"><a href="#JEP189-Shenandoah-A-Low-Pause-Time-Garbage-Collector-Experimental" class="headerlink" title="JEP189: Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)"></a><span id="jump189">JEP189: Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)</span></h4><p>低GC停顿的垃圾收集器(Experimental版本)</p><p><strong>摘要</strong>：</p><p>添加一个名为Shenandoah的新垃圾收集（GC）算法，在执行GC动作时可以通过并发的方式让Java程序继续执行，从而缩短Stop_The_World的时间。使用Shenandoah的停顿时间与堆大小无关，这意味着无论堆是200 MB还是200 GB，都将具有相同的稳定停顿时间。</p><p><strong>非目标</strong>：</p><p>这个GC算法并不是万能的，还有其他的垃圾收集算法会优先考虑吞吐量或者内存占用，而不是响应性。Shenandoah算法适用于那些注重响应性和可预测的停顿时间的应用，它并不能解决所有的JVM停顿问题，那些由于GC之外的其他原因，如达到安全点的时间（TTSP）或者监控通胀，导致的停顿时间超出了此JEP的范围。</p><p><strong>成功标准</strong>：</p><p>保持一致的较短的GC停顿时间。</p><p><strong>描述</strong>：</p><p>现代机器拥有比以往更多的内存和更多的处理器。服务水平协议（SLA）应用程序保证响应时间为10-500毫秒。为了满足该目标的低端，我们需要足够高效垃圾收集算法以允许程序在可用内存中运行，而且也要能做到永远不会中断正在运行的程序超过几毫秒。 Shenandoah是OpenJDK开源的低停顿收集器，旨在让我们更接近这些目标。</p><p>Shenandoah通过牺牲并发cpu周期和空间以优化停顿时间。我们为每个Java对象添加了一个间接指针，使得GC线程进行Java堆整理时能够与用户线程并发执行。由于整个GC过程中耗时最长的并发标记和整理过程收集器线程与用户线程可以一起工作，所以只需要在扫描线程堆栈以枚举根节点时停顿Java执行线程。</p><p>Shenandoah算法在<a href="https://www.researchgate.net/publication/306112816_Shenandoah_An_open-source_concurrent_compacting_garbage_collector_for_OpenJDK" target="_blank" rel="noopener">this PPPJ2016 paper</a>中有详细描述。</p><p>Shenandoah已经应用并且将由Red Hat提供aarch64和amd64支持。</p><p>在OpenJDK Shenandoah项目中的Shenandoah开发已经完成。在<a href="https://wiki.openjdk.java.net/display/shenandoah/Main" target="_blank" rel="noopener">Shenandoah wiki page</a>页面上查看有关当前开发流程，实现细节和可用性的更多详细信息。</p><p><strong>选择</strong>：</p><p>Zing/Azul有一个更低停顿的收集器，但是这项工作还没有贡献给OpenJDK。</p><p>ZGC有基于彩色指针的低停顿收集器， 我们期待比较两种策略的表现。</p><p>G1执行一些平行和并发工作，但它不执行并发回收（编者注：G1的筛选回收阶段，从Sun公司透漏出的信息来看，其实是支持与用户线程并发执行的，但是由于只会有一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率）。</p><p>CMS执行并发标记，但它在停顿时执行年轻代复制，并且从不整理老年代， 这导致花费更多时间来管理老年代中的可用空间以及碎片问题（编者注：CMS是基于“标记-清除”算法实现的收集器，这就意味着收集结束的时候将有大量的空间碎片产生）。</p><p><strong>建立和调用</strong>：</p><p>作为实验性功能，Shenandoah要求在命令行中配置<code>-XX:+UnlockExperimentalVMOptions</code>参数，构建系统会自动禁用不受支持的配置。下游构建者可以选择在其他支持的平台上使用<code>--with-jvm-features = -shenandoahgc</code>禁用构建Shenandoah。</p><p>要启用/使用Shenandoah GC，需要使用以下JVM选项：<code>-XX:+UnlockExperimentalVMOptions</code>                                <code>-XX:+UseShenandoahGC</code>。</p><p>想要获取有关如何设置和调整Shenandoah GC的更多信息，请参阅<a href="https://wiki.openjdk.java.net/display/shenandoah/Main" target="_blank" rel="noopener">Shenandoah wiki</a>页面。</p><p><strong>测试</strong>：</p><p>Red Hat已经为我们的重要应用程序进行了大量测试。我们开发了许多Shenandoah特定的jtreg测试。Shenandoah从Fedora 24开始在Fedora中传送，并在Rhel 7.4中作为技术预览。使用<code>-XX:+UseShenandoahGC</code>运行标准的OpenJDK测试就足够了。</p><p><strong>风险和假设</strong>：</p><p>GC接口（JEP 304）已集成在JDK 11中，之后对GC接口进行了许多扩展和改进，这样可以最大限度地降低将Shenanodah添加到OpenJDK源代码库的风险。除此之外，任何无法合理编址的Shenandoah-specific代码路径都将受到<code>#ifdef INCLUDE_SHENANDOAHGC</code>或类似机制的保护。Shenandoah GC最初将被标记为实验性功能，因此在配置参数方面除<code>-XX:+UseShenandoahGC</code>之外还需要<code>-XX:+UnlockExperimentalVMOptions</code>。</p><h4 id="JEP230-Microbenchmark-Suite"><a href="#JEP230-Microbenchmark-Suite" class="headerlink" title="JEP230: Microbenchmark Suite"></a><span id="jump230">JEP230: Microbenchmark Suite</span></h4><p>Microbenchmark 套件</p><p><strong>摘要</strong>：</p><p>在JDK源代码中添加一套基本的microbenchmarks ，使开发人员可以轻松运行现有的microbenchmarks 并创建新的microbenchmarks 。</p><p><strong>目标</strong>：</p><ul><li>基于[Java Microbenchmark Harness（JMH）];<a href="http://openjdk.java.net/projects/code-tools/jmh" target="_blank" rel="noopener">[1]</a></li><li>稳定且经过调整的benchmarks，针对持续性能测试<br> ​    ​    - 在feature release以及non-feature releases的Feature Complete milestone之后提供稳定且不移动的套件<br> ​    ​    - 支持与先前JDK版本的适用测试比较</li><li>简易<ul><li>轻松添加新benchmarks</li><li>在APIs和options更改、不推荐使用或在开发期间删除时，可以轻松更新测试</li><li>易于构建</li><li>易于查找和运行benchmark</li></ul></li><li>支持JMH更新</li><li>在组件中包含大约一百个benchmarks的初始集</li></ul><p><strong>非目标</strong>：</p><ul><li><p>为新的JDK功能提供benchmarks不是目标，为新功能添加benchmarks是这些项目的一部分。</p></li><li><p>创建一套完整的benchmarks来覆盖JDK中所有内容不是目标。随着时间的推移，该套件将继续通过新编写的benchmarks，或通过专门针对扩展其覆盖范围的协作进行扩展。</p></li><li><p>为处理microbenchmarks中的二进制依赖提供解决方案不是目标，稍后可能会添加对此的支持。</p></li></ul><p><strong>描述</strong>：</p><p>microbenchmark套件将与JDK源代码位于一个目录下，并且在构建时将生成单个JAR文件。协同定位将简化在开发期间添加和定位benchmarks。在运行benchmarks时，JMH提供强大的过滤功能，允许用户仅运行当前感兴趣的benchmarks，确切的位置仍有待确定。</p><p>Benchmarking 通常需要与早期build甚至release版本进行比较，因此microbenchmarks 必须支持JDK（N），用于针对新JDK和JDK（N-1）中的特性，以及存在于早期release版本中的特性的benchmarks 。 这意味着，对于JDK 12，结构和构建脚本必须支持JDK 12和JDK 11的编译benchmarks 。benchmarks 将进一步使用描述他们正在测试的JDK区域的Java包名称进行划分。</p><p>建议使用以下目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jdk/jdk</span><br><span class="line">   .../make/test (Shared folder for Makefiles)</span><br><span class="line">   .../test (Shared folder for functional tests)</span><br><span class="line">      .../micro/org/openjdk/bench</span><br><span class="line">         .../java (subdirectories similar to JDK packages and modules)</span><br><span class="line">         .../vm (subdirectories similar to HotSpot components)</span><br></pre></td></tr></table></figure><p>microbenchmark套件的构建将与普通的JDK构建系统集成。它将是一个单独的目标，在正常的JDK构建期间不会执行，以便为开发人员和其他对构建微基准套件不感兴趣的人保持较低的构建时间。要构建微基准套件，用户必须专门运行make build-microbenchmark或类似工具。另外，将支持使用<code>make test TEST =“micro：regexp”</code>运行基准测试。有关如何设置本地环境的说明将记录在<code>docs / testing.md | html</code>中。</p><p>benchmark将完全依赖于JMH，就像某些单元测试依赖于TestNG或jtreg一样，所以虽然对JMH的依赖是新的，但是构建的其他部分具有相似的依赖性。与jtreg相比的一个区别是JMH在构建期间都被使用，并且被打包为生成的JAR文件的一部分。</p><p>microbenchmark套件中的benchmark集将从<code>JMH JDK Microbenchmarks</code>项目中导入。这些构成了一组已在内部使用的经过调整和测试的microbenchmark。一个悬而未决的问题是，是将整个独立项目整体迁移到共处套件，还是将其作为更长寿命回归测试的stabilization forest。</p><p>但是，任何用户仍然希望确保其他参数（例如执行机器和JDK）在进行分析时是稳定且可比较的。在通常情况下，我们希望benchmark能够在不到一分钟的时间内完成整个运行。这不是大型或长期运行benchmark的包装框架；目标是提供一套快速且有针对性的benchmark。在某些特殊情况下，benchmark可能需要更长时间的预热或运行时间才能获得稳定的结果，但应尽可能避免这种情况。套件的目标不是充当大型工作负载的通用包装器；相反，意图是从更大的benchmark中提取关键组件或方法，并仅将该部分强调为microbenchmark。</p><p>作为该项目的一部分，将创建<a href="https://wiki.openjdk.java.net" target="_blank" rel="noopener">wiki.openjdk.java.net</a>上的新页面，以帮助解释如何开发新benchmarks并描述添加benchmark的要求。这些要求将要求遵守编码标准、可重现的性能，以及明确的benchmark测量文档及其测量内容。</p><p><strong>选择</strong>：</p><p>继续将microbenchmark套件维护为一个单独的项目<a href="http://openjdk.java.net/projects/code-tools/jmh-jdk-microbenchmarks/" target="_blank" rel="noopener">[2]</a>。</p><p>协同定位简化了为新功能添加benchmark，特别是在所有新功能开发的大部分在项目存储库（Valhalla，Amber等）中完成的世界中。 在单独的项目模型中被证明特别复杂的情况是测试对javac本身的更改，需要使用每个相应的JDK显式重建benchmark套件。 协同定位可以更优雅地解决这个特定用例，同时不禁止使用预先构建的benchmark捆绑包来在较长时间段内对稳定测试进行性能跟踪。</p><p><strong>测试</strong>：</p><p>作为常规性能测试的一部分，性能团队将验证microbenchmark测试，以确保仅添加稳定、调整好的和准确的microbenchmark测试。 还将根据具体情况对基准进行评估和分析，以确保其测试预期的功能。所有测试必须在所有适用的平台上运行多次，以确保它们稳定。</p><h4 id="JEP325-Switch-Expressions-Preview"><a href="#JEP325-Switch-Expressions-Preview" class="headerlink" title="JEP325:  Switch Expressions (Preview)"></a><span id="jump325">JEP325:  Switch Expressions (Preview)</span></h4><p><strong>摘要</strong>：</p><p>扩展switch语句，以便它可以用作语句或表达式，并且这两种形式都可以使用“traditional”或“simplified”的作用域，都可以实现对程序的流程控制。 这些更改将简化日常编码，并为在switch语句中使用模式匹配（JEP 305）做好准备。 </p><p><strong>动机</strong>：</p><p>当我们准备增强Java编程语言以支持模式匹配（JEP 305）时，现有switch语句的一些不规则性（长期以来一直是用户的烦恼）成为我们工作的障碍。这包括switch blocks的默认控制流行为（fall through），switch blocks的默认作用域，还包括对switch使用时仅作为语句，尽管作为表达式的话实现multi-way conditionals通常更自然。</p><p>当前Java的switch语句设计紧随C和C++等语言，并且默认支持fall-through语义。虽然这种传统的控制流通常用于编写low-level代码（例如用于二进制编码的解析器），但随着switch用于higher-level的contexts，其error-prone的性质开始超过其灵活性。</p><p>例如，在下面的代码中，许多break语句使它不必要地冗长，并且这种视觉干扰经常掩盖难以debug的错误，比如缺少break语句将导致发生意外的fall-through错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY:</span><br><span class="line">    <span class="keyword">case</span> FRIDAY:</span><br><span class="line">    <span class="keyword">case</span> SUNDAY:</span><br><span class="line">        System.out.println(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TUESDAY:</span><br><span class="line">        System.out.println(<span class="number">7</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> THURSDAY:</span><br><span class="line">    <span class="keyword">case</span> SATURDAY:</span><br><span class="line">        System.out.println(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY:</span><br><span class="line">        System.out.println(<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将引入一种新形式的switch label，写成“case L  - &gt;”，用来表示如果标签匹配则只执行标签右侧的代码。 例如， 前面的代码现在可以写成下面这种形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">case</span> TUESDAY                -&gt; System.out.println(<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">case</span> THURSDAY, SATURDAY     -&gt; System.out.println(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY              -&gt; System.out.println(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（此示例还使用多个case 标签：我们支持在单个switch label中多个标签以逗号分隔开。）</p><p>“case L  - &gt;”开关标签右侧的代码仅限于表达式、块或（为方便起见）throw语句。 这具有令人满意的结果，如果一条分支（arm）引入局部变量，则它必须包含在该分支的块中，不在 switch block中的任何其他分支的作用域内。 这消除了“traditional”作用域的switch block的另一个烦恼，即局部变量的范围是整个switch block。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY:</span><br><span class="line">    <span class="keyword">case</span> TUESDAY:</span><br><span class="line">        <span class="keyword">int</span> temp = ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY:</span><br><span class="line">    <span class="keyword">case</span> THURSDAY:</span><br><span class="line">        <span class="keyword">int</span> temp2 = ...     <span class="comment">// Why can't I call this temp?</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">int</span> temp3 = ...     <span class="comment">// Why can't I call this temp?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>许多现有的switch语句本质上是switch表达式的模拟，其中每个arm分配给一个公共目标变量或返回一个值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numLetters;</span><br><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY:</span><br><span class="line">    <span class="keyword">case</span> FRIDAY:</span><br><span class="line">    <span class="keyword">case</span> SUNDAY:</span><br><span class="line">        numLetters = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TUESDAY:</span><br><span class="line">        numLetters = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> THURSDAY:</span><br><span class="line">    <span class="keyword">case</span> SATURDAY:</span><br><span class="line">        numLetters = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY:</span><br><span class="line">        numLetters = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Wat: "</span> + day);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种作为语句进行表述是拐弯抹角的、重复的、并且容易出错。上面的代码旨在每天为numLetters赋一个值。直说的话，使用一个switch表达式将更清晰、更安全：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numLetters = <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY, FRIDAY, SUNDAY -&gt; <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">case</span> TUESDAY                -&gt; <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">case</span> THURSDAY, SATURDAY     -&gt; <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY              -&gt; <span class="number">9</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>反过来，将switch扩展到支持表达式会引发一些额外的需求，例如扩展流分析（表达式必须始终计算值或突然完成），并允许switch表达式的某些case arm抛出异常而不是产生值。</p><p><strong>描述</strong>：</p><p>除了“traditional”的switch block之外，我们还建议添加一个新的“simplified”形式，使用新的“case L  - &gt;”switch标签。如果标签匹配，则只执行箭头标签右侧的表达式或语句，并且没有fall through。例如，给定方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">howMany</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (k) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> -&gt; System.out.println(<span class="string">"one"</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span> -&gt; System.out.println(<span class="string">"two"</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span> -&gt; System.out.println(<span class="string">"many"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">howMany(<span class="number">1</span>);</span><br><span class="line">howMany(<span class="number">2</span>);</span><br><span class="line">howMany(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>得到以下输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">many</span><br></pre></td></tr></table></figure><p>我们将扩展switch语句，以便它可以另外作为表达式来使用。 在常见情况下，switch表达式如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T result = <span class="keyword">switch</span> (arg) &#123;</span><br><span class="line">    <span class="keyword">case</span> L1 -&gt; e1;</span><br><span class="line">    <span class="keyword">case</span> L2 -&gt; e2;</span><br><span class="line">    <span class="keyword">default</span> -&gt; e3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>switch表达式是多边表达式，如果目标类型已知，则将此类型下推到每个arm中。如果已知，switch表达式的类型是其目标类型；如果未知，则通过组合每个case arm的类型来计算独立的类型。</p><p>大多数switch表达式在“case L  - &gt;”开关标签的右侧都有一个表达式。 如果需要一个完整的块，我们扩展了break语句以获取一个参数，该参数成为封闭的switch表达式的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int j = switch (day) &#123;</span><br><span class="line">    case MONDAY  -&gt; 0;</span><br><span class="line">    case TUESDAY -&gt; 1;</span><br><span class="line">    default      -&gt; &#123;</span><br><span class="line">        int k = day.toString().length();</span><br><span class="line">        int result = f(k);</span><br><span class="line">        break result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与switch语句一样，switch表达式也可以使用带有“case L:”switch标签的“traditional”switch block。在这种情况下，将使用break with value语句生成值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = <span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Foo"</span>: </span><br><span class="line">        <span class="keyword">break</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Bar"</span>:</span><br><span class="line">        <span class="keyword">break</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">"Neither Foo nor Bar, hmmm..."</span>);</span><br><span class="line">        <span class="keyword">break</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两种形式的break（有值和无值）类似于方法中return的两种形式。两种形式的return都会立即终止方法的执行；在非void方法中，还必须提供一个值，该值被赋予方法的调用者。</p><p>switch表达式的case必须是详尽的，对于任何可能的值，必须有匹配的switch标签。实际上，这通常意味着只需要一个default子句；但是，如果枚举switch表达式涵盖了所有已知情况，default子句可以由编译器插入，即枚举定义在编译时和运行时之间发生了变化。</p><p>此外，switch表达式必须正常使用值完成，或抛出异常。编译器检查每个switch标签是否匹配，然后可以产生一个值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"Monday"</span>); </span><br><span class="line">        <span class="comment">// ERROR! Block doesn't contain a break with value</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line">i = <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY, TUESDAY, WEDNESDAY: </span><br><span class="line">        <span class="keyword">break</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">        System.out.println(<span class="string">"Second half of the week"</span>);</span><br><span class="line">        <span class="comment">// ERROR! Group doesn't contain a break with value</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>控制语句、break、return和continue不能跳过switch表达式，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">z: </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_VALUE; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="keyword">switch</span> (e) &#123; </span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:  </span><br><span class="line">                <span class="keyword">break</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">default</span>: </span><br><span class="line">                <span class="keyword">continue</span> z; </span><br><span class="line">                <span class="comment">// ERROR! Illegal jump through a switch expression </span></span><br><span class="line">        &#125;;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>同时，我们可以扩展switch以支持先前不允许的原始类型（及其装箱类型），例如float，double和long。</p><h4 id="JEP334-JVM-Constants-API"><a href="#JEP334-JVM-Constants-API" class="headerlink" title="JEP334: JVM Constants API"></a><span id="jump334">JEP334: JVM Constants API</span></h4><p><strong>摘要</strong>：</p><p>引入API来规范key class-file和run-time artifacts（特别是可从常量池加载的常量）的标称描述。</p><p><strong>动机</strong>：</p><p>每个Java类文件都有一个常量池，用于存储类中字节码指令的操作数。从广义上讲，常量池中的条目描述了运行时构件（如类和方法）或简单值（如字符串和整数）。所有这些条目都称为可加载常量，因为它们可以作为ldc指令的操作数（“加载常量”）。它们也可能出现在invokedynamic指令的bootstrap方法的静态参数列表中。执行ldc或invokedynamic指令会将可装入常量解析为标准Java类型的“实时”值，例如Class，String或int。</p><p>操作类文件的程序需要对字节码指令进行建模，然后再加载可加载的常量。但是，使用标准Java类型来规范可加载常量是不合适的。描述字符串（CONSTANT_String_info条目）的可加载常量可能是可以接受的，因为生成“实时”String对象很简单，但是对于描述类（CONSTANT_Class_info条目）的可加载常量是有问题的，因为生成“实时”类对象依赖于类加载的正确性和一致性。不幸的是，类加载有许多环境依赖和失败模式：所需的类不存在或者请求者可能无法访问；类加载的结果因上下文而异；装载类有副作用；有时类加载可能根本不可能（例如当所描述的类尚不存在或者不可加载时，如在编译那些相同的类期间，或在jlink-time转换期间）。</p><p>因此，处理可加载常量的程序如果能够以纯粹的名义符号形式操作类和方法，以及不太知名的构件（如方法句柄和动态计算常量），则会更简单：</p><ul><li><p>字节码解析和生成库必须以符号形式描述类和方法句柄。如果没有标准机制，它们必须求助于ad-hoc机制，无论是描述符类型（如ASM的Handle）还是字符串元组（方法所有者，方法名称，方法描述符），或者ad-hoc（和容易出错）的编码成一个字符串。</p></li><li><p>如果可以在符号域中工作而不是使用“实时”类和方法句柄，则通过旋转字节码（例如LambdaMetafactory）操作的invokedynamic的bootstraps会更简单。</p></li><li><p>编译器和脱机转换器（例如jlink插件）需要描述无法加载到正在运行的VM的类的类和成员。编译器插件（例如注释处理器）同样需要用符号术语来描述程序元素。</p></li></ul><p>这些类型的库和工具都将受益于使用单一，标准的方式来描述可加载常量。</p><p><strong>描述</strong>：</p><p>我们在新的java.lang.invoke.constant包中定义了一系列基于值的符号引用（JVMS 5.1）类型，能够描述每种可加载常量。符号引用描述了纯粹标称形式的可加载常量，与类加载或可访问性上下文分开。 有些类可以作为自己的符号引用（例如String）；对于可链接常量，我们定义了一系列符号引用类型（ClassDesc，MethodTypeDesc，MethodHandleDesc和DynamicConstantDesc），它们包含描述这些常量的标称信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/28/5c9c829850beb.jpg&quot; alt=&quot;OpenJDK.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;OpenJDK 12是由JSR 386在Java Community Process中指定的Java SE平台的版本12的开源参考实现，于2019年3月19日达到General Availability版本。GPL(General Public License)协议下的生产就绪二进制文件可从Oracle获得；其他供应商的二进制文件很快就会出现。&lt;/p&gt;
&lt;p&gt;该版本的功能和时间表是通过JEP流程提出和跟踪的，并由JEP 2.0提案进行了修订。该版本使用JDK Release Process（JEP 3）生成发布。&lt;/p&gt;
&lt;p&gt;本文根据OpenJDK 12的官方文档：&lt;a href=&quot;http://openjdk.java.net/projects/jdk/12/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OpenJDK 12&lt;/a&gt;，对其新特性进行整理，受本人翻译水平所限，难免有翻译或理解错误，望不吝指正。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="OpenJDK" scheme="http://yoursite.com/tags/OpenJDK/"/>
    
  </entry>
  
  <entry>
    <title>日志分析接口协议的设计与实现</title>
    <link href="http://yoursite.com/2019/03/25/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E6%8E%A5%E5%8F%A3%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/03/25/日志分析接口协议设计与实现/</id>
    <published>2019-03-25T09:35:20.701Z</published>
    <updated>2019-03-26T03:26:54.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p><img src="https://cdn2.iconfinder.com/data/icons/productivity-social-vol-2/512/checkmark_approve-128.png" alt="Choice"><br>通过日志信息对RPC服务调用的用户进行监控，提高系统的稳定性。本文简要记录了一下日志分析接口协议的设计与实现.<br><a id="more"></a></p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="HTTP接口"><a href="#HTTP接口" class="headerlink" title="HTTP接口"></a>HTTP接口</h3><p>请求方式： <code>post</code><br>请求参数： </p><ul><li>HTTP header<br><code>Content-Type=application/json    （必须）</code></li><li><p>HTTP body</p><pre><code>{</code></pre><p>  ​        “log_project_name”:”testhttp”,<br>  ​        “log_message_type”:”request”,<br>  ​        “log_format”:”default”,<br>  ​        “log_from”:”172.0.0.1”,<br>  ​        “log_content”:”2017-06-28 22:39:44,959 [P58,] communicationInfo - {\”cid\”:\”1111\”,\”clientIP\”:\”10.10.10.10\”,\”request\”:\”simpleSearch\”,\”timeAll\”:107,\”respLength\”:55555}”<br>  ​    }<br>  ​    </p></li></ul><p>body中为JSON字符串<br>JSON参数</p><blockquote><p>log_project_name：项目名称 同一个项目使用同一个名称<br>log_message_type：日志类型request (请求日志),error(错误日志)<br>log_format：日志格式default<br>log_from：日志来源机器每台机器写自己的IP作为一个标示<br>log_content：根据日志类型发送的日志内容（日志内容格式请见下文）</p></blockquote><h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><p>读取日志文件（日志内容格式请见下文）</p><h3 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h3><p>日志格式为两种</p><h4 id="日志格式为-request-解析类型为-default-日志为一行"><a href="#日志格式为-request-解析类型为-default-日志为一行" class="headerlink" title="日志格式为 request 解析类型为 default 日志为一行"></a>日志格式为 <code>request</code> 解析类型为 <code>default</code> 日志为一行</h4><p>示例:</p><pre><code>2017-06-21 22:37:44,959  -  {&quot;cid&quot;:&quot;1111&quot;,&quot;clientIP&quot;:&quot;10.10.10.10&quot;,&quot;request&quot;:&quot;simpleSearch&quot;,&quot;timeAll&quot;:107, &quot;respLength&quot;:55555}</code></pre><p>请求日志内容格式 分为3块</p><ol><li>时间开头格式必须为 <code>yyyy-MM-dd HH:mm:ss,SSS</code></li><li>分隔符 <code>-</code></li><li>JSON内容<blockquote><p>cid：用户ID<br> clientIP：客户端IP<br> request：请求业务类型<br> timeAll：耗时<br> respLength：返回大小</p></blockquote></li></ol><p><strong>注意：json中字段为必填字段若没有值则使用空字符串</strong></p><h4 id="日志格式为-error-解析类型为-default-日志可以为多行"><a href="#日志格式为-error-解析类型为-default-日志可以为多行" class="headerlink" title="日志格式为 error 解析类型为 default 日志可以为多行"></a>日志格式为 <code>error</code> 解析类型为 <code>default</code> 日志可以为多行</h4><p>示例</p><pre><code>2017-06-19 22:54:58,151  InfoThreadPool requestInfo http://www.eastmoney.com/ open error</code></pre><p>错误日志内容格式 分为2块</p><ol><li>时间开头格式必须为<code>yyyy-MM-dd HH:mm:ss,SSS</code></li><li>错误内容<br>注意:错误日志读取时，只匹配日志开头是否为此格式的时间，最多读取500行，当行中出现<code>eastmoney</code>关键字时，停止读取。</li></ol><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><h4 id="每一台服务器的访问情况"><a href="#每一台服务器的访问情况" class="headerlink" title="每一台服务器的访问情况"></a>每一台服务器的访问情况</h4><ul><li><code>LoginHandler</code>每次登录输出日志</li><li>日志内容字段<blockquote><p>cid：用户ID<br>  clientIP：客户端IP<br>  request：请求业务类型<br>  timeAll：耗时<br>  respLength：返回大小</p></blockquote></li></ul><h4 id="每个用户所做的操作"><a href="#每个用户所做的操作" class="headerlink" title="每个用户所做的操作"></a>每个用户所做的操作</h4><ul><li>调用Handler的doHandle()时输出日志<blockquote><p>cid：用户ID<br>  clientIP：客户端IP<br>  request：请求业务类型<br>  timeAll：耗时<br>  respLength：返回大小</p></blockquote></li></ul><p>count_info</p><pre><code>机房，服务器类型，服务器ip，服务器端口，用户数，时间，备注area,server_type,server_ip,server_port,count,time,desc</code></pre><p>user_log</p><pre><code>用户id,客户端ip,客户端端口,服务器ip，服务器端口，请求id，时间，备注clientid,remote_server,remote_port,server_ip,server_port,request_id,time,desc</code></pre><h4 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h4><p><strong>LIST_10.10.10.10_80-1818-443_sys.2017110620.log</strong></p><ul><li><p>request_id为 <strong>-1</strong>，预留位desc赋值为当前用户数（链接数），每分钟打印一次</p><blockquote><p>2017-10-30 13:26:00.574 - {“clientid”:””,”remote_server”:””,”remote_port”:””,”server_port”:””,”request_id”:-1,”desc”:”500”}</p></blockquote></li><li><p>request_id为 <strong>-2</strong>，预留位desc赋值为链接断线原因</p><blockquote><p>2017-10-30 13:26:00.574 - {“clientid”:”22000000000”,”remote_server”:”10.10.10.10”,”remote_port”:”30040”,”server_port”:”1818”,”request_id”:-2,”desc”:0}</p></blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> UNKNOWN = <span class="number">0</span>;   <span class="comment">//未知</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> WRITE_WAITE_MANY_TIMES = <span class="number">1</span>;   <span class="comment">//写等待次数过多</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> FORCE_NO_CANCEL_REQUEST = <span class="number">2</span>;   <span class="comment">//强制去除，客户端没有发送取消请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> CHANNEL_GROUP_CHECK = <span class="number">3</span>;   <span class="comment">//ChannelGroup检查关闭</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> HANDLER_EXCEPTION = <span class="number">4</span>;   <span class="comment">//Handler exceptionCaught触发</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> HANDLER_CLOSED = <span class="number">5</span>;   <span class="comment">//Handler Closed触发</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> CHANNEL_EXCEPTION = <span class="number">6</span>;   <span class="comment">//Handler Closed触发</span></span><br></pre></td></tr></table></figure></li><li><p>正常打印请求信息</p><blockquote><p>2017-10-30 13:26:00.574 - {“clientid”:”22000000000”,”remote_server”:”10.10.10.10”,”remote_port”:”30040”,”server_port”:”1818”,”request_id”:16066,”desc”:””}</p></blockquote></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>logback的使用和logback.xml详解:<a href="http://www.cnblogs.com/warking/p/5710303.html" target="_blank" rel="noopener">http://www.cnblogs.com/warking/p/5710303.html</a><br>logback.xml配置:<a href="http://blog.csdn.net/qq173684423/article/details/53611906" target="_blank" rel="noopener">http://blog.csdn.net/qq173684423/article/details/53611906</a><br>logback配置详解<a href="http://blog.csdn.net/haidage/article/details/6794509" target="_blank" rel="noopener">http://blog.csdn.net/haidage/article/details/6794509</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn2.iconfinder.com/data/icons/productivity-social-vol-2/512/checkmark_approve-128.png&quot; alt=&quot;Choice&quot;&gt;&lt;br&gt;通过日志信息对RPC服务调用的用户进行监控，提高系统的稳定性。本文简要记录了一下日志分析接口协议的设计与实现.&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
      <category term="RPC" scheme="http://yoursite.com/tags/RPC/"/>
    
      <category term="logback" scheme="http://yoursite.com/tags/logback/"/>
    
  </entry>
  
  <entry>
    <title>同步、异步、阻塞、非阻塞IO</title>
    <link href="http://yoursite.com/2019/01/29/%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9EIO/"/>
    <id>http://yoursite.com/2019/01/29/同步、异步、阻塞、非阻塞IO/</id>
    <published>2019-01-29T06:58:00.260Z</published>
    <updated>2019-01-31T06:43:45.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近在整理过去一段时间内Netty性能调优的工作，涉及到了Netty的NIO/Epoll等异步非阻塞通信，索性复习一下常见的几种IO模型。看到CSDN上这篇文章写得很清晰易懂，<a href="https://blog.csdn.net/historyasamirror/article/details/5778378" target="_blank" rel="noopener">IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）</a>，在此基础上整理了一下，方便记忆及以后查看。</p><a id="more"></a><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>IO发生时会经历两个阶段：</p><ul><li><p>等待数据</p></li><li><p>将数据从内核复制到用户空间</p></li></ul><p>不同的IO模型就是根据在这两个阶段所做的处理不同进行区分的。</p><h3 id="Blocking-IO"><a href="#Blocking-IO" class="headerlink" title="Blocking IO"></a>Blocking IO</h3><p><img src="https://i.loli.net/2019/01/30/5c5151d73a80d.jpg" alt="blocking IO.jpg"></p><p><strong>阻塞IO模型（BIO）</strong>：应用进程调用recvfrom，kernel开始了IO的第一阶段：等待数据，等到数据准备好了，kernel开始第二阶段：将数据从内核复制到用户空间。在IO的这两个阶段执行期间，应用进程一直处于block状态，直到kernel返回结果，应用进程阻塞才解除。</p><p>举例：你在美团上点了一份外卖，下单后外卖小哥开始取餐（阶段一），取到餐后再进行配送（阶段二），期间你一直站在门口等（block状态），直到收到外卖才继续自己的事情。</p><h3 id="Nonblocking-IO"><a href="#Nonblocking-IO" class="headerlink" title="Nonblocking IO"></a>Nonblocking IO</h3><p><img src="https://i.loli.net/2019/01/30/5c5151d7b62f1.jpg" alt="non-blocking IO.jpg"></p><p><strong>非阻塞IO模型（NIO）</strong>：应用进程调用recvfrom，kernel开始了IO的第一阶段：等待数据，如果kernel中的数据还没有准备好，就返回应用进程EWOULDBLOCK，应用进程收到返回后会一直调用recvfrom询问kernel，直到数据准备好，在此期间应用进程处于非block状态；然后kernel将数据从内核复制到用户空间，并block应用进程，直到成功返回后阻塞状态解除。所以非阻塞IO和阻塞IO不是完全对立的，在IO第二阶段二者均处于block状态。</p><p>举例：你在美团上点了一份外卖，下单后外卖小哥开始取餐（阶段一），在取餐期间你坐在屋里一遍看剧一边不断打电话给外卖小哥询问取到了没，直到小哥说他拿到了；这时小哥取到餐后进行配送（阶段二），你也起身站在门口等（block状态），直到收到外卖。</p><h3 id="IO-multiplexing"><a href="#IO-multiplexing" class="headerlink" title="IO multiplexing"></a>IO multiplexing</h3><p><img src="https://i.loli.net/2019/01/30/5c5151d7af63b.jpg" alt="IO multiplexing.jpg"></p><p><strong>IO复用模型</strong>：应用进程调用select，通过select可以不断的轮询所负责的所有socket，当某个socket的数据准备好了，select就会返回信息，然后用户态进程调用recvfrom，将数据从内核复制到用户空间。对于每一个socket，一般都设置成为non-blocking，但是整个应用进程受阻于select调用；同样，在IO的第二阶段，应用进程也是出于block状态。</p><p>如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于单个process就可以同时处理多个网络连接的IO。</p><p>Linux关于IO复用的使用，有三种不同的API，select、poll和epoll，关于这三种API的实现分析，可以参考下这篇文章：<a href="https://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="noopener">select、poll、epoll之间的区别总结[整理]</a>。</p><p>举例：这次你在美团上一次点了好几份外卖，美团的消息系统（select等API调用）推给你说等有外卖取到了就发消息给你，让你留意消息（block状态），然后几个外卖小哥就到不同的店去取餐（阶段一）。等取到餐了，如果你用的是select或poll版本的美团，消息推给你说你有订单已经取到了，但是不告诉你是哪家；如果你用的是epoll版本的美团，消息推给你说你有订单已经取到了，而且还告诉你是碳烤羊排。收到消息之后你就到门口去等（block状态），外卖小哥进行配送（阶段二），直到收到外卖才继续自己的事情。</p><h3 id="Asynchronous-IO"><a href="#Asynchronous-IO" class="headerlink" title="Asynchronous IO"></a>Asynchronous IO</h3><p><img src="https://i.loli.net/2019/01/30/5c5151d704ff1.jpg" alt="Asynchronous IO.jpg"></p><p><strong>异步IO模型（AIO）</strong>：应用进程调用aio_read，kernel收到请求后会立刻返回，等数据准备好，并且复制到用户空间后执行事先指定好的函数，整个过程应用进程都处于非block状态。</p><p>举例：你发现自己出去等太大笨蛋了，在美团上点了一份外卖，看到下单成功后就去看剧了。外卖小哥开始取餐（阶段一），取到餐后再进行配送（阶段二），最后送到你门口，整个过程你都在干自己的事情，没有一直等着（非block状态）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="IO模型对比"><a href="#IO模型对比" class="headerlink" title="IO模型对比"></a>IO模型对比</h3><p><img src="https://i.loli.net/2019/01/30/5c5151d774bba.jpg" alt="IO Models.jpg"></p><p>因为信号驱动式IO（signal-driven I/O）使用较少，正文中没提及。</p><p><strong>阻塞IO和非阻塞IO</strong>：调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p><p><strong>同步IO和异步IO</strong>：synchronous IO做”IO operation”的时候会将process阻塞，blocking IO，non-blocking IO，IO multiplexing因为都阻塞于recvfrom调用，都属于synchronous IO。</p><p><strong>非阻塞IO和异步IO</strong>：在数据准备阶段，non-blocking IO中进程不会被block，但是它仍然要求进程去主动的check，而asynchronous IO中应用进程进程将整个IO操作交给kernel来完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;最近在整理过去一段时间内Netty性能调优的工作，涉及到了Netty的NIO/Epoll等异步非阻塞通信，索性复习一下常见的几种IO模型。看到CSDN上这篇文章写得很清晰易懂，&lt;a href=&quot;https://blog.csdn.net/historyasamirror/article/details/5778378&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）&lt;/a&gt;，在此基础上整理了一下，方便记忆及以后查看。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>读懂Young GC日志</title>
    <link href="http://yoursite.com/2018/12/18/%E8%AF%BB%E6%87%82Young%20GC%E6%97%A5%E5%BF%97/"/>
    <id>http://yoursite.com/2018/12/18/读懂Young GC日志/</id>
    <published>2018-12-18T06:46:08.526Z</published>
    <updated>2018-12-19T01:41:01.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>在进行JVM调优时我们经常需要通过日志信息来分析G1GC的性能，本文就日志中可供收集的数据和信息进行了简单介绍。<br><a id="more"></a></p><h2 id="Young-GC日志"><a href="#Young-GC日志" class="headerlink" title="Young GC日志"></a>Young GC日志</h2><p>下面选取了SZVPC线上报价服务的一段Young GC日志：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;Heap before GC invocations=<span class="number">38623</span> (full <span class="number">4</span>):</span><br><span class="line"> garbage-first heap   total <span class="number">25165824</span>K, used <span class="number">11321508</span>K [<span class="number">0x00000001c0000000</span>, <span class="number">0x00000001c040c000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  region size <span class="number">4096</span>K, <span class="number">307</span> young (<span class="number">1257472</span>K), <span class="number">26</span> survivors (<span class="number">106496</span>K)</span><br><span class="line"> Metaspace       used <span class="number">23093</span>K, capacity <span class="number">23236</span>K, committed <span class="number">29440</span>K, reserved <span class="number">1075200</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 2444<span class="title">K</span>, <span class="title">capacity</span> 2510<span class="title">K</span>, <span class="title">committed</span> 3328<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line">2018-12-18T11:19:27.084+0800: 671040.790: [GC pause (G1 Evacuation Pause) (young), 0.3639131 secs]</span><br><span class="line">   [Parallel Time: <span class="number">354.4</span> ms, GC Workers: <span class="number">13</span>]</span><br><span class="line">      [<span class="function">GC Worker <span class="title">Start</span> <span class="params">(ms)</span>: Min: 671040790.4, Avg: 671040790.6, Max: 671040790.8, Diff: 0.4]</span></span><br><span class="line"><span class="function">      [Ext Root <span class="title">Scanning</span> <span class="params">(ms)</span>: Min: 0.8, Avg: 1.0, Max: 1.2, Diff: 0.4, Sum: 13.0]</span></span><br><span class="line"><span class="function">      [Update <span class="title">RS</span> <span class="params">(ms)</span>: Min: 22.6, Avg: 23.0, Max: 23.6, Diff: 1.0, Sum: 299.6]</span></span><br><span class="line"><span class="function">         [Processed Buffers: Min: 24, Avg: 32.5, Max: 39, Diff: 15, Sum: 422]</span></span><br><span class="line"><span class="function">      [Scan <span class="title">RS</span> <span class="params">(ms)</span>: Min: 201.4, Avg: 202.0, Max: 202.4, Diff: 1.0, Sum: 2625.9]</span></span><br><span class="line"><span class="function">      [Code Root <span class="title">Scanning</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.0, Sum: 0.2]</span></span><br><span class="line"><span class="function">      [Object <span class="title">Copy</span> <span class="params">(ms)</span>: Min: 126.9, Avg: 127.2, Max: 127.8, Diff: 0.9, Sum: 1653.5]</span></span><br><span class="line"><span class="function">      [<span class="title">Termination</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.6, Max: 0.9, Diff: 0.9, Sum: 8.3]</span></span><br><span class="line"><span class="function">         [Termination Attempts: Min: 1, Avg: 278.6, Max: 349, Diff: 348, Sum: 3622]</span></span><br><span class="line"><span class="function">      [GC Worker <span class="title">Other</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.1, Max: 0.3, Diff: 0.2, Sum: 1.6]</span></span><br><span class="line"><span class="function">      [GC Worker <span class="title">Total</span> <span class="params">(ms)</span>: Min: 353.8, Avg: 354.0, Max: 354.2, Diff: 0.4, Sum: 4602.1]</span></span><br><span class="line"><span class="function">      [GC Worker <span class="title">End</span> <span class="params">(ms)</span>: Min: 671041144.5, Avg: 671041144.6, Max: 671041144.7, Diff: 0.2]</span></span><br><span class="line"><span class="function">   [Code Root Fixup: 0.0 ms]</span></span><br><span class="line"><span class="function">   [Code Root Purge: 0.0 ms]</span></span><br><span class="line"><span class="function">   [Clear CT: 1.7 ms]</span></span><br><span class="line"><span class="function">   [Other: 7.8 ms]</span></span><br><span class="line"><span class="function">      [Choose CSet: 0.0 ms]</span></span><br><span class="line"><span class="function">      [Ref Proc: 0.6 ms]</span></span><br><span class="line"><span class="function">      [Ref Enq: 0.0 ms]</span></span><br><span class="line"><span class="function">      [Redirty Cards: 2.5 ms]</span></span><br><span class="line"><span class="function">      [Humongous Register: 0.2 ms]</span></span><br><span class="line"><span class="function">      [Humongous Reclaim: 0.1 ms]</span></span><br><span class="line"><span class="function">      [Free CSet: 3.0 ms]</span></span><br><span class="line"><span class="function">   [Eden: 1124.0<span class="title">M</span><span class="params">(<span class="number">1124.0</span>M)</span>-&gt;0.0<span class="title">B</span><span class="params">(<span class="number">1132.0</span>M)</span> Survivors: 104.0M-&gt;96.0M Heap: 10.8<span class="title">G</span><span class="params">(<span class="number">24.0</span>G)</span>-&gt;9968.2<span class="title">M</span><span class="params">(<span class="number">24.0</span>G)</span>]</span></span><br><span class="line"><span class="function">Heap after GC invocations</span>=<span class="number">38624</span> (full <span class="number">4</span>):</span><br><span class="line"> garbage-first heap   total <span class="number">25165824</span>K, used <span class="number">10207396</span>K [<span class="number">0x00000001c0000000</span>, <span class="number">0x00000001c040c000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  region size <span class="number">4096</span>K, <span class="number">24</span> young (<span class="number">98304</span>K), <span class="number">24</span> survivors (<span class="number">98304</span>K)</span><br><span class="line"> Metaspace       used <span class="number">23093</span>K, capacity <span class="number">23236</span>K, committed <span class="number">29440</span>K, reserved <span class="number">1075200</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 2444<span class="title">K</span>, <span class="title">capacity</span> 2510<span class="title">K</span>, <span class="title">committed</span> 3328<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"> [Times: user=4.64 sys=0.00, real=0.36 secs]</span><br></pre></td></tr></table></figure></p><h4 id="日志信息详解："><a href="#日志信息详解：" class="headerlink" title="日志信息详解："></a>日志信息详解：</h4><ul><li><p><strong>garbage-first heap   total 25165824K, used 11321508K [0x00000001c0000000, 0x00000001c040c000, 0x00000007c0000000)</strong></p><p>可以看出GC的类型为G1，Heap的总大小为25165824K，已使用11321508K。</p></li><li><p><strong>region size 4096K, 307 young (1257472K), 26 survivors (106496K)</strong></p><p>每个region的大小为4096K，新生代307个region，survivor区26个region。</p></li><li><p><strong>Metaspace       used 23093K, capacity 23236K, committed 29440K, reserved 1075200K<br> class space    used 2444K, capacity 2510K, committed 3328K, reserved 1048576K</strong></p><p>java8去掉了永久区（Permanent），新增元数据区（Metaspace）。</p></li><li><p><strong>671040.790: [GC pause (G1 Evacuation Pause) (young), 0.3639131 secs]</strong></p><p>G1停顿清理(young) regions，即新生代minor GC。本次停顿在JVM启动后671040.790 s后触发，且停顿持续时间为0.3639131 s，根据系统时间（wall clock time）测定。</p></li><li><p><strong>[Parallel Time: 354.4 ms, GC Workers: 13]</strong></p><p>收集过程是多线程并发执行的，日志表明在354.4ms（real time）时间内，下面的活动是由13个线程并行完成的：</p><ol><li><p><code>GC Worker Start (ms)</code></p><p>收集线程开始的时间，匹配停顿开始时的时间戳。使用的是相对时间，Min是最早开始时间，Avg是平均开始时间，Max是最晚开始时间，Diff是Max-Min。 如果Min和Max差别很大，那么可能表明使用了太多线程或者机器上的其他进程正在从JVM内部的垃圾收集进程中窃取CPU时间。</p></li><li><p><code>Ext Root Scanning (ms)</code></p><p>扫描外部（非heap）roots如类加载器、JNI引用、JVM 系统roots等的耗时，Sum是Cpu time。</p></li><li><p><code>Update RS (ms)</code></p><p>每个线程更新Remembered Set的耗时。</p></li><li><p><code>Scan RS (ms)</code></p><p>扫描CS中的region对应的RSet，因为RSet是points-into，所以这样实现避免了扫描old generadion region，但是会产生float garbage。</p></li><li><p><code>Code Root Scanning (ms)</code></p><p>扫描code roots如本地变量的耗时。code roots指的是经过JIT编译后的代码里，引用了heap中的对象。引用关系保存在RSet中。</p></li><li><p><code>Object Copy (ms)</code></p><p>从收集region拷贝存活的对象到新region的耗时。</p></li><li><p><code>Termination (ms)</code></p><p>工作线程确保它们能够安全地停止并且没有更多的工作要做最终终止所用的耗时。在结束前，它会检查其他线程是否还有未扫描完的引用，如果有，则”偷”过来，完成后再申请结束，这个时间是线程之前互相同步所花费的时间。</p><ul><li><p><code>Termination Attempts</code></p><p>工作线程尝试终止的次数，如果实际还有更多的工作要做，那么尝试就会失败，现在终止还为时过早。</p></li></ul></li><li><p><code>GC Worker Other (ms)</code></p><p>花费在其他杂项（不值得在日志中单独占用一个部分）上的时间。</p></li><li><p><code>GC Worker Total (ms)</code></p><p>所用工作线程耗时之和。</p></li><li><p><code>GC Worker End (ms)</code></p><p>每个线程结束的时间戳，通常它们应该大致相等。</p></li></ol></li><li><p><strong>[Code Root Fixup: 0.0 ms]</strong></p><p>用来将code root修正到正确的evacuate之后的对象位置所花费的时间。</p></li><li><p><strong>[Code Root Purge: 0.0 ms]</strong></p><p>清除code root的耗时，code root中的引用已经失效，不再指向Region中的对象，所以需要被清除。</p></li><li><p><strong>[Clear CT: 1.7 ms]</strong></p><p>清除RSet的card table的耗时，这个任务在serial模式下执行。</p></li><li><p><strong>[Other: 7.8 ms]</strong></p><p>下面所列的其他事项共耗时7.8ms：</p><ol><li><p><code>[Choose CSet: 0.0 ms]</code></p><p>查找Collection Set的region的耗时；</p></li><li><p><code>[Ref Proc: 0.6 ms]</code></p><p>Reference Process， 处理引用对象的耗时；</p></li><li><p><code>[Ref Enq: 0.0 ms]</code></p><p>Reference enqueue，引用对象排队到引用队列的耗时；</p></li><li><p><code>[Redirty Cards: 2.5 ms]</code>略</p></li><li><p><code>[Humongous Register: 0.2 ms]</code>略</p></li><li><p><code>[Humongous Reclaim: 0.1 ms]</code>略</p></li><li><p><code>[Free CSet: 3.0 ms]</code></p><p>清理Collection Set数据结构的耗时；</p></li></ol></li><li><p><strong>[Eden: 1124.0M(1124.0M)-&gt;0.0B(1132.0M) Survivors: 104.0M-&gt;96.0M Heap: 10.8G(24.0G)-&gt;9968.2M(24.0G)]</strong></p><p>分别代表：停顿前后Eden区已用内存和容量；停顿前后Survivor区使用的内存；停顿前后整个Heap已用内存和容量。</p></li><li><p><strong>[Times: user=4.64 sys=0.00, real=0.36 secs]</strong></p><p>整个GC事件的持续时间，从以下不同的类别来测量：</p><ol><li><p><strong>user</strong> - 本次垃圾收集中GC线程所消耗的总体CPU时间；</p></li><li><p><strong>sys</strong> - OS调用或等待系统事件的耗时；</p></li><li><p><strong>real</strong> - 应用程序停止的时间（Clock time）。在GC活动可并行执行的情况下，这个数值理想上应为：（user时间 + sys时间）/ GC所用的线程数，在这个case里线程数是13。要注意的是，有些活动不能并行执行，因此该数值总会超过这个比例一定数量。</p></li></ol></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html" target="_blank" rel="noopener">Getting Started with the G1 Garbage Collector</a></p><p><a href="https://blogs.oracle.com/poonam/understanding-g1-gc-logs" target="_blank" rel="noopener">Understanding G1 GC Logs</a></p><p><a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations/g1/evacuation-pause-fully-young" target="_blank" rel="noopener">JAVA GARBAGE COLLECTION HANDBOOK</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;在进行JVM调优时我们经常需要通过日志信息来分析G1GC的性能，本文就日志中可供收集的数据和信息进行了简单介绍。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="G1GC" scheme="http://yoursite.com/tags/G1GC/"/>
    
  </entry>
  
  <entry>
    <title>JDK命令行工具</title>
    <link href="http://yoursite.com/2018/12/13/JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/12/13/JDK命令行工具/</id>
    <published>2018-12-13T02:10:02.308Z</published>
    <updated>2019-01-31T09:11:08.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>前一阵接口服务性能调优的时候，零零星星地用到一些JDK自带的命令行工具。当服务部署到生产环境时，有一些性能诊断工具因为环境原因可能会受到限制，但是通过使用这些JDK自带的监控工具，我问可以直接在应用程序中实现强大的监控分析功能。这些工具在<strong>《深入理解Java虚拟机》</strong>和<strong>《Java性能权威指南》</strong>中都有系统性的介绍，本文也权当是一篇学习笔记，顺便对之前调优过程中的使用做一下梳理。</p><a id="more"></a><h2 id="常用的JDK命令行工具"><a href="#常用的JDK命令行工具" class="headerlink" title="常用的JDK命令行工具"></a>常用的JDK命令行工具</h2><table><thead><tr><th style="text-align:left">请求ID</th><th style="text-align:left">主要作用</th></tr></thead><tbody><tr><td style="text-align:left">jps</td><td style="text-align:left">JVM Process Status Tool，显示指定系统内所有的HotSpot虚拟机进程</td></tr><tr><td style="text-align:left">jstat</td><td style="text-align:left">JVM Statistics Monitoring Tool，用于收集Hotspot虚拟机各方面的运行数据</td></tr><tr><td style="text-align:left">jinfo</td><td style="text-align:left">Configuration Info for Java，显示虚拟机配置信息</td></tr><tr><td style="text-align:left">jmap</td><td style="text-align:left">JVM Memory Map，生成虚拟机的内存转储快照，生成heapdump文件</td></tr><tr><td style="text-align:left">jhat</td><td style="text-align:left">JVM Heap Dump Browser，用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户在浏览器上查看分析结果</td></tr><tr><td style="text-align:left">jstack</td><td style="text-align:left">JVM Stack Trace，显示虚拟机的线程快照</td></tr><tr><td style="text-align:left">jcmd</td><td style="text-align:left">打印Java进程所涉及的基本类、线程和VM信息</td></tr><tr><td style="text-align:left">jconsole</td><td style="text-align:left">提供JVM活动的图形化视图，包括线程的使用、类的使用和GC活动</td></tr><tr><td style="text-align:left">jvisualvm</td><td style="text-align:left">监控JVM的GUI工具，可用来剖析运行的应用，分析JVM堆转储</td></tr></tbody></table><p>这些工具可以广泛用于以下领域：</p><ul><li>基本的VM信息</li><li>线程信息</li><li>类信息</li><li>实时GC分析</li><li>堆转储的事后处理</li><li>JVM的性能分析</li></ul><h2 id="常用命令介绍"><a href="#常用命令介绍" class="headerlink" title="常用命令介绍"></a>常用命令介绍</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p><strong>命令格式</strong>：</p><p><code>jps [ options ] [ hostid ]</code></p><p><strong>options</strong>：</p><p><code>-q</code> 只输出本地虚拟机进程ID，省略主类名 </p><p><code>-m</code> 输出虚拟机进程启动时传递给main()函数的参数</p><p><code>-l</code> 输出进程执行的主类的全名 </p><p><code>-v</code> 输出虚拟机进程启动时的JVM参数 </p><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p><strong>命令格式</strong>：</p><p><code>jstat [ option vmid [interval[s|ms] [count]] ]</code></p><p><strong>options</strong>：</p><p><code>-class</code>监视类装载，卸载数量，总空间以及类装载所耗费的时间</p><p><code>-gc</code> 监视Java堆状况，包括Eden区，两个survivor区，老年代，永久代的容量，已用空间，GC时间合计等信息</p><p><code>-gccapacity</code> 内容与-gc基本相同，但主要输出Java堆各个区域的最大最小空间</p><p><code>-gcutil</code> 内容与-gc基本相同，但主要关注已使用空间占总空间的百分比</p><p><code>-gccause</code> 内容与-gcutil基本相同，但主要关注已使用空间占总空间的百分比,并输出导致上一次GC的原因</p><p><code>-gcnew</code> 监视新生代GC情况</p><p><code>-gcnewcapacity</code> 内容与-gcnew基本相同，但主要输出使用到的最大最小空间</p><p><code>-gcold</code> 监视老年代GC情况</p><p><code>-gcoldcapacity</code> 内容与-gcnew基本相同，但主要输出使用到的最大最小空间</p><p><code>-gcpermcapacity</code> 输出永久代使用到的最大最小空间</p><p><code>-complier</code> 输出JIT 编译器编译过的方法耗时的信息</p><p><code>-printcompliter</code> 输出已经被JIT编译的方法</p><h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p><strong>命令格式</strong>：</p><p><code>jinfo [ option ] pid</code></p><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p><strong>命令格式</strong>：</p><p><code>jinfo [ option ] vmid</code></p><p><strong>options</strong>：</p><p><code>-dump</code> 生成Java堆转储快照，格式为： -dump:[live , ]format=b , file=,其中live子参数 说明只dump出存活的对象</p><p><code>-finalizerinfo</code> 显示在F-Queue中等待Finalizer线程执行finalize方法的对象</p><p><code>-heap</code> 显示Java堆详细信息，如使用哪种回收器，参数配置，分代状况等 </p><h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p><strong>命令格式</strong>：</p><p><code>jhat heapdumpFileName</code></p><h3 id="jatack"><a href="#jatack" class="headerlink" title="jatack"></a>jatack</h3><p><strong>命令格式</strong>：</p><p><code>jstack [ option ] vmid</code></p><p><strong>options</strong>：</p><p><code>-F</code> 当正常输出的请求不被响应时，强制输出线程堆栈</p><p><code>-l</code> 除堆栈外，显示关于锁的附加信息</p><p><code>-m</code> 如果调用到本地方法的话，可以显示C/C++的堆栈</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;前一阵接口服务性能调优的时候，零零星星地用到一些JDK自带的命令行工具。当服务部署到生产环境时，有一些性能诊断工具因为环境原因可能会受到限制，但是通过使用这些JDK自带的监控工具，我问可以直接在应用程序中实现强大的监控分析功能。这些工具在&lt;strong&gt;《深入理解Java虚拟机》&lt;/strong&gt;和&lt;strong&gt;《Java性能权威指南》&lt;/strong&gt;中都有系统性的介绍，本文也权当是一篇学习笔记，顺便对之前调优过程中的使用做一下梳理。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>线上服务CPU负载高问题排查（一）</title>
    <link href="http://yoursite.com/2018/12/06/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1CPU%E8%B4%9F%E8%BD%BD%E9%AB%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/12/06/线上服务CPU负载高问题排查（一）/</id>
    <published>2018-12-06T05:49:15.410Z</published>
    <updated>2019-03-25T06:37:16.984Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>使用Arthas定位CPU占用率过高的问题，</p><p>挖坑待填…</p><a id="more"></a><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p><img src="https://i.loli.net/2018/12/06/5c08d11e024ef.png" alt="top.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;使用Arthas定位CPU占用率过高的问题，&lt;/p&gt;
&lt;p&gt;挖坑待填…&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>线上服务CPU负载高问题排查（二）</title>
    <link href="http://yoursite.com/2018/12/06/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1CPU%E8%B4%9F%E8%BD%BD%E9%AB%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/12/06/线上服务CPU负载高问题排查（二）/</id>
    <published>2018-12-06T05:49:15.410Z</published>
    <updated>2019-03-25T08:29:53.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在进行接口服务优化，前面对处理大量数据的线程进行了优化，具体见：<a href="https://f8f-1bearcat.github.io/2018/12/06/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1CPU%E8%B4%9F%E8%BD%BD%E9%AB%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">线上服务CPU负载高问题排查（一）</a> 。当优化后的版本部署到灰度服务器上时，原以为CPU占用率会明显地降低，然而事实却狠狠地打了脸，非但该服务的CPU占用及负载没有降低，反而远远差于上次优化之前版本及线上的服务。是优化方向错了，还是引入了新的问题？<br><a id="more"></a></p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>通过运维中心<code>zabbix</code>面板查看该机房上所有的报价服务负载情况，新部署接口服务的负载情况如下图红线所示：<br><img src="https://i.loli.net/2018/12/06/5c08d1299cb5d.png" alt="load_before.png"><br>可以发现在上午11:00~14:00时间段内，该接口服务的负载明显高于其他几台服务。CPU利用率的情况与负载类似。</p><h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><h3 id="一、比较用户数量"><a href="#一、比较用户数量" class="headerlink" title="一、比较用户数量"></a>一、比较用户数量</h3><p>5个服务都部署在SZVPC机房，并且可以确定服务运行环境是相同的，那么首先需要确认是否是该服务用户量过大导致的。</p><p>登录CRT，通过<code>netstat -antp|grep &#39;port&#39;|wc -l</code>命令查看服务器上的实时用户连接数。对比该机房的5个报价服务发现，所有服务的实时用户连接数大体相等，不存在优化版本服务用户连接远大于其他几台服务的情况。到这里可以得出结论是新部署的服务本身有问题。</p><h3 id="二、定位高CPU占用线程"><a href="#二、定位高CPU占用线程" class="headerlink" title="二、定位高CPU占用线程"></a>二、定位高CPU占用线程</h3><p>1、在上一篇的CPU高负载排查过程中，我们定位到是组合和账户的数据处理线程CPU占用率高。那首先，可以确定下上次优化有没有解决这两个线程的CPU占用问题。</p><p>通过Arthas进入到当前服务进程，执行<code>thread -n 5 -i 1000</code>命令来查看当前CPU占用最高的几个线程。分析堆栈信息，可以看到改完之后的服务组合账户线程的CPU占用率已经降低了，至少前5个线程里面不见他们的踪影。</p><p><img src="https://i.loli.net/2018/12/13/5c11f7ed83ec2.png" alt="thread5.png"></p><p>2、排除了组合账户线程的影响，下一步就要定位到底是什么线程占用CPU最高。通过<code>$ top</code>命令，查看CPU实时使用情况（注：图为后面补加的，数据可能有出入）：<br><img src="https://i.loli.net/2018/12/07/5c09d1aa96940.png" alt="top_load.png"><br>可以看出pid为26810的进程CPU占用率竟然达到了1000%，而这个进程就是接口服务的进程。</p><p>3、经典的命令行工具，如<em>ps</em>或<em>top</em>，都可以用来显示线程级别的信息，下面列举了这两种方法的使用。</p><p>方法一：通过<code>$ ps -mp &lt;pid&gt; -o tid,THREAD,time</code>命令，查看线程列表。到这里确认tid为8592…的这三个线程CPU占用率最高，且占用CPU的时间也很长。</p><p><img src="https://i.loli.net/2018/12/07/5c09de2a7f8c5.png" alt="thread.png"></p><p>方法二：通过<code>$ top -H -p &lt;pid&gt;</code>命令，查看线程列表，得出的结论与方法一一致。</p><p>​            <img src="https://i.loli.net/2018/12/07/5c09de2511265.png" alt="top_thread.png"></p><p>4、定位到线程tid之后，就可以用<code>jstack</code>命令查看线程具体的堆栈信息了，不过<code>jstack</code>命令中线程id使用16进制，因而首先需要通过 <code>$ echo &quot;obase=16;&lt;tid&gt;&quot;|bc</code>或 <code>$ printf &quot;%x\n&quot; &lt;tid&gt;</code>命令将tid转为16进制。</p><p><img src="https://i.loli.net/2018/12/07/5c09de1cb3c4b.png" alt="16.png"></p><p>以tid8592为例，转为16进制后为2190，再通过<code>$ jstack &lt;pid&gt; |grep &lt;tid&gt; -C 20</code>命令查看该线程的堆栈信息。</p><p><img src="https://i.loli.net/2018/12/07/5c09de3041b0a.png" alt="thread_stack.png"></p><h3 id="三、分析"><a href="#三、分析" class="headerlink" title="三、分析"></a>三、分析</h3><p>Gang worker是JVM 用于做新生代垃圾回收（monir gc）的一个线程，#号后面是线程编号。从线程的堆栈信息可以看出是JVM的GC线程一直在占用大量CPU.定位到垃圾收集器的问题，可以通过<code>jstat -gcutil &lt;pid&gt; 1000 100</code>命令统计GC回收的情况（没发现有什么异常）。</p><p><img src="https://i.loli.net/2018/12/13/5c11f7d2e9c4d.png" alt="gcutil.png"></p><p>对应的参数如下：</p><ul><li><strong>S0：</strong>幸存1区当前使用比例</li><li><strong>S1：</strong>幸存2区当前使用比例</li><li><strong>E：</strong>伊甸园区使用比例</li><li><strong>O：</strong>老年代使用比例</li><li><strong>M：</strong>元数据区使用比例</li><li><strong>CCS：</strong>压缩使用比例</li><li><strong>YGC：</strong>年轻代垃圾回收次数</li><li><strong>FGC：</strong>老年代垃圾回收次数</li><li><strong>FGCT：</strong>老年代垃圾回收消耗时间</li><li><strong>GCT：</strong>垃圾回收消耗总时间</li></ul><p>通过<code>jinfo -flags &lt;pid&gt;</code>命令，查看该服务器上的JVM内存参数设置，看到了这一条配置：<code>-Xmx12g -XX:MaxDirectMemorySize=18g</code>，原来之前的服务版本中已经不使用直接内存，而是全都使用堆内存，而这里JVM配置却没有改过来，由此推测是服务的内存分配不够用导致频繁GC，进而引起CPU负载过高。</p><p><img src="https://i.loli.net/2018/12/13/5c11f7f40440c.png" alt="jinfo.png"></p><h3 id="四、后续"><a href="#四、后续" class="headerlink" title="四、后续"></a>四、后续</h3><p>修改JVM的配置，将最大堆内存设置为<code>-Xmx=24g</code>，重启服务运行一段时候后发现CPU负载迅速降了下来，并一直低于线上服务的负载。</p><p><img src="https://i.loli.net/2018/12/06/5c08d1312b7aa.png" alt="load_after.png"></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>1 有关JVM调优相关的可以参考这一系列博客，写的很详尽：<a href="https://www.cnblogs.com/wyb628/p/8566337.html" target="_blank" rel="noopener">Java内存泄露分析系列</a>。</p><p>2 这次问题解决也是凑巧去看了一眼JVM参数，本身GC回收具体什么地方占用了CPU，迫于时间关系实际上没有准确定位到，后面再研究吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在进行接口服务优化，前面对处理大量数据的线程进行了优化，具体见：&lt;a href=&quot;https://f8f-1bearcat.github.io/2018/12/06/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1CPU%E8%B4%9F%E8%BD%BD%E9%AB%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%EF%BC%88%E4%B8%80%EF%BC%89/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;线上服务CPU负载高问题排查（一）&lt;/a&gt; 。当优化后的版本部署到灰度服务器上时，原以为CPU占用率会明显地降低，然而事实却狠狠地打了脸，非但该服务的CPU占用及负载没有降低，反而远远差于上次优化之前版本及线上的服务。是优化方向错了，还是引入了新的问题？&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Netty源码之writeAndFlush()流程与异步</title>
    <link href="http://yoursite.com/2018/12/06/Netty%E6%BA%90%E7%A0%81%E4%B9%8BwriteAndFlush()%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%BC%82%E6%AD%A5/"/>
    <id>http://yoursite.com/2018/12/06/Netty源码之writeAndFlush()流程与异步/</id>
    <published>2018-12-06T01:14:11.376Z</published>
    <updated>2019-03-25T06:36:30.985Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf21c6726a92.png" alt="netty.png"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>挖坑待填…</p><p>本文旨在对Netty中writeAndFlush()方法的线程安全及并发问题简单谈下自己的理解，同时对channel.writeAndFlush()和ctx.writeAndFlush()两个方法通过阅读源码进行比较。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf21c6726a92.png&quot; alt=&quot;netty.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;挖坑待填…&lt;/p&gt;
&lt;p&gt;本文旨在对Netty中writeAndFlush()方法的线程安全及并发问题简单谈下自己的理解，同时对channel.writeAndFlush()和ctx.writeAndFlush()两个方法通过阅读源码进行比较。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Linux之sed用法</title>
    <link href="http://yoursite.com/2018/12/05/Linux%E4%B9%8Bsed%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2018/12/05/Linux之sed用法/</id>
    <published>2018-12-05T01:33:22.380Z</published>
    <updated>2019-02-01T06:16:32.856Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/02/01/5c53e438b7367.png" alt="Linux.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Linux sed命令是利用script来处理、编辑文本文件。</p><a id="more"></a><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>sed [OPTION]... {script-only-if-no-other-script} [input-file]...</code></p><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li>-n, –quiet, –silent<br>​                 suppress automatic printing of pattern space</li><li>-e script, –expression=script<br> ​                 add the script to the commands to be executed</li><li><p>-f script-file, –file=script-file<br> ​                 add the contents of script-file to the commands to be executed</p><p> –follow-symlinks<br>​                 follow symlinks when processing in place; hard links<br>​                 will still be broken.</p></li><li>-i[SUFFIX], –in-place[=SUFFIX]<br> ​                 edit files in place (makes backup if extension supplied).<br> ​                 The default operation mode is to break symbolic and hard links.<br> ​                 This can be changed with –follow-symlinks and –copy.</li><li>-c, –copy<br>​                 use copy instead of rename when shuffling files in -i mode.<br>​                 While this will avoid breaking links (symbolic or hard), the<br>​                 resulting editing operation is not atomic.  This is rarely<br>​                 the desired mode; –follow-symlinks is usually enough, and<br>​                 it is both faster and more secure.</li><li>-l N, –line-length=N<br>​                 specify the desired line-wrap length for the `l’ command<br>  –posix<br>​                 disable all GNU extensions.</li><li>-r, –regexp-extended<br>​                 use extended regular expressions in the script.</li><li>-s, –separate<br>​                 consider files as separate rather than as a single continuous<br>​                 long stream.</li><li>-u, –unbuffered<br>​                 load minimal amounts of data from the input files and flush<br>​                 the output buffers more often</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>查看某段时间的服务日志：<code>sed -n &#39;/1970-01-01 01:01/,$p&#39; 1.log |more</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/02/01/5c53e438b7367.png&quot; alt=&quot;Linux.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Linux sed命令是利用script来处理、编辑文本文件。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>浅谈OGNL表达式</title>
    <link href="http://yoursite.com/2018/11/30/%E6%B5%85%E8%B0%88OGNL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/11/30/浅谈OGNL表达式/</id>
    <published>2018-11-30T02:29:36.063Z</published>
    <updated>2018-11-30T02:33:36.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>挖坑…</p><p>OGNL特殊用法请参考：<a href="https://github.com/alibaba/arthas/issues/71" target="_blank" rel="noopener">https://github.com/alibaba/arthas/issues/71</a><br>OGNL表达式官方指南：<a href="https://commons.apache.org/proper/commons-ognl/language-guide.html" target="_blank" rel="noopener">https://commons.apache.org/proper/commons-ognl/language-guide.html</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;挖坑…&lt;/p&gt;
&lt;p&gt;OGNL特殊用法请参考：&lt;a href=&quot;https://github.com/alibaba/arthas/issues/71&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/alibaba/arthas/issues/71&lt;/a&gt;&lt;br&gt;OGNL表达式官方指南：&lt;a href=&quot;https://commons.apache.org/proper/commons-ognl/language-guide.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://commons.apache.org/proper/commons-ognl/language-guide.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="OGNL" scheme="http://yoursite.com/tags/OGNL/"/>
    
  </entry>
  
  <entry>
    <title>Logback以及Log4j2性能测试对比</title>
    <link href="http://yoursite.com/2018/11/28/Logback%E4%BB%A5%E5%8F%8ALog4j2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2018/11/28/Logback以及Log4j2性能测试对比/</id>
    <published>2018-11-28T01:06:32.907Z</published>
    <updated>2019-03-25T08:24:06.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>挖坑待填…</p><p>在进行RPC服务调优时，我们往往下意识地会从框架、JVM、业务代码等方向思考，但却往往会忽略线上服务日志打印对服务性能的影响。实际上，在某些情况下，选取合适的日志框架、有效的日志打印策略，将会给服务带来很大的性能提升。本文将尝试对常用的日志框架进行对比分析，从而服务于我们的服务性能调优工作。</p><a id="more"></a><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;挖坑待填…&lt;/p&gt;
&lt;p&gt;在进行RPC服务调优时，我们往往下意识地会从框架、JVM、业务代码等方向思考，但却往往会忽略线上服务日志打印对服务性能的影响。实际上，在某些情况下，选取合适的日志框架、有效的日志打印策略，将会给服务带来很大的性能提升。本文将尝试对常用的日志框架进行对比分析，从而服务于我们的服务性能调优工作。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Logback" scheme="http://yoursite.com/tags/Logback/"/>
    
      <category term="Log4j2" scheme="http://yoursite.com/tags/Log4j2/"/>
    
  </entry>
  
  <entry>
    <title>quartz定时任务时间设置</title>
    <link href="http://yoursite.com/2018/11/28/quartz%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/11/28/quartz定时任务时间设置/</id>
    <published>2018-11-28T01:03:26.828Z</published>
    <updated>2019-02-01T06:06:56.366Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/02/01/5c53b7b438ba0.png" alt="quartz.png"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>Quartz 是一个完全由 Java 编写的开源作业调度框架，为在 Java 应用程序中进行作业调度提供了简单却强大的机制。项目中的定时任务有使用到Quartz，这里就简单记录下其有关概念以及时间设置，方便记忆及以后查看。</p><a id="more"></a><h2 id="Quartz-的核心概念"><a href="#Quartz-的核心概念" class="headerlink" title="Quartz 的核心概念"></a>Quartz 的核心概念</h2><p><strong>Job</strong> 表示一个工作，要执行的具体内容。此接口中只有一个方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span></span></span><br></pre></td></tr></table></figure><p><strong>JobDetail</strong> 表示一个具体的可执行的调度程序，Job 是这个可执行程调度程序所要执行的内容，另外 JobDetail 还包含了这个任务调度的方案和策略。 </p><p><strong>Trigger</strong> 代表一个调度参数的配置，什么时候去调。</p><p><strong>Scheduler</strong> 代表一个调度容器，一个调度容器中可以注册多个 JobDetail 和 Trigger。当 Trigger 与 JobDetail 组合，就可以被 Scheduler 容器调度了。</p><h2 id="定时任务时间设置"><a href="#定时任务时间设置" class="headerlink" title="定时任务时间设置"></a>定时任务时间设置</h2><p><strong>时间格式:</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">星号： * * * * * * * </span><br><span class="line">格式： 秒 分 时 日 月 周 年</span><br></pre></td></tr></table></figure><table><thead><tr><th>时间域名</th><th style="text-align:center">允许填写的值</th><th style="text-align:center">允许的通配符</th><th>是否必填</th></tr></thead><tbody><tr><td>秒</td><td style="text-align:center">0-59</td><td style="text-align:center">, - * /</td><td>是</td></tr><tr><td>分</td><td style="text-align:center">0-59</td><td style="text-align:center">, - * /</td><td>是</td></tr><tr><td>时</td><td style="text-align:center">0-23</td><td style="text-align:center">, - * /</td><td>是</td></tr><tr><td>周</td><td style="text-align:center">1-31</td><td style="text-align:center">, - * ? / L W</td><td>是</td></tr><tr><td>月</td><td style="text-align:center">1-12 or JAN-DEC</td><td style="text-align:center">, - * /</td><td></td></tr><tr><td>周</td><td style="text-align:center">1-7 or SUN-SAT</td><td style="text-align:center">, - * ? / L  #</td><td>是</td></tr><tr><td>年</td><td style="text-align:center">1970-2099</td><td style="text-align:center">, - * /</td><td>否</td></tr></tbody></table><p><strong>通配符说明</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'*'</span> 表示所有值。例如:在分的字段上设置<span class="string">'*'</span>,表示每一分钟都会触发。</span><br><span class="line"></span><br><span class="line"><span class="string">'?'</span> 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的<span class="number">10</span>号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为<span class="string">'?'</span>具体设置为<span class="string">'00010*?'</span>。</span><br><span class="line"></span><br><span class="line"><span class="string">'-'</span> 表示区间。例如 在小时上设置<span class="string">'10-12'</span>,表示<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>点都会触发。<span class="string">','</span>表示指定多个值，例如在周字段上设置<span class="string">'MON,WED,FRI'</span>表示周一，周三和周五触发。</span><br><span class="line"></span><br><span class="line"><span class="string">'/'</span> 用于递增触发。如在秒上面设置<span class="string">'5/15'</span>表示从<span class="number">5</span>秒开始，每增<span class="number">15</span>秒触发(<span class="number">5</span>,<span class="number">20</span>,<span class="number">35</span>,<span class="number">50</span>)。在月字段上设置<span class="string">'1/3'</span>所示每月<span class="number">1</span>号开始，每隔三天触发一次。</span><br><span class="line"></span><br><span class="line"><span class="string">'L'</span> 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于<span class="string">'7'</span>或<span class="string">'SAT'</span>。如果在<span class="string">'L'</span>前加上数字，则表示该数据的最后一个。例如在周字段上设置<span class="string">'6L'</span>这样的格式,则表示<span class="string">"本月最后一个星期五"</span>。</span><br><span class="line"></span><br><span class="line"><span class="string">'W'</span> 表示离指定日期的最近那个工作日(周一至周五)。例如在日字段上设置<span class="string">'15W'</span>，表示离每月<span class="number">15</span>号最近的那个工作日触发。如果<span class="number">15</span>号正好是周六，则找最近的周五(<span class="number">14</span>号)触发, 如果<span class="number">15</span>号是周未，则找最近的下周一(<span class="number">16</span>号)触发.如果<span class="number">15</span>号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 <span class="string">'1W'</span>,它则表示每月<span class="number">1</span>号往后最近的工作日触发。如果<span class="number">1</span>号正是周六，则将在<span class="number">3</span>号下周一触发。(注，<span class="string">'W'</span>前只能设置具体的数字,不允许区间<span class="string">"-"</span>)。</span><br><span class="line"></span><br><span class="line"><span class="string">'L'</span>和<span class="string">'W'</span>可以一组合使用。如果在日字段上设置<span class="string">'LW'</span>,则表示在本月的最后一个工作日触发(一般指发工资 )序号(表示每月的第几个周几)，例如在周字段上设置<span class="string">'6#3'</span>表示在每月的第三个周六.注意如果指定<span class="string">'#5'</span>,正好第五周没有周六，则不会触发该配置(用在母亲节和父亲节再合适不过了)。</span><br><span class="line"></span><br><span class="line">周字段的设置，若使用英文字母是不区分大小写的，<span class="string">'MON'</span>与<span class="string">'mon'</span>相同。</span><br></pre></td></tr></table></figure><p><strong>常用示例</strong>：</p><p><code>0 0 12 * * ?</code> 每天12点触发<br><code>0 15 10 ? * *</code> 每天10点15分触发<br><code>0 15 10 * * ?</code> 每天10点15分触发<br><code>0 15 10 * * ? *</code> 每天10点15分触发<br><code>0 15 10 * * ? 2005</code> 2005年每天10点15分触发<br><code>0 * 14 * * ?</code> 每天下午的 2点到2点59分每分触发<br><code>0 0/5 14 * * ?</code> 每天下午的 2点到2点59分(整点开始，每隔5分触发)<br><code>0 0/5 14,18 * * ?</code> 每天下午的 18点到18点59分(整点开始，每隔5分触发)<br><code>0 0-5 14 * * ?</code> 每天下午的 2点到2点05分每分触发<br><code>0 10,44 14 ? 3 WED</code>     3月分每周三下午的 2点10分和2点44分触发 （特殊情况，在一个时间设置里，执行两次或两次以上的情况）<br><code>0 59 2 ? * FRI</code>    每周5凌晨2点59分触发；<br><code>0 15 10 ? * MON-FRI</code> 从周一到周五每天上午的10点15分触发<br><code>0 15 10 15 * ?</code> 每月15号上午10点15分触发<br><code>0 15 10 L * ?</code> 每月最后一天的10点15分触发<br><code>0 15 10 ? * 6L</code> 每月最后一周的星期五的10点15分触发<br><code>0 15 10 ? * 6L 2002-2005</code> 从2002年到2005年每月最后一周的星期五的10点15分触发<br><code>0 15 10 ? * 6#3</code> 每月的第三周的星期五开始触发<br><code>0 0 12 1/5 * ?</code> 每月的第一个中午开始每隔5天触发一次<br><code>0 11 11 11 11 ?</code> 每年的11月11号 11点11分触发(光棍节)</p><p>官方文档：<a href="http://www.quartz-scheduler.org/documentation/quartz-2.2.x/quick-start.html" target="_blank" rel="noopener">http://www.quartz-scheduler.org/documentation/quartz-2.2.x/quick-start.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/02/01/5c53b7b438ba0.png&quot; alt=&quot;quartz.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;Quartz 是一个完全由 Java 编写的开源作业调度框架，为在 Java 应用程序中进行作业调度提供了简单却强大的机制。项目中的定时任务有使用到Quartz，这里就简单记录下其有关概念以及时间设置，方便记忆及以后查看。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Quartz任务调度" scheme="http://yoursite.com/tags/Quartz%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>介绍一款开源Java诊断工具—Arthas</title>
    <link href="http://yoursite.com/2018/11/19/Arthas%E2%80%94%E5%BC%80%E6%BA%90Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/11/19/Arthas—开源Java诊断工具/</id>
    <published>2018-11-19T06:48:50.651Z</published>
    <updated>2019-01-28T08:43:18.477Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf2661ea96ae.png" alt="arthas.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Arthas（阿尔萨斯）是阿里巴巴开源的 Java 诊断工具，深受开发者喜爱。</p><p>当你遇到以下类似问题而束手无策时，Arthas 可以帮助你解决：</p><pre><code>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！是否有一个全局视角来查看系统的运行状况？有什么办法可以监控到JVM的实时运行状态？</code></pre><p>Arthas 采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。</p><a id="more"></a><h2 id="常用命令示例"><a href="#常用命令示例" class="headerlink" title="常用命令示例"></a>常用命令示例</h2><ul><li>实时显示当前服务的线程、JVM等信息：</li></ul><p><code>dashboard</code></p><ul><li>在指定采样时间间隔<code>i</code>内展示当前最忙的前<code>n</code>个线程并打印堆栈：</li></ul><p><code>thread -n 10 -i 1000</code></p><ul><li>展示方法内部调用路径，并输出方法路径上的每个节点上耗时，跟据调用耗时过滤：</li></ul><p><code>trace [class-pattern] [method-pattern] #cost&gt;100</code></p><ul><li>方法执行数据观测：</li></ul><p><code>watch [class-pattern] [method-pattern] returnObj</code><br><code>watch [class-pattern] getInstance &quot;returnObj.getReqList().size()&quot;</code></p><ul><li>反编译指定已加载类的源码：</li></ul><p><code>jad [class-pattern]</code></p><ul><li>打印出类的Field信息：</li></ul><p><code>sc -df io.netty.util.internal.PlatformDependent</code></p><p>安装和更多命令列表参见官方文档：<a href="https://alibaba.github.io/arthas/index.html" target="_blank" rel="noopener">Arthas 用户文档 — Arthas 3.0.5-SNAPSHOT 文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf2661ea96ae.png&quot; alt=&quot;arthas.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Arthas（阿尔萨斯）是阿里巴巴开源的 Java 诊断工具，深受开发者喜爱。&lt;/p&gt;
&lt;p&gt;当你遇到以下类似问题而束手无策时，Arthas 可以帮助你解决：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？

我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？

遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？

线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！

是否有一个全局视角来查看系统的运行状况？

有什么办法可以监控到JVM的实时运行状态？
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Arthas 采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="开发工具" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
      <category term="alibaba" scheme="http://yoursite.com/tags/alibaba/"/>
    
  </entry>
  
  <entry>
    <title>Netty引用计数对象</title>
    <link href="http://yoursite.com/2018/11/19/Netty%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/11/19/Netty引用计数对象/</id>
    <published>2018-11-19T05:42:35.208Z</published>
    <updated>2019-03-25T06:42:42.747Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf21c6726a92.png" alt="netty.png"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>挖坑待填…</p><p>之前项目中怼Netty的高性能编程进行了实践，其中Netty 的接收和发送 ByteBuffer有用到堆外内存 DIRECT BUFFERS。使用堆外直接内存进行 Socket 读写，好处是不需要进行字节缓冲区的二次拷贝，实现了Netty的零拷贝。但是堆外内存不能被GC回收，必须遵循“谁分配，谁释放”的原则，在使用堆外内存后如果没有及时的释放，则很有可能导致OOM问题，具体可以参考这篇文章：<a href="https://f8f-1bearcat.github.io/2018/11/16/Netty%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/#more" target="_blank" rel="noopener">Netty直接内存泄露</a>；而如果对堆外内存进行了重复释放，服务则会抛出Netty引用计数异常问题。</p><p>本文旨在结合源码，对Netty的引用计数对象进行简析。</p><a id="more"></a><p>官方文档：<a href="https://netty.io/wiki/reference-counted-objects.html" target="_blank" rel="noopener">https://netty.io/wiki/reference-counted-objects.html</a></p><p>文档翻译：<a href="https://damacheng009.iteye.com/blog/2013657" target="_blank" rel="noopener">https://damacheng009.iteye.com/blog/2013657</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf21c6726a92.png&quot; alt=&quot;netty.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;挖坑待填…&lt;/p&gt;
&lt;p&gt;之前项目中怼Netty的高性能编程进行了实践，其中Netty 的接收和发送 ByteBuffer有用到堆外内存 DIRECT BUFFERS。使用堆外直接内存进行 Socket 读写，好处是不需要进行字节缓冲区的二次拷贝，实现了Netty的零拷贝。但是堆外内存不能被GC回收，必须遵循“谁分配，谁释放”的原则，在使用堆外内存后如果没有及时的释放，则很有可能导致OOM问题，具体可以参考这篇文章：&lt;a href=&quot;https://f8f-1bearcat.github.io/2018/11/16/Netty%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/#more&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Netty直接内存泄露&lt;/a&gt;；而如果对堆外内存进行了重复释放，服务则会抛出Netty引用计数异常问题。&lt;/p&gt;
&lt;p&gt;本文旨在结合源码，对Netty的引用计数对象进行简析。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>线上服务性能调优：RPC可靠性设计</title>
    <link href="http://yoursite.com/2018/11/16/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%EF%BC%9ARPC%E5%8F%AF%E9%9D%A0%E6%80%A7%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2018/11/16/线上服务性能调优：RPC可靠性设计/</id>
    <published>2018-11-16T09:04:30.994Z</published>
    <updated>2019-03-26T07:53:18.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>本文以《Netty权威指南（第二版）》第23章<strong>可靠性</strong>为基础，结合实际项目中的应用，实现RPC框架的可靠性设计。当前权作为自己的学习笔记，后续慢慢填充自己在项目中的实践（如果懒癌没犯的话）。</p><a id="more"></a><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="RPC-框架的可靠性设计"><a href="#RPC-框架的可靠性设计" class="headerlink" title="RPC 框架的可靠性设计"></a>RPC 框架的可靠性设计</h3><h4 id="1-故障"><a href="#1-故障" class="headerlink" title="1. 故障"></a>1. 故障</h4><p>1.1 分布式调用引入的故障<br>​    1．消息的序列化和反序列化故障，例如，不支持的数据类型。<br>​    2．路由故障：包括服务的订阅、发布故障，服务实例故障之后没有及时刷新路由表，导致 RPC 调用仍然路由到故障节点。<br>​    3．网络通信故障，包括网络闪断、网络单通、丢包、客户端浪涌接入等。<br>1.2 第三方服务依赖<br>数据库服务、文件存储服务、缓存服务、消息队列服务<br>​    1．网络通信类故障, 如果采用 BIO 调用第三方服务，很有可能被阻塞。<br>​    2．“雪崩效用”导致的级联故障，例如服务端处理慢导致客户端线程被阻塞。<br>​    3．第三方不可用导致 RPC 调用失败。</p><h4 id="2-通信层的可靠性设计"><a href="#2-通信层的可靠性设计" class="headerlink" title="2. 通信层的可靠性设计"></a>2. 通信层的可靠性设计</h4><p>2.1 链路有效性检测<br>​    心跳检测机制分为三个层面：<br>​        1.TCP 层面的心跳检测，即 TCP 的 Keep-Alive 机制，它的作用域是整个 TCP 协议栈。<br>​        2. 协议层的心跳检测，主要存在于长连接协议中。例如 MQTT 协议。<br>​        3. 应用层的心跳检测，它主要由各业务产品通过约定方式定时给对方发送心跳消息实现。<br>​    心跳检测策略如下：<br>​        1．连续 N 次心跳检测都没有收到对方的 Pong 应答消息或者 Ping 请求消息，则认为链路已经发生逻辑失效，这被称作心跳超时。<br>​        2．读取和发送心跳消息的时候如何直接发生了 IO 异常，说明链路已经失效，这被称为心跳失败。​<br>  2.2 客户端断连重连<br>  ​    1．服务端因为某种原因，主动关闭连接，客户端检测到链路被正常关闭。<br>  ​    2．服务端因为宕机等故障，强制关闭连接，客户端检测到链路被 Rest 掉。<br>  ​    3．心跳检测超时，客户端主动关闭连接。<br>  ​    4．客户端因为其它原因（例如解码失败），强制关闭连接。<br>  ​    5．网络类故障，例如网络丢包、超时、单通等，导致链路中断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public int checkHealth() &#123;&#125;</span><br></pre></td></tr></table></figure><p>  2.3 缓存重发<br>  ​    消息队列中积压了部分消息，此时链路中断，这会导致部分消息并没有真正发送给通信对端<br>  ​        1．调用 Netty ChannelHandlerContext 的 write 方法时，返回 ChannelFuture 对象，我们在 ChannelFuture 中注册发送结果监听 Listener。<br>  ​        2．在 Listener 的 operationComplete 方法中判断操作结果，如果操作不成功，将之前发送的消息对象添加到重发队列中。<br>  ​        3．链路重连成功之后，根据策略，将缓存队列中的消息重新发送给通信对端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最终写入数据</span></span><br><span class="line">channel.writeAndFlush(byteBuf).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">         <span class="keyword">if</span> ((!dataQueue.isEmpty()) &amp;&amp; channel.isWritable() &amp;&amp; (!isWriting())) &#123;</span><br><span class="line">              dataProcessor();</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">               <span class="comment">//缓存重发</span></span><br><span class="line">  &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>  2.4 客户端超时保护</p><p>​    1. 在同步阻塞 I/O 模型中，连接操作是同步阻塞的，如果不设置超时时间，客户端 I/O 线程可能会被长时间阻塞，这会导致系统可用 I/O 线程数的减少。</p><p>​    2. 业务层需要：大多数系统都会对业务流程执行时间有限制，例如 WEB 交互类的响应时间要小于 3S。客户端设置连接超时时间是为了实现业务层的超时。</p><p>2.5 针对客户端的并发连接数流控<br>​    检查登录次数<br>​    目前简单判断一段时间内不允许再登录<br>2.6 内存保护<br>​    1. 链路总数的控制：每条链路都包含接收和发送缓冲区，链路个数太多容易导致内存溢出。<br>​    2. 单个缓冲区的上限控制：防止非法长度或者消息过大导致内存溢出。<br>​        缓冲区的创建方式通常有两种：<br>​            1. 容量预分配，在实际读写过程中如果不够再扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf byteBuf = com.eastmoney.quote.service.core.common.BufAllocator.newBuffer(resMinData.getByteData().length + <span class="number">28</span>);</span><br></pre></td></tr></table></figure><p>​            2. 根据协议消息长度创建缓冲区。    </p><p>​    3. 缓冲区内存释放：防止因为缓冲区使用不当导致的内存泄露。</p><p>​    4. NIO 消息发送队列的长度上限控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (buf.readableBytes() &gt;= ServerInfo.getInstance().getChunkSize()) &#123;</span><br><span class="line">    writeBuf(buf);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (batchBuf == <span class="keyword">null</span>) &#123;</span><br><span class="line">        batchBuf = BufAllocator.newBuffer();</span><br><span class="line">    &#125;</span><br><span class="line">    batchBuf.writeBytes(buf);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       buf.release();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       LOG.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-RPC-调用层的可靠性设计"><a href="#3-RPC-调用层的可靠性设计" class="headerlink" title="3. RPC 调用层的可靠性设计"></a>3. RPC 调用层的可靠性设计</h4><p>3.1 RPC 调用异常场景<br>​    3.1.1 服务路由失败<br>​    3.1.2 服务端超时<br>​    3.1.3 服务端调用失败<br>3.2 RPC 调用可靠性方案<br>​    3.2.1 注册中心与链路检测双保险机制<br>​    3.2.2 集群容错策略</p><h4 id="4-第三方服务依赖故障隔离"><a href="#4-第三方服务依赖故障隔离" class="headerlink" title="4. 第三方服务依赖故障隔离"></a>4. 第三方服务依赖故障隔离</h4><p>4.1 总体策略<br>4.2 异步化<br>4.3. 基于 Hystrix 的第三方依赖故障隔离</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;本文以《Netty权威指南（第二版）》第23章&lt;strong&gt;可靠性&lt;/strong&gt;为基础，结合实际项目中的应用，实现RPC框架的可靠性设计。当前权作为自己的学习笔记，后续慢慢填充自己在项目中的实践（如果懒癌没犯的话）。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
      <category term="RPC" scheme="http://yoursite.com/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>线上服务性能调优：Netty高性能编程</title>
    <link href="http://yoursite.com/2018/11/16/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%EF%BC%9ANetty%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/11/16/线上服务性能调优：Netty高性能编程/</id>
    <published>2018-11-16T03:28:20.479Z</published>
    <updated>2019-03-25T08:32:03.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>我的Netty通信框架学习是从李林峰老师的《Netty权威指南（第二版）》开始的，书中从原始的I/O模型到Netty的高性能、可靠性等高级特性进行了由浅入深的讲解。偶然的机会，发现了李林峰老师在InfoQ上的专栏：<a href="https://www.infoq.cn/profile/1278176" target="_blank" rel="noopener">InfoQ_李林峰</a>，当前还保持着不错的更新频率，大家感兴趣的可以关注一下。学习本身就是一个不断获取知识然后投入实践的过程，本文将简单记录下在我自己的项目中是如何实践Netty高性能编程的。</p><a id="more"></a><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>声明：本文将以《Netty权威指南（第二版）》第22章<strong>高性能之道</strong>为基础，对项目中的实际应用进行梳理，可以看做是自己的一份学习笔记，方便记忆及以后查看，不做其他用途。</p><h3 id="传统-RPC-调用性能差的三宗罪"><a href="#传统-RPC-调用性能差的三宗罪" class="headerlink" title="传统 RPC 调用性能差的三宗罪"></a>传统 RPC 调用性能差的三宗罪</h3><ul><li><p>网络传输方式问题：</p><p>传统的 RPC 框架或者基于 RMI 等方式的远程服务（过程）调用采用了同步阻塞 IO，当客户端的并发压力或者网络时延增大之后，同步阻塞 IO 会由于频繁的 wait 导致 IO 线程经常性的阻塞，由于线程无法高效的工作，IO 处理能力自然下降。</p></li><li><p>序列化方式问题：<br>Java 序列化存在如下几个典型问题：</p><ul><li>无法跨语言使用；</li><li>序列化后的码流太大，网络传输还是持久化到磁盘，都会导致额外的资源占用；</li><li>序列化性能差（CPU 资源占用高）；</li></ul></li><li><p>线程模型问题：<br>由于采用同步阻塞 IO，这会导致每个 TCP 连接都占用 1 个线程，当 IO 读写阻塞导致线程无法及时释放时，会导致系统性能急剧下降；</p></li></ul><h3 id="高性能的三个主题"><a href="#高性能的三个主题" class="headerlink" title="高性能的三个主题"></a>高性能的三个主题</h3><p>​    1) 传输：用什么样的通道将数据发送给对方，BIO、NIO 或者 AIO，IO 模型在很大程度上决定了框架的性能。<br>​    2) 协议：采用什么样的通信协议，HTTP 或者内部私有协议。协议的选择不同，性能模型也不同。相比于公有协议，内部私有协议的性能通常可以被设计的更优。<br>​    3) 线程：数据报如何读取？读取之后的编解码在哪个线程进行，编解码后的消息如何派发，Reactor 线程模型的不同，对性能的影响也非常大。</p><h3 id="Netty-高性能编程实践"><a href="#Netty-高性能编程实践" class="headerlink" title="Netty 高性能编程实践"></a>Netty 高性能编程实践</h3><h4 id="1-异步非阻塞通信"><a href="#1-异步非阻塞通信" class="headerlink" title="1. 异步非阻塞通信"></a>1. 异步非阻塞通信</h4><p>与 Socket 类和 ServerSocket 类相对应，NIO 也提供了 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">"Epoll"</span>.equals(ServerInfo.getInstance().getEventLoopGroup())) &#123;</span><br><span class="line">    bossGroup = <span class="keyword">new</span> EpollEventLoopGroup();</span><br><span class="line">    workerGroup = <span class="keyword">new</span> EpollEventLoopGroup();</span><br><span class="line">    serverBootstrap = serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">            .channel(EpollServerSocketChannel.class);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    serverBootstrap = serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">            .channel(NioServerSocketChannel.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-零拷贝"><a href="#2-零拷贝" class="headerlink" title="2. 零拷贝"></a>2. 零拷贝</h4><p>​    1) Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title">newBufferType</span><span class="params">(<span class="keyword">byte</span> type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (type == BYTEBUF_TYPE_POOLED_DIRECT) &#123;</span><br><span class="line"><span class="keyword">return</span> PooledByteBufAllocator.DEFAULT.directBuffer().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == BYTEBUF_TYPE_UNPOOLED_DIRECT) &#123;</span><br><span class="line"><span class="keyword">return</span> UnpooledByteBufAllocator.DEFAULT.directBuffer().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == BYTEBUF_TYPE_POOLED_HEAP) &#123;</span><br><span class="line"><span class="keyword">return</span> PooledByteBufAllocator.DEFAULT.buffer().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == BYTEBUF_TYPE_UNPOOLED_HEAP) &#123;</span><br><span class="line"><span class="keyword">return</span> UnpooledByteBufAllocator.DEFAULT.buffer().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> UnpooledByteBufAllocator.DEFAULT.buffer().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    2) Netty 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompositeByteBuf <span class="title">compositeBuffer</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ServerInfo.getInstance().getByteBufType() == BYTEBUF_TYPE_POOLED_DIRECT) &#123;</span><br><span class="line"><span class="keyword">return</span> PooledByteBufAllocator.DEFAULT.compositeDirectBuffer();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ServerInfo.getInstance().getByteBufType() == BYTEBUF_TYPE_UNPOOLED_DIRECT) &#123;</span><br><span class="line"><span class="keyword">return</span> UnpooledByteBufAllocator.DEFAULT.compositeDirectBuffer();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ServerInfo.getInstance().getByteBufType() == BYTEBUF_TYPE_POOLED_HEAP) &#123;</span><br><span class="line"><span class="keyword">return</span> PooledByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ServerInfo.getInstance().getByteBufType() == BYTEBUF_TYPE_UNPOOLED_HEAP) &#123;</span><br><span class="line"><span class="keyword">return</span> UnpooledByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> UnpooledByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    3) Netty 的文件传输采用了 transferTo 方法，它可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。</p><p>​    在实际的开发项目中，没有使用文件传输方法，顾该特性没有使用到。</p><h4 id="3-内存池"><a href="#3-内存池" class="headerlink" title="3. 内存池"></a>3. 内存池</h4><p>为了尽量重用缓冲区，Netty 提供了基于内存池的缓冲区重用机制。Netty 提供了多种内存管理策略，通过在启动辅助类中配置相关参数，可以实现差异化的定制。<br>PooledDirectByteBuf 的 newInstance 方法实现：</p><ul><li>通过 RECYCLER 的 get 方法循环使用 ByteBuf 对象，如果是非内存池实现，则直接创建一个新的 ByteBuf 对象。</li><li>从缓冲池中获取 ByteBuf 之后，调用 AbstractReferenceCountedByteBuf 的 setRefCnt 方法设置引用计数器，用于对象的引用计数和内存回收（类似 JVM 垃圾回收机制）。</li></ul><p>在上面零拷贝的实例中，可以看到对内存池<strong>UnpooledByteBufAllocator</strong>的使用。</p><h4 id="4-高效的-Reactor-线程模型"><a href="#4-高效的-Reactor-线程模型" class="headerlink" title="4. 高效的 Reactor 线程模型"></a>4. 高效的 Reactor 线程模型</h4><p>Reactor 线程模型分为以下三种：</p><p>​    1) Reactor 单线程模型；<br>​    2) Reactor 多线程模型；<br>​    3) 主从 Reactor 多线程模型；</p><p>实际应用中，我们使用的是主从 Reactor 多线程模型，代码实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bossGroup = <span class="keyword">new</span> EpollEventLoopGroup();</span><br><span class="line">workerGroup = <span class="keyword">new</span> EpollEventLoopGroup();</span><br><span class="line">serverBootstrap = serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                        .channel(EpollServerSocketChannel.class);</span><br></pre></td></tr></table></figure><p>服务端启动时创建了两个NioEventLoopGroup，实际上他们是两个独立的Reactor线程池，BossGroup用于服务端处理客户端建立TCP连接的请求，WorkerGroup用于处理I/O相关的读写操作，或则执行系统的Task，定时Task。</p><p>BossGroup线程池具体作用：<br>1)接收客户端的连接，初始化Channel参数；<br>2)将链路状态变更时间通知给ChannelPipeline；</p><p>WorkerGroup线程池具体作用：<br>​    1)异步读取通信对端的数据报，发送读事件到ChannelPipeline；<br>​    2)异步发送消息到通信对端，调用ChannelPipeline的消息发送接口；<br>​    3)执行系统调用、定时任务Task；</p><h4 id="5-无锁化的串行设计理念"><a href="#5-无锁化的串行设计理念" class="headerlink" title="5. 无锁化的串行设计理念"></a>5. 无锁化的串行设计理念</h4><p>为了尽可能提升性能，Netty 采用了串行无锁化设计，在 IO 线程内部进行串行操作，避免多线程竞争导致的性能下降。表面上看，串行化设计似乎 CPU 利用率不高，并发程度不够。但是，通过调整 NIO 线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列 - 多个工作线程模型性能更优。<br>具体实现：</p><p>Netty 的 NioEventLoop 读取到消息之后，直接调用 ChannelPipeline 的 fireChannelRead(Object msg)，只要用户不主动切换线程，一直会由 NioEventLoop 调用到用户的 Handler，期间不进行线程切换。</p><h4 id="6-高效的并发编程"><a href="#6-高效的并发编程" class="headerlink" title="6. 高效的并发编程"></a>6. 高效的并发编程</h4><p>1) volatile 的大量、正确使用 ;<br>2) CAS 和原子类的广泛使用；<br>3) 线程安全容器的使用；</p><p>举例说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推送注册列表</span></span><br><span class="line"><span class="keyword">private</span> ConcurrentHashMap&lt;Short, ResPush&gt; pushList = <span class="keyword">new</span> ConcurrentHashMap&lt;Short, ResPush&gt;();</span><br><span class="line"><span class="comment">// 推送数据队列</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">private</span> ArrayBlockingQueue&lt;Object&gt; dataQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Object&gt;(QUEUE_SIZE_MAX);</span><br></pre></td></tr></table></figure><p>4) 通过读写锁提升并发性能。</p><p>举例说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock writeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!writeLock.tryLock(<span class="number">10</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//写入数据操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-高性能的序列化框架"><a href="#7-高性能的序列化框架" class="headerlink" title="7. 高性能的序列化框架"></a>7. 高性能的序列化框架</h4><p>1) 序列化后的码流大小（网络带宽的占用）；</p><p>首先通过定制私有协议：增量+FAST协议，有效缩减每次请求或推送的数据返回包的大小，然后通过gzip/zip压缩、控制每个返回包的大小等手段实现降低网络带宽的占用。</p><p>其中压缩代码实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ServerInfo.getInstance().isZip()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (header.getZip() == ResHeader.RES_HEADER_ZIP_TO_GZIP) &#123;</span><br><span class="line">        <span class="comment">//压缩写入out，压缩后长度</span></span><br><span class="line">        bodyLen = GZipUtils.compress(bodyBuf, out);</span><br><span class="line">        header.setZip(ResHeader.RES_HEADER_ZIP_GZIP);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (header.getZip() == ResHeader.RES_HEADER_ZIP_TO_ZIP) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[bodyBuf.readableBytes()];</span><br><span class="line">        bodyBuf.readBytes(bytes);</span><br><span class="line">        <span class="keyword">byte</span>[] compress = ZipUtil.compress(bytes);</span><br><span class="line">        out.writeBytes(compress);</span><br><span class="line">        header.setZip(ResHeader.RES_HEADER_ZIP_ZIP);</span><br><span class="line">        bodyLen = compress.length;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bodyLen = bodyBuf.readableBytes();</span><br><span class="line">        <span class="keyword">if</span> (bodyLen &gt;= ServerInfo.getInstance().getZipMaxLength()) &#123;</span><br><span class="line">             <span class="comment">//压缩写入out，压缩后长度</span></span><br><span class="line">             bodyLen = GZipUtils.compress(bodyBuf, out);</span><br><span class="line">             <span class="comment">//压缩</span></span><br><span class="line">             header.setZip(ResHeader.RES_HEADER_ZIP_GZIP);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             out.writeBytes(bodyBuf);</span><br><span class="line">             header.setZip(ResHeader.RES_HEADER_ZIP_UNZIP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2) 序列化 &amp; 反序列化的性能（CPU 资源占用）；</p><p>因为涉及到私有协议的定制，不适合展开细讲，这里大体提一下，在序列化优化这方面，我们使用了增量+FAST协议栈的方式，包体协议定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UINT[] dps; //标识每一字段数据精度</span><br><span class="line">UINT baseNum; //基准数据id (int)</span><br><span class="line">TmpData</span><br><span class="line">&#123;</span><br><span class="line">BIT_VECTOR flag;//数据二进制位</span><br><span class="line">UINT[] diff;//增量数据 (int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>依次读入数据，选取基准数据，后续读入数据根据基准数据做增量，减少返回包数据大小。</p></li><li><p>增量数据设置：</p><ul><li><p>flag：     </p><p>​    ①第一位如果设置（isSet(0)），表示是全量数据，后面n-1位没有设置；</p><pre><code>②第一位如果没有设置，表示增量，后面n-1位设置过的表示有增量数据，未设置过的表示该位数据与基准数据对应数据相同。</code></pre></li><li><p>增量数据返回的数据与flag位是否设置相对应。</p></li></ul></li><li><p>私有协议同时支持可配置的全量拉取、注册推送等模式，降低服务器压力；</p></li></ul><p>3) 是否支持跨语言（异构系统的对接和开发语言切换）。</p><p>本项目中通过定制化私有协议实现了RPC服务与不同的客户端：终端、API、Web服务、Excel等的跨语言通信。</p><h4 id="8-灵活的-TCP-参数配置能力"><a href="#8-灵活的-TCP-参数配置能力" class="headerlink" title="8. 灵活的 TCP 参数配置能力"></a>8. 灵活的 TCP 参数配置能力</h4><p>1) SO_RCVBUF 和 SO_SNDBUF：通常建议值为 128K 或者 256K；<br>2) SO_TCPNODELAY：NAGLE 算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法；<br>3) 软中断：如果 Linux 内核版本支持 RPS（2.6.35 以上版本），开启 RPS 后可以实现软中断，提升网络吞吐量。</p><p>TCP/Socket的设置，具体有 SO_REUSEADDR， TCP_NODELAY， SO_KEEPALIVE，SO_LINGER， SO_TIMEOUT， SO_BACKLOG，SO_SNDBUF， SO_RCVBUF。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>迫于篇幅限制，本文只是单纯的对Netty的高性能编程实践进行了简单的罗列，实际在开发过程中，每一项改动都需要结合JVM监控工具及运维监控平台进行大量的参数修改及压力测试，力求找到RPC服务性能的最优解。当然根据生产环境的不同，这些特性的使用也不完全一致，需要我们具体对待。</p><p>通过对Netty高性能编程的时间以及JVM调优，线上服务的性能其实是有了不小的提升：</p><p>​    内存占用方面，报价接口服务内存占用从 25G 降低到 21G，实时接口服务内存占用从 26G 降低到 13G；<br>​    CPU 占用方面，线上 RPC 服务的 CPU 占用率从高峰期 1100%降低到 600%左右，服务器负载从 16 降低到 11；<br>​    I/O 带宽方面，返回包数据大小减小了 30%～36%。</p><p>最后还是要感谢李林峰老师，给我RPC服务的Netty性能调优提供了清晰的思路。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;我的Netty通信框架学习是从李林峰老师的《Netty权威指南（第二版）》开始的，书中从原始的I/O模型到Netty的高性能、可靠性等高级特性进行了由浅入深的讲解。偶然的机会，发现了李林峰老师在InfoQ上的专栏：&lt;a href=&quot;https://www.infoq.cn/profile/1278176&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;InfoQ_李林峰&lt;/a&gt;，当前还保持着不错的更新频率，大家感兴趣的可以关注一下。学习本身就是一个不断获取知识然后投入实践的过程，本文将简单记录下在我自己的项目中是如何实践Netty高性能编程的。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty直接内存泄露问题排查</title>
    <link href="http://yoursite.com/2018/11/16/Netty%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    <id>http://yoursite.com/2018/11/16/Netty直接内存泄露/</id>
    <published>2018-11-16T02:50:20.893Z</published>
    <updated>2019-03-30T05:38:33.144Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf21c6726a92.png" alt="netty.png"></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在做接口服务内存和CPU优化，使用Netty版本为<code>netty-all-4.1.29.Final</code>，对于行情数据我们采用Netty的直接内存进行存储，Netty的几种<code>ByteBuf</code>介绍见：<a href="https://f8f-1bearcat.github.io/2018/11/19/Netty%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%AF%B9%E8%B1%A1/" target="_blank" rel="noopener">Netty常见内存结构</a> ，当前我们使用的是<code>PooledByteBufAllocator</code>，所以每次内存使用完毕后都需要通过<code>release()</code>方法手动回收直接内存。</p><p>使用Netty的直接内存有点与C类似，自己malloc的对象需要自己free；但与C不同的是，在内有引用计数器，外有Java的GC的场景下，Netty直接内存的使用更为复杂，对内存的使用稍有纰漏就会导致整个服务挂掉。在一次优化版本中，就出现了很严重的Netty直接内存泄露的问题。<br><a id="more"></a></p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>前一天盘后我们部署了某个优化版本到灰度服务器上，第二天行情数据下发后伴随着用户量增长，接口服务在很短的时间内不可用。</p><p>通过运维平台调取了当天该服务器上的内存使用情况：</p><p><img src="https://i.loli.net/2018/11/19/5bf2700185b45.png" alt="SZVPC内存使用情况.png"></p><p>可以发现在上午9:00~11:00时间段内，接口服务多次挂掉后自动重启，中午版本回退后服务才恢复正常。</p><h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><h3 id="一、查看系统日志"><a href="#一、查看系统日志" class="headerlink" title="一、查看系统日志"></a>一、查看系统日志</h3><p>首先查看服务异常时间段内服务器上的日志，可以发现在短时间内日志打印了非常多的直接内存分配异常<code>OutOfDirectMemoryError</code>：</p><p><img src="https://i.loli.net/2018/11/19/5bf28a9a2d455.png" alt="直接内存分配异常.png"></p><p>日志显示直接内存Direct Memory不够用了，该服务器上配置了堆内存12G，直接内存18G，与异常中打印的最大可分配直接内存相匹配；</p><p><img src="https://i.loli.net/2018/11/19/5bf2701a7dc76.png" alt="内存配置.png"></p><p>根据之前的内存使用情况可以断定在服务正常状态下，18G直接内存是能满足接口服务使用场景的，那就可以断定单纯地在配置中增大可分配直接内存的大小不能解决问题。</p><h3 id="二、确认异常抛出原因"><a href="#二、确认异常抛出原因" class="headerlink" title="二、确认异常抛出原因"></a>二、确认异常抛出原因</h3><p>通过上面OOM异常日志，可以追踪到<code>PlatformDependent.java</code>的<code>incrementMemoryCounter(int capacity)</code>方法。</p><p><img src="https://i.loli.net/2018/11/19/5bf21b9878c32.png" alt=""></p><p>我们可以看到这个方法是Netty自身对已使用直接内存进行计数，当计数器<code>DIRECT_MEMORY_COUNTER</code>已使用内存大于直接内存上限<code>DIRECT_MEMORY_LIMIT</code>时，抛出一个OutOfDirectMemoryError异常，这个直接内存上限即上面我们在配置文件中通过<code>-XX:MaxDirectMemorySize</code>配置的。关于Netty的OutOfDirectMemoryError问题见：<a href="https://f8f-1bearcat.github.io/2018/11/19/Netty%E7%9A%84OutOfDirectMemoryError%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">关于Netty的OutOfDirectMemoryError问题</a> 。</p><p>无法分配直接内存无非是以下两种情况导致的：</p><ol><li>分配的直接内存最终没有<code>release()</code>掉，使直接内存不断被分配使用而没有回收掉，最终达到可用上限产生内存泄露；</li><li>因用户网络异常或者传输的数据量过大等问题，使得直接内存的释放回收速度小于其分配的速度，最终无内存可分配抛出OOM。</li></ol><p>如果是前者，就需要找出没有正确<code>release()</code>的代码进行修改；如果是后者，则需要在write的时候，添加流控措施，避免到达内存限制。</p><h3 id="三、Netty内存泄漏的监测机制"><a href="#三、Netty内存泄漏的监测机制" class="headerlink" title="三、Netty内存泄漏的监测机制"></a>三、Netty内存泄漏的监测机制</h3><p>Netty本身提供了内存泄漏的监测机制（详细介绍见：<a href="https://f8f-1bearcat.github.io/2018/11/19/Netty%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%AF%B9%E8%B1%A1/" target="_blank" rel="noopener">Netty引用计数对象</a>），我们可以通过在配置文件中配置<code>-Dio.netty.leakDetectionLevel</code>对分配的ByteBuf进行跟踪。</p><p><img src="https://i.loli.net/2018/11/19/5bf27013c719b.png" alt="leakDetection.png"></p><p>如果服务有内存泄露，则会打印如下日志：</p><blockquote><p>LEAK: ByteBuf.release() was not called before it’s garbage-collected. Enable advanced leak reporting to find out where the leak occurred. To enable advanced leak reporting, specify the JVM option ‘-Dio.netty.leakDetectionLevel=paranoid’ or call ResourceLeakDetector .setLevel()</p></blockquote><p>因为是功能测试，所以在异常服务上，我将监测的级别配置为paranoid，运行一段时间后查看服务日志，发现并未有<strong>LEAK </strong>日志打印，看来通过Netty自身的监测机制定位问题这条路走不通。</p><h3 id="四、Arthas查看直接内存使用情况"><a href="#四、Arthas查看直接内存使用情况" class="headerlink" title="四、Arthas查看直接内存使用情况"></a>四、Arthas查看直接内存使用情况</h3><p>我们知道服务是因为已使用直接内存达到了可分配上限才挂掉的，那通过查看服务器上<code>DIRECT_MEMORY_COUNTER</code>的大小能不能发现问题呢？这时候不得不提到Java诊断神器Arthas了（详细介绍见：<a href="https://f8f-1bearcat.github.io/2018/11/19/Arthas%E2%80%94%E5%BC%80%E6%BA%90Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/" target="_blank" rel="noopener">介绍一款开源Java诊断工具—Arthas</a> ）。</p><p>通过Arthas进入到当前服务进程，执行sc命令来查看<code>PlatformDependent.java</code>类的成员变量：</p><blockquote><p>sc -df io.netty.util.internal.PlatformDependent</p></blockquote><p>可以看到命令执行后当前时间的<strong>已分配直接内存</strong>和<strong>可分配直接内存上限</strong>两个参数的值：</p><p><img src="https://i.loli.net/2018/11/19/5bf26527165f9.png" alt="directmemory.png"></p><p>使用Arthas来查看确实简单便捷，但是因为只能查看一个时间点的变量的值（<del>也可能是我的打开方式不对</del>），对我们解决问题帮助不是很大，所以还是用笨办法吧，即通过起一个线程来定时打印直接内存的值。</p><h3 id="五、日志打印直接内存"><a href="#五、日志打印直接内存" class="headerlink" title="五、日志打印直接内存"></a>五、日志打印直接内存</h3><h4 id="直接内存定时打印"><a href="#直接内存定时打印" class="headerlink" title="直接内存定时打印"></a>直接内存定时打印</h4><p>这里我写了一个线程，每两秒将通过反射获取的<code>DIRECT_MEMORY_COUNTER</code>参数的值在日志中实时打印出来，方便我们调试。</p><p><img src="https://i.loli.net/2018/11/19/5bf26713a10a9.png" alt="直接内存打印.png"></p><h4 id="模拟客户端进行压力测试"><a href="#模拟客户端进行压力测试" class="headerlink" title="模拟客户端进行压力测试"></a>模拟客户端进行压力测试</h4><p>为了能明显地看到内存分配的数值变化，这里我通过编写TestMain模拟客户端用户来请求接口服务数据；</p><p><img src="https://i.loli.net/2018/11/19/5bf269a675904.png" alt="压力测试.png"></p><p>并设置模拟用户量为200，将有问题的服务部署到开发服务器上进行压力测试。</p><p><img src="https://i.loli.net/2018/11/19/5bf2699bdaf27.png" alt="压力测试用户.png"></p><h4 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h4><p>首先将开发服务器上接口服务启动，这是当前服务的端口连接数为0，即没有用户访问，这时服务已使用的直接内存维持在一个稳定的值256MB（如下图前几条日志所示）；当把压力测试程序启动，随着用户连接数涨到200，服务已使用的直接内存迅速飙升（如下图选中日志所示），一直达到可用内存上限18G，最终导致服务不可用，整个用时不到5分钟！</p><p><img src="https://i.loli.net/2018/11/19/5bf2746f146fc.png" alt="内存日志2.png"></p><p>到这里我们可以得出结论，本次内存泄露与接口服务处理上游数据的过程无关，而是在处理用户请求并返回数据的过程中抛出的。</p><p>到这里问题的定位范围进一步缩小，我还是采用了虽然繁琐但是直接有效的方法：范围从大到小地对请求返回数据过程中分配及使用直接内存的代码块进行注释，并部署到开发服务器上进行测试。</p><p>其中的具体操作过程略去不表，其实结果证明这个方法确实是很有效的，我只重新部署哦了两次服务就找到了问题代码：</p><p><img src="https://i.loli.net/2018/11/19/5bf280fb7fd1e.png" alt="callback.png"></p><p>当我把上图选中代码注释掉后，再进行压力测试接口服务已使用直接内存的值维持在256MB不再增长，如下图所示：</p><p><img src="https://i.loli.net/2018/11/19/5bf272fdb0bbf.png" alt="内存日志1.png"></p><p>进入到<code>callback()</code>方法最终修改了下图所示代码，对已分配但未使用的直接内存进行<code>release()</code>回收释放，重新部署，测试通过。</p><p><img src="https://i.loli.net/2018/11/19/5bf280fb09e34.png" alt="代码修改.png"></p><h3 id="六、后续"><a href="#六、后续" class="headerlink" title="六、后续"></a>六、后续</h3><p>我提交了代码盘后通过CI重新发布到之前出现异常的服务器上，几个交易日过去了，问题没有再出现。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>1.对于Netty直接内存问题，我们可以通过三种手段来定位问题：Netty自身的内存泄露监测机制；Arthas等第三方工具；反射获取并打印直接内存数值。</p><p>2.这次问题的出现是只在ByteBuf使用之后进行了回收，没有考虑到在异常情况下ByteBuf没有成功传递到下一个Hanlder（<del>其实考虑到了，只不过疏忽了这个分支</del>），这时也要把分配了没有使用的直接内存进行回收。</p><p>3.至于为什么Netty自身的监测机制没有打印LEAK日志，后面我会再研究一下。</p><p>最后希望大家都能：</p><p><img src="https://i.loli.net/2018/11/19/5bf28b9a947e9.png" alt="表情.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf21c6726a92.png&quot; alt=&quot;netty.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在做接口服务内存和CPU优化，使用Netty版本为&lt;code&gt;netty-all-4.1.29.Final&lt;/code&gt;，对于行情数据我们采用Netty的直接内存进行存储，Netty的几种&lt;code&gt;ByteBuf&lt;/code&gt;介绍见：&lt;a href=&quot;https://f8f-1bearcat.github.io/2018/11/19/Netty%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%AF%B9%E8%B1%A1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Netty常见内存结构&lt;/a&gt; ，当前我们使用的是&lt;code&gt;PooledByteBufAllocator&lt;/code&gt;，所以每次内存使用完毕后都需要通过&lt;code&gt;release()&lt;/code&gt;方法手动回收直接内存。&lt;/p&gt;
&lt;p&gt;使用Netty的直接内存有点与C类似，自己malloc的对象需要自己free；但与C不同的是，在内有引用计数器，外有Java的GC的场景下，Netty直接内存的使用更为复杂，对内存的使用稍有纰漏就会导致整个服务挂掉。在一次优化版本中，就出现了很严重的Netty直接内存泄露的问题。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java(10)</title>
    <link href="http://yoursite.com/2018/11/15/Effective%20Java(10)/"/>
    <id>http://yoursite.com/2018/11/15/Effective Java(10)/</id>
    <published>2018-11-15T09:32:56.881Z</published>
    <updated>2018-11-19T05:34:25.830Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf24a39023ab.jpg" alt="effective-java.jpg"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>Effective Java第10章 并发 学习笔记</p><a id="more"></a><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="66-同步访问共享的可变数据"><a href="#66-同步访问共享的可变数据" class="headerlink" title="66 同步访问共享的可变数据"></a>66 同步访问共享的可变数据</h3><ul><li>程序不会终止，后台线程永远在循环。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> stopRequested;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">Thread </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf24a39023ab.jpg&quot; alt=&quot;effective-java.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;Effective Java第10章 并发 学习笔记&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Effective Java" scheme="http://yoursite.com/tags/Effective-Java/"/>
    
  </entry>
  
</feed>
