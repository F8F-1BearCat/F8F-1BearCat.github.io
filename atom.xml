<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Magical Cat</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-25T09:49:42.199Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>F8F-1BearCat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日志分析接口协议的设计与实现</title>
    <link href="http://yoursite.com/2019/03/25/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E6%8E%A5%E5%8F%A3%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/03/25/日志分析接口协议设计与实现/</id>
    <published>2019-03-25T09:35:20.701Z</published>
    <updated>2019-03-25T09:49:42.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p><img src="https://cdn2.iconfinder.com/data/icons/productivity-social-vol-2/512/checkmark_approve-128.png" alt="Choice"><br>通过日志信息对RPC服务调用的用户进行监控，挺高系统的稳定性。本文简要记录了一下日志分析接口协议的设计与实现.<br><a id="more"></a></p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="HTTP接口"><a href="#HTTP接口" class="headerlink" title="HTTP接口"></a>HTTP接口</h3><p>请求方式： <code>post</code><br>请求参数： </p><ul><li>HTTP header<br><code>Content-Type=application/json    （必须）</code></li><li><p>HTTP body</p><pre><code>{</code></pre><p>  ​        “log_project_name”:”testhttp”,<br>  ​        “log_message_type”:”request”,<br>  ​        “log_format”:”default”,<br>  ​        “log_from”:”172.0.0.1”,<br>  ​        “log_content”:”2017-06-28 22:39:44,959 [P58,] communicationInfo - {\”cid\”:\”1111\”,\”clientIP\”:\”10.10.10.10\”,\”request\”:\”simpleSearch\”,\”timeAll\”:107,\”respLength\”:55555}”<br>  ​    }<br>  ​    </p></li></ul><p>body中为JSON字符串<br>JSON参数</p><blockquote><p>log_project_name：项目名称 同一个项目使用同一个名称<br>log_message_type：日志类型request (请求日志),error(错误日志)<br>log_format：日志格式default<br>log_from：日志来源机器每台机器写自己的IP作为一个标示<br>log_content：根据日志类型发送的日志内容（日志内容格式请见下文）</p></blockquote><h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><p>读取日志文件（日志内容格式请见下文）</p><h3 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h3><p>日志格式为两种</p><h4 id="日志格式为-request-解析类型为-default-日志为一行"><a href="#日志格式为-request-解析类型为-default-日志为一行" class="headerlink" title="日志格式为 request 解析类型为 default 日志为一行"></a>日志格式为 <code>request</code> 解析类型为 <code>default</code> 日志为一行</h4><p>示例:</p><pre><code>2017-06-21 22:37:44,959  -  {&quot;cid&quot;:&quot;1111&quot;,&quot;clientIP&quot;:&quot;10.10.10.10&quot;,&quot;request&quot;:&quot;simpleSearch&quot;,&quot;timeAll&quot;:107, &quot;respLength&quot;:55555}</code></pre><p>请求日志内容格式 分为3块</p><ol><li>时间开头格式必须为 <code>yyyy-MM-dd HH:mm:ss,SSS</code></li><li>分隔符 <code>-</code></li><li>JSON内容<blockquote><p>cid：用户ID<br> clientIP：客户端IP<br> request：请求业务类型<br> timeAll：耗时<br> respLength：返回大小</p></blockquote></li></ol><p><strong>注意：json中字段为必填字段若没有值则使用空字符串</strong></p><h4 id="日志格式为-error-解析类型为-default-日志可以为多行"><a href="#日志格式为-error-解析类型为-default-日志可以为多行" class="headerlink" title="日志格式为 error 解析类型为 default 日志可以为多行"></a>日志格式为 <code>error</code> 解析类型为 <code>default</code> 日志可以为多行</h4><p>示例</p><pre><code>2017-06-19 22:54:58,151  InfoThreadPool requestInfo http://www.eastmoney.com/ open error</code></pre><p>错误日志内容格式 分为2块</p><ol><li>时间开头格式必须为<code>yyyy-MM-dd HH:mm:ss,SSS</code></li><li>错误内容<br>注意:错误日志读取时，只匹配日志开头是否为此格式的时间，最多读取500行，当行中出现<code>eastmoney</code>关键字时，停止读取。</li></ol><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><h4 id="每一台服务器的访问情况"><a href="#每一台服务器的访问情况" class="headerlink" title="每一台服务器的访问情况"></a>每一台服务器的访问情况</h4><ul><li><code>LoginHandler</code>每次登录输出日志</li><li>日志内容字段<blockquote><p>cid：用户ID<br>  clientIP：客户端IP<br>  request：请求业务类型<br>  timeAll：耗时<br>  respLength：返回大小</p></blockquote></li></ul><h4 id="每个用户所做的操作"><a href="#每个用户所做的操作" class="headerlink" title="每个用户所做的操作"></a>每个用户所做的操作</h4><ul><li>调用Handler的doHandle()时输出日志<blockquote><p>cid：用户ID<br>  clientIP：客户端IP<br>  request：请求业务类型<br>  timeAll：耗时<br>  respLength：返回大小</p></blockquote></li></ul><p>count_info</p><pre><code>机房，服务器类型，服务器ip，服务器端口，用户数，时间，备注area,server_type,server_ip,server_port,count,time,desc</code></pre><p>user_log</p><pre><code>用户id,客户端ip,客户端端口,服务器ip，服务器端口，请求id，时间，备注clientid,remote_server,remote_port,server_ip,server_port,request_id,time,desc</code></pre><h4 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h4><p><strong>LIST_10.10.10.10_80-1818-443_sys.2017110620.log</strong></p><ul><li><p>request_id为 <strong>-1</strong>，预留位desc赋值为当前用户数（链接数），每分钟打印一次</p><blockquote><p>2017-10-30 13:26:00.574 - {“clientid”:””,”remote_server”:””,”remote_port”:””,”server_port”:””,”request_id”:-1,”desc”:”500”}</p></blockquote></li><li><p>request_id为 <strong>-2</strong>，预留位desc赋值为链接断线原因</p><blockquote><p>2017-10-30 13:26:00.574 - {“clientid”:”22000000000”,”remote_server”:”10.10.10.10”,”remote_port”:”30040”,”server_port”:”1818”,”request_id”:-2,”desc”:0}</p></blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> UNKNOWN = <span class="number">0</span>;   <span class="comment">//未知</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> WRITE_WAITE_MANY_TIMES = <span class="number">1</span>;   <span class="comment">//写等待次数过多</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> FORCE_NO_CANCEL_REQUEST = <span class="number">2</span>;   <span class="comment">//强制去除，客户端没有发送取消请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> CHANNEL_GROUP_CHECK = <span class="number">3</span>;   <span class="comment">//ChannelGroup检查关闭</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> HANDLER_EXCEPTION = <span class="number">4</span>;   <span class="comment">//Handler exceptionCaught触发</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> HANDLER_CLOSED = <span class="number">5</span>;   <span class="comment">//Handler Closed触发</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> CHANNEL_EXCEPTION = <span class="number">6</span>;   <span class="comment">//Handler Closed触发</span></span><br></pre></td></tr></table></figure></li><li><p>正常打印请求信息</p><blockquote><p>2017-10-30 13:26:00.574 - {“clientid”:”22000000000”,”remote_server”:”10.10.10.10”,”remote_port”:”30040”,”server_port”:”1818”,”request_id”:16066,”desc”:””}</p></blockquote></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>logback的使用和logback.xml详解:<a href="http://www.cnblogs.com/warking/p/5710303.html" target="_blank" rel="noopener">http://www.cnblogs.com/warking/p/5710303.html</a><br>logback.xml配置:<a href="http://blog.csdn.net/qq173684423/article/details/53611906" target="_blank" rel="noopener">http://blog.csdn.net/qq173684423/article/details/53611906</a><br>logback配置详解<a href="http://blog.csdn.net/haidage/article/details/6794509" target="_blank" rel="noopener">http://blog.csdn.net/haidage/article/details/6794509</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn2.iconfinder.com/data/icons/productivity-social-vol-2/512/checkmark_approve-128.png&quot; alt=&quot;Choice&quot;&gt;&lt;br&gt;通过日志信息对RPC服务调用的用户进行监控，挺高系统的稳定性。本文简要记录了一下日志分析接口协议的设计与实现.&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
      <category term="RPC" scheme="http://yoursite.com/tags/RPC/"/>
    
      <category term="logback" scheme="http://yoursite.com/tags/logback/"/>
    
  </entry>
  
  <entry>
    <title>解析OpenJDK12的新特性</title>
    <link href="http://yoursite.com/2019/03/25/%E8%A7%A3%E6%9E%90OpenJDK12%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/03/25/解析OpenJDK12的新特性/</id>
    <published>2019-03-25T09:34:38.995Z</published>
    <updated>2019-03-25T09:42:49.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>挖坑待填…<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;挖坑待填…&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="OpenJDK" scheme="http://yoursite.com/tags/OpenJDK/"/>
    
  </entry>
  
  <entry>
    <title>同步、异步、阻塞、非阻塞IO</title>
    <link href="http://yoursite.com/2019/01/29/%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9EIO/"/>
    <id>http://yoursite.com/2019/01/29/同步、异步、阻塞、非阻塞IO/</id>
    <published>2019-01-29T06:58:00.260Z</published>
    <updated>2019-01-31T06:43:45.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近在整理过去一段时间内Netty性能调优的工作，涉及到了Netty的NIO/Epoll等异步非阻塞通信，索性复习一下常见的几种IO模型。看到CSDN上这篇文章写得很清晰易懂，<a href="https://blog.csdn.net/historyasamirror/article/details/5778378" target="_blank" rel="noopener">IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）</a>，在此基础上整理了一下，方便记忆及以后查看。</p><a id="more"></a><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>IO发生时会经历两个阶段：</p><ul><li><p>等待数据</p></li><li><p>将数据从内核复制到用户空间</p></li></ul><p>不同的IO模型就是根据在这两个阶段所做的处理不同进行区分的。</p><h3 id="Blocking-IO"><a href="#Blocking-IO" class="headerlink" title="Blocking IO"></a>Blocking IO</h3><p><img src="https://i.loli.net/2019/01/30/5c5151d73a80d.jpg" alt="blocking IO.jpg"></p><p><strong>阻塞IO模型（BIO）</strong>：应用进程调用recvfrom，kernel开始了IO的第一阶段：等待数据，等到数据准备好了，kernel开始第二阶段：将数据从内核复制到用户空间。在IO的这两个阶段执行期间，应用进程一直处于block状态，直到kernel返回结果，应用进程阻塞才解除。</p><p>举例：你在美团上点了一份外卖，下单后外卖小哥开始取餐（阶段一），取到餐后再进行配送（阶段二），期间你一直站在门口等（block状态），直到收到外卖才继续自己的事情。</p><h3 id="Nonblocking-IO"><a href="#Nonblocking-IO" class="headerlink" title="Nonblocking IO"></a>Nonblocking IO</h3><p><img src="https://i.loli.net/2019/01/30/5c5151d7b62f1.jpg" alt="non-blocking IO.jpg"></p><p><strong>非阻塞IO模型（NIO）</strong>：应用进程调用recvfrom，kernel开始了IO的第一阶段：等待数据，如果kernel中的数据还没有准备好，就返回应用进程EWOULDBLOCK，应用进程收到返回后会一直调用recvfrom询问kernel，直到数据准备好，在此期间应用进程处于非block状态；然后kernel将数据从内核复制到用户空间，并block应用进程，直到成功返回后阻塞状态解除。所以非阻塞IO和阻塞IO不是完全对立的，在IO第二阶段二者均处于block状态。</p><p>举例：你在美团上点了一份外卖，下单后外卖小哥开始取餐（阶段一），在取餐期间你坐在屋里一遍看剧一边不断打电话给外卖小哥询问取到了没，直到小哥说他拿到了；这时小哥取到餐后进行配送（阶段二），你也起身站在门口等（block状态），直到收到外卖。</p><h3 id="IO-multiplexing"><a href="#IO-multiplexing" class="headerlink" title="IO multiplexing"></a>IO multiplexing</h3><p><img src="https://i.loli.net/2019/01/30/5c5151d7af63b.jpg" alt="IO multiplexing.jpg"></p><p><strong>IO复用模型</strong>：应用进程调用select，通过select可以不断的轮询所负责的所有socket，当某个socket的数据准备好了，select就会返回信息，然后用户态进程调用recvfrom，将数据从内核复制到用户空间。对于每一个socket，一般都设置成为non-blocking，但是整个应用进程受阻于select调用；同样，在IO的第二阶段，应用进程也是出于block状态。</p><p>如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于单个process就可以同时处理多个网络连接的IO。</p><p>Linux关于IO复用的使用，有三种不同的API，select、poll和epoll，关于这三种API的实现分析，可以参考下这篇文章：<a href="https://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="noopener">select、poll、epoll之间的区别总结[整理]</a>。</p><p>举例：这次你在美团上一次点了好几份外卖，美团的消息系统（select等API调用）推给你说等有外卖取到了就发消息给你，让你留意消息（block状态），然后几个外卖小哥就到不同的店去取餐（阶段一）。等取到餐了，如果你用的是select或poll版本的美团，消息推给你说你有订单已经取到了，但是不告诉你是哪家；如果你用的是epoll版本的美团，消息推给你说你有订单已经取到了，而且还告诉你是碳烤羊排。收到消息之后你就到门口去等（block状态），外卖小哥进行配送（阶段二），直到收到外卖才继续自己的事情。</p><h3 id="Asynchronous-IO"><a href="#Asynchronous-IO" class="headerlink" title="Asynchronous IO"></a>Asynchronous IO</h3><p><img src="https://i.loli.net/2019/01/30/5c5151d704ff1.jpg" alt="Asynchronous IO.jpg"></p><p><strong>异步IO模型（AIO）</strong>：应用进程调用aio_read，kernel收到请求后会立刻返回，等数据准备好，并且复制到用户空间后执行事先指定好的函数，整个过程应用进程都处于非block状态。</p><p>举例：你发现自己出去等太大笨蛋了，在美团上点了一份外卖，看到下单成功后就去看剧了。外卖小哥开始取餐（阶段一），取到餐后再进行配送（阶段二），最后送到你门口，整个过程你都在干自己的事情，没有一直等着（非block状态）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="IO模型对比"><a href="#IO模型对比" class="headerlink" title="IO模型对比"></a>IO模型对比</h3><p><img src="https://i.loli.net/2019/01/30/5c5151d774bba.jpg" alt="IO Models.jpg"></p><p>因为信号驱动式IO（signal-driven I/O）使用较少，正文中没提及。</p><p><strong>阻塞IO和非阻塞IO</strong>：调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p><p><strong>同步IO和异步IO</strong>：synchronous IO做”IO operation”的时候会将process阻塞，blocking IO，non-blocking IO，IO multiplexing因为都阻塞于recvfrom调用，都属于synchronous IO。</p><p><strong>非阻塞IO和异步IO</strong>：在数据准备阶段，non-blocking IO中进程不会被block，但是它仍然要求进程去主动的check，而asynchronous IO中应用进程进程将整个IO操作交给kernel来完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;最近在整理过去一段时间内Netty性能调优的工作，涉及到了Netty的NIO/Epoll等异步非阻塞通信，索性复习一下常见的几种IO模型。看到CSDN上这篇文章写得很清晰易懂，&lt;a href=&quot;https://blog.csdn.net/historyasamirror/article/details/5778378&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）&lt;/a&gt;，在此基础上整理了一下，方便记忆及以后查看。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>读懂Young GC日志</title>
    <link href="http://yoursite.com/2018/12/18/%E8%AF%BB%E6%87%82Young%20GC%E6%97%A5%E5%BF%97/"/>
    <id>http://yoursite.com/2018/12/18/读懂Young GC日志/</id>
    <published>2018-12-18T06:46:08.526Z</published>
    <updated>2018-12-19T01:41:01.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>在进行JVM调优时我们经常需要通过日志信息来分析G1GC的性能，本文就日志中可供收集的数据和信息进行了简单介绍。<br><a id="more"></a></p><h2 id="Young-GC日志"><a href="#Young-GC日志" class="headerlink" title="Young GC日志"></a>Young GC日志</h2><p>下面选取了SZVPC线上报价服务的一段Young GC日志：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;Heap before GC invocations=<span class="number">38623</span> (full <span class="number">4</span>):</span><br><span class="line"> garbage-first heap   total <span class="number">25165824</span>K, used <span class="number">11321508</span>K [<span class="number">0x00000001c0000000</span>, <span class="number">0x00000001c040c000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  region size <span class="number">4096</span>K, <span class="number">307</span> young (<span class="number">1257472</span>K), <span class="number">26</span> survivors (<span class="number">106496</span>K)</span><br><span class="line"> Metaspace       used <span class="number">23093</span>K, capacity <span class="number">23236</span>K, committed <span class="number">29440</span>K, reserved <span class="number">1075200</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 2444<span class="title">K</span>, <span class="title">capacity</span> 2510<span class="title">K</span>, <span class="title">committed</span> 3328<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line">2018-12-18T11:19:27.084+0800: 671040.790: [GC pause (G1 Evacuation Pause) (young), 0.3639131 secs]</span><br><span class="line">   [Parallel Time: <span class="number">354.4</span> ms, GC Workers: <span class="number">13</span>]</span><br><span class="line">      [<span class="function">GC Worker <span class="title">Start</span> <span class="params">(ms)</span>: Min: 671040790.4, Avg: 671040790.6, Max: 671040790.8, Diff: 0.4]</span></span><br><span class="line"><span class="function">      [Ext Root <span class="title">Scanning</span> <span class="params">(ms)</span>: Min: 0.8, Avg: 1.0, Max: 1.2, Diff: 0.4, Sum: 13.0]</span></span><br><span class="line"><span class="function">      [Update <span class="title">RS</span> <span class="params">(ms)</span>: Min: 22.6, Avg: 23.0, Max: 23.6, Diff: 1.0, Sum: 299.6]</span></span><br><span class="line"><span class="function">         [Processed Buffers: Min: 24, Avg: 32.5, Max: 39, Diff: 15, Sum: 422]</span></span><br><span class="line"><span class="function">      [Scan <span class="title">RS</span> <span class="params">(ms)</span>: Min: 201.4, Avg: 202.0, Max: 202.4, Diff: 1.0, Sum: 2625.9]</span></span><br><span class="line"><span class="function">      [Code Root <span class="title">Scanning</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.0, Sum: 0.2]</span></span><br><span class="line"><span class="function">      [Object <span class="title">Copy</span> <span class="params">(ms)</span>: Min: 126.9, Avg: 127.2, Max: 127.8, Diff: 0.9, Sum: 1653.5]</span></span><br><span class="line"><span class="function">      [<span class="title">Termination</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.6, Max: 0.9, Diff: 0.9, Sum: 8.3]</span></span><br><span class="line"><span class="function">         [Termination Attempts: Min: 1, Avg: 278.6, Max: 349, Diff: 348, Sum: 3622]</span></span><br><span class="line"><span class="function">      [GC Worker <span class="title">Other</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.1, Max: 0.3, Diff: 0.2, Sum: 1.6]</span></span><br><span class="line"><span class="function">      [GC Worker <span class="title">Total</span> <span class="params">(ms)</span>: Min: 353.8, Avg: 354.0, Max: 354.2, Diff: 0.4, Sum: 4602.1]</span></span><br><span class="line"><span class="function">      [GC Worker <span class="title">End</span> <span class="params">(ms)</span>: Min: 671041144.5, Avg: 671041144.6, Max: 671041144.7, Diff: 0.2]</span></span><br><span class="line"><span class="function">   [Code Root Fixup: 0.0 ms]</span></span><br><span class="line"><span class="function">   [Code Root Purge: 0.0 ms]</span></span><br><span class="line"><span class="function">   [Clear CT: 1.7 ms]</span></span><br><span class="line"><span class="function">   [Other: 7.8 ms]</span></span><br><span class="line"><span class="function">      [Choose CSet: 0.0 ms]</span></span><br><span class="line"><span class="function">      [Ref Proc: 0.6 ms]</span></span><br><span class="line"><span class="function">      [Ref Enq: 0.0 ms]</span></span><br><span class="line"><span class="function">      [Redirty Cards: 2.5 ms]</span></span><br><span class="line"><span class="function">      [Humongous Register: 0.2 ms]</span></span><br><span class="line"><span class="function">      [Humongous Reclaim: 0.1 ms]</span></span><br><span class="line"><span class="function">      [Free CSet: 3.0 ms]</span></span><br><span class="line"><span class="function">   [Eden: 1124.0<span class="title">M</span><span class="params">(<span class="number">1124.0</span>M)</span>-&gt;0.0<span class="title">B</span><span class="params">(<span class="number">1132.0</span>M)</span> Survivors: 104.0M-&gt;96.0M Heap: 10.8<span class="title">G</span><span class="params">(<span class="number">24.0</span>G)</span>-&gt;9968.2<span class="title">M</span><span class="params">(<span class="number">24.0</span>G)</span>]</span></span><br><span class="line"><span class="function">Heap after GC invocations</span>=<span class="number">38624</span> (full <span class="number">4</span>):</span><br><span class="line"> garbage-first heap   total <span class="number">25165824</span>K, used <span class="number">10207396</span>K [<span class="number">0x00000001c0000000</span>, <span class="number">0x00000001c040c000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  region size <span class="number">4096</span>K, <span class="number">24</span> young (<span class="number">98304</span>K), <span class="number">24</span> survivors (<span class="number">98304</span>K)</span><br><span class="line"> Metaspace       used <span class="number">23093</span>K, capacity <span class="number">23236</span>K, committed <span class="number">29440</span>K, reserved <span class="number">1075200</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 2444<span class="title">K</span>, <span class="title">capacity</span> 2510<span class="title">K</span>, <span class="title">committed</span> 3328<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"> [Times: user=4.64 sys=0.00, real=0.36 secs]</span><br></pre></td></tr></table></figure></p><h4 id="日志信息详解："><a href="#日志信息详解：" class="headerlink" title="日志信息详解："></a>日志信息详解：</h4><ul><li><p><strong>garbage-first heap   total 25165824K, used 11321508K [0x00000001c0000000, 0x00000001c040c000, 0x00000007c0000000)</strong></p><p>可以看出GC的类型为G1，Heap的总大小为25165824K，已使用11321508K。</p></li><li><p><strong>region size 4096K, 307 young (1257472K), 26 survivors (106496K)</strong></p><p>每个region的大小为4096K，新生代307个region，survivor区26个region。</p></li><li><p><strong>Metaspace       used 23093K, capacity 23236K, committed 29440K, reserved 1075200K<br> class space    used 2444K, capacity 2510K, committed 3328K, reserved 1048576K</strong></p><p>java8去掉了永久区（Permanent），新增元数据区（Metaspace）。</p></li><li><p><strong>671040.790: [GC pause (G1 Evacuation Pause) (young), 0.3639131 secs]</strong></p><p>G1停顿清理(young) regions，即新生代minor GC。本次停顿在JVM启动后671040.790 s后触发，且停顿持续时间为0.3639131 s，根据系统时间（wall clock time）测定。</p></li><li><p><strong>[Parallel Time: 354.4 ms, GC Workers: 13]</strong></p><p>收集过程是多线程并发执行的，日志表明在354.4ms（real time）时间内，下面的活动是由13个线程并行完成的：</p><ol><li><p><code>GC Worker Start (ms)</code></p><p>收集线程开始的时间，匹配停顿开始时的时间戳。使用的是相对时间，Min是最早开始时间，Avg是平均开始时间，Max是最晚开始时间，Diff是Max-Min。 如果Min和Max差别很大，那么可能表明使用了太多线程或者机器上的其他进程正在从JVM内部的垃圾收集进程中窃取CPU时间。</p></li><li><p><code>Ext Root Scanning (ms)</code></p><p>扫描外部（非heap）roots如类加载器、JNI引用、JVM 系统roots等的耗时，Sum是Cpu time。</p></li><li><p><code>Update RS (ms)</code></p><p>每个线程更新Remembered Set的耗时。</p></li><li><p><code>Scan RS (ms)</code></p><p>扫描CS中的region对应的RSet，因为RSet是points-into，所以这样实现避免了扫描old generadion region，但是会产生float garbage。</p></li><li><p><code>Code Root Scanning (ms)</code></p><p>扫描code roots如本地变量的耗时。code roots指的是经过JIT编译后的代码里，引用了heap中的对象。引用关系保存在RSet中。</p></li><li><p><code>Object Copy (ms)</code></p><p>从收集region拷贝存活的对象到新region的耗时。</p></li><li><p><code>Termination (ms)</code></p><p>工作线程确保它们能够安全地停止并且没有更多的工作要做最终终止所用的耗时。在结束前，它会检查其他线程是否还有未扫描完的引用，如果有，则”偷”过来，完成后再申请结束，这个时间是线程之前互相同步所花费的时间。</p><ul><li><p><code>Termination Attempts</code></p><p>工作线程尝试终止的次数，如果实际还有更多的工作要做，那么尝试就会失败，现在终止还为时过早。</p></li></ul></li><li><p><code>GC Worker Other (ms)</code></p><p>花费在其他杂项（不值得在日志中单独占用一个部分）上的时间。</p></li><li><p><code>GC Worker Total (ms)</code></p><p>所用工作线程耗时之和。</p></li><li><p><code>GC Worker End (ms)</code></p><p>每个线程结束的时间戳，通常它们应该大致相等。</p></li></ol></li><li><p><strong>[Code Root Fixup: 0.0 ms]</strong></p><p>用来将code root修正到正确的evacuate之后的对象位置所花费的时间。</p></li><li><p><strong>[Code Root Purge: 0.0 ms]</strong></p><p>清除code root的耗时，code root中的引用已经失效，不再指向Region中的对象，所以需要被清除。</p></li><li><p><strong>[Clear CT: 1.7 ms]</strong></p><p>清除RSet的card table的耗时，这个任务在serial模式下执行。</p></li><li><p><strong>[Other: 7.8 ms]</strong></p><p>下面所列的其他事项共耗时7.8ms：</p><ol><li><p><code>[Choose CSet: 0.0 ms]</code></p><p>查找Collection Set的region的耗时；</p></li><li><p><code>[Ref Proc: 0.6 ms]</code></p><p>Reference Process， 处理引用对象的耗时；</p></li><li><p><code>[Ref Enq: 0.0 ms]</code></p><p>Reference enqueue，引用对象排队到引用队列的耗时；</p></li><li><p><code>[Redirty Cards: 2.5 ms]</code>略</p></li><li><p><code>[Humongous Register: 0.2 ms]</code>略</p></li><li><p><code>[Humongous Reclaim: 0.1 ms]</code>略</p></li><li><p><code>[Free CSet: 3.0 ms]</code></p><p>清理Collection Set数据结构的耗时；</p></li></ol></li><li><p><strong>[Eden: 1124.0M(1124.0M)-&gt;0.0B(1132.0M) Survivors: 104.0M-&gt;96.0M Heap: 10.8G(24.0G)-&gt;9968.2M(24.0G)]</strong></p><p>分别代表：停顿前后Eden区已用内存和容量；停顿前后Survivor区使用的内存；停顿前后整个Heap已用内存和容量。</p></li><li><p><strong>[Times: user=4.64 sys=0.00, real=0.36 secs]</strong></p><p>整个GC事件的持续时间，从以下不同的类别来测量：</p><ol><li><p><strong>user</strong> - 本次垃圾收集中GC线程所消耗的总体CPU时间；</p></li><li><p><strong>sys</strong> - OS调用或等待系统事件的耗时；</p></li><li><p><strong>real</strong> - 应用程序停止的时间（Clock time）。在GC活动可并行执行的情况下，这个数值理想上应为：（user时间 + sys时间）/ GC所用的线程数，在这个case里线程数是13。要注意的是，有些活动不能并行执行，因此该数值总会超过这个比例一定数量。</p></li></ol></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html" target="_blank" rel="noopener">Getting Started with the G1 Garbage Collector</a></p><p><a href="https://blogs.oracle.com/poonam/understanding-g1-gc-logs" target="_blank" rel="noopener">Understanding G1 GC Logs</a></p><p><a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations/g1/evacuation-pause-fully-young" target="_blank" rel="noopener">JAVA GARBAGE COLLECTION HANDBOOK</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;在进行JVM调优时我们经常需要通过日志信息来分析G1GC的性能，本文就日志中可供收集的数据和信息进行了简单介绍。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="G1GC" scheme="http://yoursite.com/tags/G1GC/"/>
    
  </entry>
  
  <entry>
    <title>JDK命令行工具</title>
    <link href="http://yoursite.com/2018/12/13/JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/12/13/JDK命令行工具/</id>
    <published>2018-12-13T02:10:02.308Z</published>
    <updated>2019-01-31T09:11:08.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>前一阵接口服务性能调优的时候，零零星星地用到一些JDK自带的命令行工具。当服务部署到生产环境时，有一些性能诊断工具因为环境原因可能会受到限制，但是通过使用这些JDK自带的监控工具，我问可以直接在应用程序中实现强大的监控分析功能。这些工具在<strong>《深入理解Java虚拟机》</strong>和<strong>《Java性能权威指南》</strong>中都有系统性的介绍，本文也权当是一篇学习笔记，顺便对之前调优过程中的使用做一下梳理。</p><a id="more"></a><h2 id="常用的JDK命令行工具"><a href="#常用的JDK命令行工具" class="headerlink" title="常用的JDK命令行工具"></a>常用的JDK命令行工具</h2><table><thead><tr><th style="text-align:left">请求ID</th><th style="text-align:left">主要作用</th></tr></thead><tbody><tr><td style="text-align:left">jps</td><td style="text-align:left">JVM Process Status Tool，显示指定系统内所有的HotSpot虚拟机进程</td></tr><tr><td style="text-align:left">jstat</td><td style="text-align:left">JVM Statistics Monitoring Tool，用于收集Hotspot虚拟机各方面的运行数据</td></tr><tr><td style="text-align:left">jinfo</td><td style="text-align:left">Configuration Info for Java，显示虚拟机配置信息</td></tr><tr><td style="text-align:left">jmap</td><td style="text-align:left">JVM Memory Map，生成虚拟机的内存转储快照，生成heapdump文件</td></tr><tr><td style="text-align:left">jhat</td><td style="text-align:left">JVM Heap Dump Browser，用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户在浏览器上查看分析结果</td></tr><tr><td style="text-align:left">jstack</td><td style="text-align:left">JVM Stack Trace，显示虚拟机的线程快照</td></tr><tr><td style="text-align:left">jcmd</td><td style="text-align:left">打印Java进程所涉及的基本类、线程和VM信息</td></tr><tr><td style="text-align:left">jconsole</td><td style="text-align:left">提供JVM活动的图形化视图，包括线程的使用、类的使用和GC活动</td></tr><tr><td style="text-align:left">jvisualvm</td><td style="text-align:left">监控JVM的GUI工具，可用来剖析运行的应用，分析JVM堆转储</td></tr></tbody></table><p>这些工具可以广泛用于以下领域：</p><ul><li>基本的VM信息</li><li>线程信息</li><li>类信息</li><li>实时GC分析</li><li>堆转储的事后处理</li><li>JVM的性能分析</li></ul><h2 id="常用命令介绍"><a href="#常用命令介绍" class="headerlink" title="常用命令介绍"></a>常用命令介绍</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p><strong>命令格式</strong>：</p><p><code>jps [ options ] [ hostid ]</code></p><p><strong>options</strong>：</p><p><code>-q</code> 只输出本地虚拟机进程ID，省略主类名 </p><p><code>-m</code> 输出虚拟机进程启动时传递给main()函数的参数</p><p><code>-l</code> 输出进程执行的主类的全名 </p><p><code>-v</code> 输出虚拟机进程启动时的JVM参数 </p><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p><strong>命令格式</strong>：</p><p><code>jstat [ option vmid [interval[s|ms] [count]] ]</code></p><p><strong>options</strong>：</p><p><code>-class</code>监视类装载，卸载数量，总空间以及类装载所耗费的时间</p><p><code>-gc</code> 监视Java堆状况，包括Eden区，两个survivor区，老年代，永久代的容量，已用空间，GC时间合计等信息</p><p><code>-gccapacity</code> 内容与-gc基本相同，但主要输出Java堆各个区域的最大最小空间</p><p><code>-gcutil</code> 内容与-gc基本相同，但主要关注已使用空间占总空间的百分比</p><p><code>-gccause</code> 内容与-gcutil基本相同，但主要关注已使用空间占总空间的百分比,并输出导致上一次GC的原因</p><p><code>-gcnew</code> 监视新生代GC情况</p><p><code>-gcnewcapacity</code> 内容与-gcnew基本相同，但主要输出使用到的最大最小空间</p><p><code>-gcold</code> 监视老年代GC情况</p><p><code>-gcoldcapacity</code> 内容与-gcnew基本相同，但主要输出使用到的最大最小空间</p><p><code>-gcpermcapacity</code> 输出永久代使用到的最大最小空间</p><p><code>-complier</code> 输出JIT 编译器编译过的方法耗时的信息</p><p><code>-printcompliter</code> 输出已经被JIT编译的方法</p><h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p><strong>命令格式</strong>：</p><p><code>jinfo [ option ] pid</code></p><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p><strong>命令格式</strong>：</p><p><code>jinfo [ option ] vmid</code></p><p><strong>options</strong>：</p><p><code>-dump</code> 生成Java堆转储快照，格式为： -dump:[live , ]format=b , file=,其中live子参数 说明只dump出存活的对象</p><p><code>-finalizerinfo</code> 显示在F-Queue中等待Finalizer线程执行finalize方法的对象</p><p><code>-heap</code> 显示Java堆详细信息，如使用哪种回收器，参数配置，分代状况等 </p><h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p><strong>命令格式</strong>：</p><p><code>jhat heapdumpFileName</code></p><h3 id="jatack"><a href="#jatack" class="headerlink" title="jatack"></a>jatack</h3><p><strong>命令格式</strong>：</p><p><code>jstack [ option ] vmid</code></p><p><strong>options</strong>：</p><p><code>-F</code> 当正常输出的请求不被响应时，强制输出线程堆栈</p><p><code>-l</code> 除堆栈外，显示关于锁的附加信息</p><p><code>-m</code> 如果调用到本地方法的话，可以显示C/C++的堆栈</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;前一阵接口服务性能调优的时候，零零星星地用到一些JDK自带的命令行工具。当服务部署到生产环境时，有一些性能诊断工具因为环境原因可能会受到限制，但是通过使用这些JDK自带的监控工具，我问可以直接在应用程序中实现强大的监控分析功能。这些工具在&lt;strong&gt;《深入理解Java虚拟机》&lt;/strong&gt;和&lt;strong&gt;《Java性能权威指南》&lt;/strong&gt;中都有系统性的介绍，本文也权当是一篇学习笔记，顺便对之前调优过程中的使用做一下梳理。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>线上服务CPU负载高问题排查（一）</title>
    <link href="http://yoursite.com/2018/12/06/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1CPU%E8%B4%9F%E8%BD%BD%E9%AB%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/12/06/线上服务CPU负载高问题排查（一）/</id>
    <published>2018-12-06T05:49:15.410Z</published>
    <updated>2019-03-25T06:37:16.984Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>使用Arthas定位CPU占用率过高的问题，</p><p>挖坑待填…</p><a id="more"></a><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p><img src="https://i.loli.net/2018/12/06/5c08d11e024ef.png" alt="top.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;使用Arthas定位CPU占用率过高的问题，&lt;/p&gt;
&lt;p&gt;挖坑待填…&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>线上服务CPU负载高问题排查（二）</title>
    <link href="http://yoursite.com/2018/12/06/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1CPU%E8%B4%9F%E8%BD%BD%E9%AB%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/12/06/线上服务CPU负载高问题排查（二）/</id>
    <published>2018-12-06T05:49:15.410Z</published>
    <updated>2019-03-25T08:29:53.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在进行接口服务优化，前面对处理大量数据的线程进行了优化，具体见：<a href="https://f8f-1bearcat.github.io/2018/12/06/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1CPU%E8%B4%9F%E8%BD%BD%E9%AB%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">线上服务CPU负载高问题排查（一）</a> 。当优化后的版本部署到灰度服务器上时，原以为CPU占用率会明显地降低，然而事实却狠狠地打了脸，非但该服务的CPU占用及负载没有降低，反而远远差于上次优化之前版本及线上的服务。是优化方向错了，还是引入了新的问题？<br><a id="more"></a></p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>通过运维中心<code>zabbix</code>面板查看该机房上所有的报价服务负载情况，新部署接口服务的负载情况如下图红线所示：<br><img src="https://i.loli.net/2018/12/06/5c08d1299cb5d.png" alt="load_before.png"><br>可以发现在上午11:00~14:00时间段内，该接口服务的负载明显高于其他几台服务。CPU利用率的情况与负载类似。</p><h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><h3 id="一、比较用户数量"><a href="#一、比较用户数量" class="headerlink" title="一、比较用户数量"></a>一、比较用户数量</h3><p>5个服务都部署在SZVPC机房，并且可以确定服务运行环境是相同的，那么首先需要确认是否是该服务用户量过大导致的。</p><p>登录CRT，通过<code>netstat -antp|grep &#39;port&#39;|wc -l</code>命令查看服务器上的实时用户连接数。对比该机房的5个报价服务发现，所有服务的实时用户连接数大体相等，不存在优化版本服务用户连接远大于其他几台服务的情况。到这里可以得出结论是新部署的服务本身有问题。</p><h3 id="二、定位高CPU占用线程"><a href="#二、定位高CPU占用线程" class="headerlink" title="二、定位高CPU占用线程"></a>二、定位高CPU占用线程</h3><p>1、在上一篇的CPU高负载排查过程中，我们定位到是组合和账户的数据处理线程CPU占用率高。那首先，可以确定下上次优化有没有解决这两个线程的CPU占用问题。</p><p>通过Arthas进入到当前服务进程，执行<code>thread -n 5 -i 1000</code>命令来查看当前CPU占用最高的几个线程。分析堆栈信息，可以看到改完之后的服务组合账户线程的CPU占用率已经降低了，至少前5个线程里面不见他们的踪影。</p><p><img src="https://i.loli.net/2018/12/13/5c11f7ed83ec2.png" alt="thread5.png"></p><p>2、排除了组合账户线程的影响，下一步就要定位到底是什么线程占用CPU最高。通过<code>$ top</code>命令，查看CPU实时使用情况（注：图为后面补加的，数据可能有出入）：<br><img src="https://i.loli.net/2018/12/07/5c09d1aa96940.png" alt="top_load.png"><br>可以看出pid为26810的进程CPU占用率竟然达到了1000%，而这个进程就是接口服务的进程。</p><p>3、经典的命令行工具，如<em>ps</em>或<em>top</em>，都可以用来显示线程级别的信息，下面列举了这两种方法的使用。</p><p>方法一：通过<code>$ ps -mp &lt;pid&gt; -o tid,THREAD,time</code>命令，查看线程列表。到这里确认tid为8592…的这三个线程CPU占用率最高，且占用CPU的时间也很长。</p><p><img src="https://i.loli.net/2018/12/07/5c09de2a7f8c5.png" alt="thread.png"></p><p>方法二：通过<code>$ top -H -p &lt;pid&gt;</code>命令，查看线程列表，得出的结论与方法一一致。</p><p>​            <img src="https://i.loli.net/2018/12/07/5c09de2511265.png" alt="top_thread.png"></p><p>4、定位到线程tid之后，就可以用<code>jstack</code>命令查看线程具体的堆栈信息了，不过<code>jstack</code>命令中线程id使用16进制，因而首先需要通过 <code>$ echo &quot;obase=16;&lt;tid&gt;&quot;|bc</code>或 <code>$ printf &quot;%x\n&quot; &lt;tid&gt;</code>命令将tid转为16进制。</p><p><img src="https://i.loli.net/2018/12/07/5c09de1cb3c4b.png" alt="16.png"></p><p>以tid8592为例，转为16进制后为2190，再通过<code>$ jstack &lt;pid&gt; |grep &lt;tid&gt; -C 20</code>命令查看该线程的堆栈信息。</p><p><img src="https://i.loli.net/2018/12/07/5c09de3041b0a.png" alt="thread_stack.png"></p><h3 id="三、分析"><a href="#三、分析" class="headerlink" title="三、分析"></a>三、分析</h3><p>Gang worker是JVM 用于做新生代垃圾回收（monir gc）的一个线程，#号后面是线程编号。从线程的堆栈信息可以看出是JVM的GC线程一直在占用大量CPU.定位到垃圾收集器的问题，可以通过<code>jstat -gcutil &lt;pid&gt; 1000 100</code>命令统计GC回收的情况（没发现有什么异常）。</p><p><img src="https://i.loli.net/2018/12/13/5c11f7d2e9c4d.png" alt="gcutil.png"></p><p>对应的参数如下：</p><ul><li><strong>S0：</strong>幸存1区当前使用比例</li><li><strong>S1：</strong>幸存2区当前使用比例</li><li><strong>E：</strong>伊甸园区使用比例</li><li><strong>O：</strong>老年代使用比例</li><li><strong>M：</strong>元数据区使用比例</li><li><strong>CCS：</strong>压缩使用比例</li><li><strong>YGC：</strong>年轻代垃圾回收次数</li><li><strong>FGC：</strong>老年代垃圾回收次数</li><li><strong>FGCT：</strong>老年代垃圾回收消耗时间</li><li><strong>GCT：</strong>垃圾回收消耗总时间</li></ul><p>通过<code>jinfo -flags &lt;pid&gt;</code>命令，查看该服务器上的JVM内存参数设置，看到了这一条配置：<code>-Xmx12g -XX:MaxDirectMemorySize=18g</code>，原来之前的服务版本中已经不使用直接内存，而是全都使用堆内存，而这里JVM配置却没有改过来，由此推测是服务的内存分配不够用导致频繁GC，进而引起CPU负载过高。</p><p><img src="https://i.loli.net/2018/12/13/5c11f7f40440c.png" alt="jinfo.png"></p><h3 id="四、后续"><a href="#四、后续" class="headerlink" title="四、后续"></a>四、后续</h3><p>修改JVM的配置，将最大堆内存设置为<code>-Xmx=24g</code>，重启服务运行一段时候后发现CPU负载迅速降了下来，并一直低于线上服务的负载。</p><p><img src="https://i.loli.net/2018/12/06/5c08d1312b7aa.png" alt="load_after.png"></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>1 有关JVM调优相关的可以参考这一系列博客，写的很详尽：<a href="https://www.cnblogs.com/wyb628/p/8566337.html" target="_blank" rel="noopener">Java内存泄露分析系列</a>。</p><p>2 这次问题解决也是凑巧去看了一眼JVM参数，本身GC回收具体什么地方占用了CPU，迫于时间关系实际上没有准确定位到，后面再研究吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在进行接口服务优化，前面对处理大量数据的线程进行了优化，具体见：&lt;a href=&quot;https://f8f-1bearcat.github.io/2018/12/06/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1CPU%E8%B4%9F%E8%BD%BD%E9%AB%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%EF%BC%88%E4%B8%80%EF%BC%89/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;线上服务CPU负载高问题排查（一）&lt;/a&gt; 。当优化后的版本部署到灰度服务器上时，原以为CPU占用率会明显地降低，然而事实却狠狠地打了脸，非但该服务的CPU占用及负载没有降低，反而远远差于上次优化之前版本及线上的服务。是优化方向错了，还是引入了新的问题？&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Netty源码之writeAndFlush()流程与异步</title>
    <link href="http://yoursite.com/2018/12/06/Netty%E6%BA%90%E7%A0%81%E4%B9%8BwriteAndFlush()%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%BC%82%E6%AD%A5/"/>
    <id>http://yoursite.com/2018/12/06/Netty源码之writeAndFlush()流程与异步/</id>
    <published>2018-12-06T01:14:11.376Z</published>
    <updated>2019-03-25T06:36:30.985Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf21c6726a92.png" alt="netty.png"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>挖坑待填…</p><p>本文旨在对Netty中writeAndFlush()方法的线程安全及并发问题简单谈下自己的理解，同时对channel.writeAndFlush()和ctx.writeAndFlush()两个方法通过阅读源码进行比较。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf21c6726a92.png&quot; alt=&quot;netty.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;挖坑待填…&lt;/p&gt;
&lt;p&gt;本文旨在对Netty中writeAndFlush()方法的线程安全及并发问题简单谈下自己的理解，同时对channel.writeAndFlush()和ctx.writeAndFlush()两个方法通过阅读源码进行比较。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Linux之sed用法</title>
    <link href="http://yoursite.com/2018/12/05/Linux%E4%B9%8Bsed%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2018/12/05/Linux之sed用法/</id>
    <published>2018-12-05T01:33:22.380Z</published>
    <updated>2019-02-01T06:16:32.856Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/02/01/5c53e438b7367.png" alt="Linux.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Linux sed命令是利用script来处理、编辑文本文件。</p><a id="more"></a><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>sed [OPTION]... {script-only-if-no-other-script} [input-file]...</code></p><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li>-n, –quiet, –silent<br>​                 suppress automatic printing of pattern space</li><li>-e script, –expression=script<br> ​                 add the script to the commands to be executed</li><li><p>-f script-file, –file=script-file<br> ​                 add the contents of script-file to the commands to be executed</p><p> –follow-symlinks<br>​                 follow symlinks when processing in place; hard links<br>​                 will still be broken.</p></li><li>-i[SUFFIX], –in-place[=SUFFIX]<br> ​                 edit files in place (makes backup if extension supplied).<br> ​                 The default operation mode is to break symbolic and hard links.<br> ​                 This can be changed with –follow-symlinks and –copy.</li><li>-c, –copy<br>​                 use copy instead of rename when shuffling files in -i mode.<br>​                 While this will avoid breaking links (symbolic or hard), the<br>​                 resulting editing operation is not atomic.  This is rarely<br>​                 the desired mode; –follow-symlinks is usually enough, and<br>​                 it is both faster and more secure.</li><li>-l N, –line-length=N<br>​                 specify the desired line-wrap length for the `l’ command<br>  –posix<br>​                 disable all GNU extensions.</li><li>-r, –regexp-extended<br>​                 use extended regular expressions in the script.</li><li>-s, –separate<br>​                 consider files as separate rather than as a single continuous<br>​                 long stream.</li><li>-u, –unbuffered<br>​                 load minimal amounts of data from the input files and flush<br>​                 the output buffers more often</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>查看某段时间的服务日志：<code>sed -n &#39;/1970-01-01 01:01/,$p&#39; 1.log |more</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/02/01/5c53e438b7367.png&quot; alt=&quot;Linux.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Linux sed命令是利用script来处理、编辑文本文件。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>浅谈OGNL表达式</title>
    <link href="http://yoursite.com/2018/11/30/%E6%B5%85%E8%B0%88OGNL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/11/30/浅谈OGNL表达式/</id>
    <published>2018-11-30T02:29:36.063Z</published>
    <updated>2018-11-30T02:33:36.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>挖坑…</p><p>OGNL特殊用法请参考：<a href="https://github.com/alibaba/arthas/issues/71" target="_blank" rel="noopener">https://github.com/alibaba/arthas/issues/71</a><br>OGNL表达式官方指南：<a href="https://commons.apache.org/proper/commons-ognl/language-guide.html" target="_blank" rel="noopener">https://commons.apache.org/proper/commons-ognl/language-guide.html</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;挖坑…&lt;/p&gt;
&lt;p&gt;OGNL特殊用法请参考：&lt;a href=&quot;https://github.com/alibaba/arthas/issues/71&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/alibaba/arthas/issues/71&lt;/a&gt;&lt;br&gt;OGNL表达式官方指南：&lt;a href=&quot;https://commons.apache.org/proper/commons-ognl/language-guide.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://commons.apache.org/proper/commons-ognl/language-guide.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="OGNL" scheme="http://yoursite.com/tags/OGNL/"/>
    
  </entry>
  
  <entry>
    <title>Logback以及Log4j2性能测试对比</title>
    <link href="http://yoursite.com/2018/11/28/Logback%E4%BB%A5%E5%8F%8ALog4j2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2018/11/28/Logback以及Log4j2性能测试对比/</id>
    <published>2018-11-28T01:06:32.907Z</published>
    <updated>2019-03-25T08:24:06.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>挖坑待填…</p><p>在进行RPC服务调优时，我们往往下意识地会从框架、JVM、业务代码等方向思考，但却往往会忽略线上服务日志打印对服务性能的影响。实际上，在某些情况下，选取合适的日志框架、有效的日志打印策略，将会给服务带来很大的性能提升。本文将尝试对常用的日志框架进行对比分析，从而服务于我们的服务性能调优工作。</p><a id="more"></a><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;挖坑待填…&lt;/p&gt;
&lt;p&gt;在进行RPC服务调优时，我们往往下意识地会从框架、JVM、业务代码等方向思考，但却往往会忽略线上服务日志打印对服务性能的影响。实际上，在某些情况下，选取合适的日志框架、有效的日志打印策略，将会给服务带来很大的性能提升。本文将尝试对常用的日志框架进行对比分析，从而服务于我们的服务性能调优工作。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Logback" scheme="http://yoursite.com/tags/Logback/"/>
    
      <category term="Log4j2" scheme="http://yoursite.com/tags/Log4j2/"/>
    
  </entry>
  
  <entry>
    <title>quartz定时任务时间设置</title>
    <link href="http://yoursite.com/2018/11/28/quartz%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/11/28/quartz定时任务时间设置/</id>
    <published>2018-11-28T01:03:26.828Z</published>
    <updated>2019-02-01T06:06:56.366Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/02/01/5c53b7b438ba0.png" alt="quartz.png"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>Quartz 是一个完全由 Java 编写的开源作业调度框架，为在 Java 应用程序中进行作业调度提供了简单却强大的机制。项目中的定时任务有使用到Quartz，这里就简单记录下其有关概念以及时间设置，方便记忆及以后查看。</p><a id="more"></a><h2 id="Quartz-的核心概念"><a href="#Quartz-的核心概念" class="headerlink" title="Quartz 的核心概念"></a>Quartz 的核心概念</h2><p><strong>Job</strong> 表示一个工作，要执行的具体内容。此接口中只有一个方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span></span></span><br></pre></td></tr></table></figure><p><strong>JobDetail</strong> 表示一个具体的可执行的调度程序，Job 是这个可执行程调度程序所要执行的内容，另外 JobDetail 还包含了这个任务调度的方案和策略。 </p><p><strong>Trigger</strong> 代表一个调度参数的配置，什么时候去调。</p><p><strong>Scheduler</strong> 代表一个调度容器，一个调度容器中可以注册多个 JobDetail 和 Trigger。当 Trigger 与 JobDetail 组合，就可以被 Scheduler 容器调度了。</p><h2 id="定时任务时间设置"><a href="#定时任务时间设置" class="headerlink" title="定时任务时间设置"></a>定时任务时间设置</h2><p><strong>时间格式:</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">星号： * * * * * * * </span><br><span class="line">格式： 秒 分 时 日 月 周 年</span><br></pre></td></tr></table></figure><table><thead><tr><th>时间域名</th><th style="text-align:center">允许填写的值</th><th style="text-align:center">允许的通配符</th><th>是否必填</th></tr></thead><tbody><tr><td>秒</td><td style="text-align:center">0-59</td><td style="text-align:center">, - * /</td><td>是</td></tr><tr><td>分</td><td style="text-align:center">0-59</td><td style="text-align:center">, - * /</td><td>是</td></tr><tr><td>时</td><td style="text-align:center">0-23</td><td style="text-align:center">, - * /</td><td>是</td></tr><tr><td>周</td><td style="text-align:center">1-31</td><td style="text-align:center">, - * ? / L W</td><td>是</td></tr><tr><td>月</td><td style="text-align:center">1-12 or JAN-DEC</td><td style="text-align:center">, - * /</td><td></td></tr><tr><td>周</td><td style="text-align:center">1-7 or SUN-SAT</td><td style="text-align:center">, - * ? / L  #</td><td>是</td></tr><tr><td>年</td><td style="text-align:center">1970-2099</td><td style="text-align:center">, - * /</td><td>否</td></tr></tbody></table><p><strong>通配符说明</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'*'</span> 表示所有值。例如:在分的字段上设置<span class="string">'*'</span>,表示每一分钟都会触发。</span><br><span class="line"></span><br><span class="line"><span class="string">'?'</span> 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的<span class="number">10</span>号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为<span class="string">'?'</span>具体设置为<span class="string">'00010*?'</span>。</span><br><span class="line"></span><br><span class="line"><span class="string">'-'</span> 表示区间。例如 在小时上设置<span class="string">'10-12'</span>,表示<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>点都会触发。<span class="string">','</span>表示指定多个值，例如在周字段上设置<span class="string">'MON,WED,FRI'</span>表示周一，周三和周五触发。</span><br><span class="line"></span><br><span class="line"><span class="string">'/'</span> 用于递增触发。如在秒上面设置<span class="string">'5/15'</span>表示从<span class="number">5</span>秒开始，每增<span class="number">15</span>秒触发(<span class="number">5</span>,<span class="number">20</span>,<span class="number">35</span>,<span class="number">50</span>)。在月字段上设置<span class="string">'1/3'</span>所示每月<span class="number">1</span>号开始，每隔三天触发一次。</span><br><span class="line"></span><br><span class="line"><span class="string">'L'</span> 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于<span class="string">'7'</span>或<span class="string">'SAT'</span>。如果在<span class="string">'L'</span>前加上数字，则表示该数据的最后一个。例如在周字段上设置<span class="string">'6L'</span>这样的格式,则表示<span class="string">"本月最后一个星期五"</span>。</span><br><span class="line"></span><br><span class="line"><span class="string">'W'</span> 表示离指定日期的最近那个工作日(周一至周五)。例如在日字段上设置<span class="string">'15W'</span>，表示离每月<span class="number">15</span>号最近的那个工作日触发。如果<span class="number">15</span>号正好是周六，则找最近的周五(<span class="number">14</span>号)触发, 如果<span class="number">15</span>号是周未，则找最近的下周一(<span class="number">16</span>号)触发.如果<span class="number">15</span>号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 <span class="string">'1W'</span>,它则表示每月<span class="number">1</span>号往后最近的工作日触发。如果<span class="number">1</span>号正是周六，则将在<span class="number">3</span>号下周一触发。(注，<span class="string">'W'</span>前只能设置具体的数字,不允许区间<span class="string">"-"</span>)。</span><br><span class="line"></span><br><span class="line"><span class="string">'L'</span>和<span class="string">'W'</span>可以一组合使用。如果在日字段上设置<span class="string">'LW'</span>,则表示在本月的最后一个工作日触发(一般指发工资 )序号(表示每月的第几个周几)，例如在周字段上设置<span class="string">'6#3'</span>表示在每月的第三个周六.注意如果指定<span class="string">'#5'</span>,正好第五周没有周六，则不会触发该配置(用在母亲节和父亲节再合适不过了)。</span><br><span class="line"></span><br><span class="line">周字段的设置，若使用英文字母是不区分大小写的，<span class="string">'MON'</span>与<span class="string">'mon'</span>相同。</span><br></pre></td></tr></table></figure><p><strong>常用示例</strong>：</p><p><code>0 0 12 * * ?</code> 每天12点触发<br><code>0 15 10 ? * *</code> 每天10点15分触发<br><code>0 15 10 * * ?</code> 每天10点15分触发<br><code>0 15 10 * * ? *</code> 每天10点15分触发<br><code>0 15 10 * * ? 2005</code> 2005年每天10点15分触发<br><code>0 * 14 * * ?</code> 每天下午的 2点到2点59分每分触发<br><code>0 0/5 14 * * ?</code> 每天下午的 2点到2点59分(整点开始，每隔5分触发)<br><code>0 0/5 14,18 * * ?</code> 每天下午的 18点到18点59分(整点开始，每隔5分触发)<br><code>0 0-5 14 * * ?</code> 每天下午的 2点到2点05分每分触发<br><code>0 10,44 14 ? 3 WED</code>     3月分每周三下午的 2点10分和2点44分触发 （特殊情况，在一个时间设置里，执行两次或两次以上的情况）<br><code>0 59 2 ? * FRI</code>    每周5凌晨2点59分触发；<br><code>0 15 10 ? * MON-FRI</code> 从周一到周五每天上午的10点15分触发<br><code>0 15 10 15 * ?</code> 每月15号上午10点15分触发<br><code>0 15 10 L * ?</code> 每月最后一天的10点15分触发<br><code>0 15 10 ? * 6L</code> 每月最后一周的星期五的10点15分触发<br><code>0 15 10 ? * 6L 2002-2005</code> 从2002年到2005年每月最后一周的星期五的10点15分触发<br><code>0 15 10 ? * 6#3</code> 每月的第三周的星期五开始触发<br><code>0 0 12 1/5 * ?</code> 每月的第一个中午开始每隔5天触发一次<br><code>0 11 11 11 11 ?</code> 每年的11月11号 11点11分触发(光棍节)</p><p>官方文档：<a href="http://www.quartz-scheduler.org/documentation/quartz-2.2.x/quick-start.html" target="_blank" rel="noopener">http://www.quartz-scheduler.org/documentation/quartz-2.2.x/quick-start.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/02/01/5c53b7b438ba0.png&quot; alt=&quot;quartz.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;Quartz 是一个完全由 Java 编写的开源作业调度框架，为在 Java 应用程序中进行作业调度提供了简单却强大的机制。项目中的定时任务有使用到Quartz，这里就简单记录下其有关概念以及时间设置，方便记忆及以后查看。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Quartz任务调度" scheme="http://yoursite.com/tags/Quartz%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>介绍一款开源Java诊断工具—Arthas</title>
    <link href="http://yoursite.com/2018/11/19/Arthas%E2%80%94%E5%BC%80%E6%BA%90Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/11/19/Arthas—开源Java诊断工具/</id>
    <published>2018-11-19T06:48:50.651Z</published>
    <updated>2019-01-28T08:43:18.477Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf2661ea96ae.png" alt="arthas.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Arthas（阿尔萨斯）是阿里巴巴开源的 Java 诊断工具，深受开发者喜爱。</p><p>当你遇到以下类似问题而束手无策时，Arthas 可以帮助你解决：</p><pre><code>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！是否有一个全局视角来查看系统的运行状况？有什么办法可以监控到JVM的实时运行状态？</code></pre><p>Arthas 采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。</p><a id="more"></a><h2 id="常用命令示例"><a href="#常用命令示例" class="headerlink" title="常用命令示例"></a>常用命令示例</h2><ul><li>实时显示当前服务的线程、JVM等信息：</li></ul><p><code>dashboard</code></p><ul><li>在指定采样时间间隔<code>i</code>内展示当前最忙的前<code>n</code>个线程并打印堆栈：</li></ul><p><code>thread -n 10 -i 1000</code></p><ul><li>展示方法内部调用路径，并输出方法路径上的每个节点上耗时，跟据调用耗时过滤：</li></ul><p><code>trace [class-pattern] [method-pattern] #cost&gt;100</code></p><ul><li>方法执行数据观测：</li></ul><p><code>watch [class-pattern] [method-pattern] returnObj</code><br><code>watch [class-pattern] getInstance &quot;returnObj.getReqList().size()&quot;</code></p><ul><li>反编译指定已加载类的源码：</li></ul><p><code>jad [class-pattern]</code></p><ul><li>打印出类的Field信息：</li></ul><p><code>sc -df io.netty.util.internal.PlatformDependent</code></p><p>安装和更多命令列表参见官方文档：<a href="https://alibaba.github.io/arthas/index.html" target="_blank" rel="noopener">Arthas 用户文档 — Arthas 3.0.5-SNAPSHOT 文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf2661ea96ae.png&quot; alt=&quot;arthas.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Arthas（阿尔萨斯）是阿里巴巴开源的 Java 诊断工具，深受开发者喜爱。&lt;/p&gt;
&lt;p&gt;当你遇到以下类似问题而束手无策时，Arthas 可以帮助你解决：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？

我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？

遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？

线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！

是否有一个全局视角来查看系统的运行状况？

有什么办法可以监控到JVM的实时运行状态？
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Arthas 采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="开发工具" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
      <category term="alibaba" scheme="http://yoursite.com/tags/alibaba/"/>
    
  </entry>
  
  <entry>
    <title>Netty引用计数对象</title>
    <link href="http://yoursite.com/2018/11/19/Netty%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/11/19/Netty引用计数对象/</id>
    <published>2018-11-19T05:42:35.208Z</published>
    <updated>2019-03-25T06:42:42.747Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf21c6726a92.png" alt="netty.png"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>挖坑待填…</p><p>之前项目中怼Netty的高性能编程进行了实践，其中Netty 的接收和发送 ByteBuffer有用到堆外内存 DIRECT BUFFERS。使用堆外直接内存进行 Socket 读写，好处是不需要进行字节缓冲区的二次拷贝，实现了Netty的零拷贝。但是堆外内存不能被GC回收，必须遵循“谁分配，谁释放”的原则，在使用堆外内存后如果没有及时的释放，则很有可能导致OOM问题，具体可以参考这篇文章：<a href="https://f8f-1bearcat.github.io/2018/11/16/Netty%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/#more" target="_blank" rel="noopener">Netty直接内存泄露</a>；而如果对堆外内存进行了重复释放，服务则会抛出Netty引用计数异常问题。</p><p>本文旨在结合源码，对Netty的引用计数对象进行简析。</p><a id="more"></a><p>官方文档：<a href="https://netty.io/wiki/reference-counted-objects.html" target="_blank" rel="noopener">https://netty.io/wiki/reference-counted-objects.html</a></p><p>文档翻译：<a href="https://damacheng009.iteye.com/blog/2013657" target="_blank" rel="noopener">https://damacheng009.iteye.com/blog/2013657</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf21c6726a92.png&quot; alt=&quot;netty.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;挖坑待填…&lt;/p&gt;
&lt;p&gt;之前项目中怼Netty的高性能编程进行了实践，其中Netty 的接收和发送 ByteBuffer有用到堆外内存 DIRECT BUFFERS。使用堆外直接内存进行 Socket 读写，好处是不需要进行字节缓冲区的二次拷贝，实现了Netty的零拷贝。但是堆外内存不能被GC回收，必须遵循“谁分配，谁释放”的原则，在使用堆外内存后如果没有及时的释放，则很有可能导致OOM问题，具体可以参考这篇文章：&lt;a href=&quot;https://f8f-1bearcat.github.io/2018/11/16/Netty%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/#more&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Netty直接内存泄露&lt;/a&gt;；而如果对堆外内存进行了重复释放，服务则会抛出Netty引用计数异常问题。&lt;/p&gt;
&lt;p&gt;本文旨在结合源码，对Netty的引用计数对象进行简析。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>线上服务性能调优：RPC可靠性设计</title>
    <link href="http://yoursite.com/2018/11/16/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%EF%BC%9ARPC%E5%8F%AF%E9%9D%A0%E6%80%A7%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2018/11/16/线上服务性能调优：RPC可靠性设计/</id>
    <published>2018-11-16T09:04:30.994Z</published>
    <updated>2019-03-25T09:09:32.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>挖坑待填…</p><p>本文以《Netty权威指南（第二版）》第23章<strong>可靠性</strong>为基础，结合实际项目中的应用，实现RPC框架的可靠性设计。</p><a id="more"></a><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="RPC-框架的可靠性设计"><a href="#RPC-框架的可靠性设计" class="headerlink" title="RPC 框架的可靠性设计"></a>RPC 框架的可靠性设计</h3><h4 id="1-故障"><a href="#1-故障" class="headerlink" title="1. 故障"></a>1. 故障</h4><p>1.1 分布式调用引入的故障<br>​    1．消息的序列化和反序列化故障，例如，不支持的数据类型。<br>​    2．路由故障：包括服务的订阅、发布故障，服务实例故障之后没有及时刷新路由表，导致 RPC 调用仍然路由到故障节点。<br>​    3．网络通信故障，包括网络闪断、网络单通、丢包、客户端浪涌接入等。<br>1.2 第三方服务依赖<br>数据库服务、文件存储服务、缓存服务、消息队列服务<br>​    1．网络通信类故障, 如果采用 BIO 调用第三方服务，很有可能被阻塞。<br>​    2．“雪崩效用”导致的级联故障，例如服务端处理慢导致客户端线程被阻塞。<br>​    3．第三方不可用导致 RPC 调用失败。</p><h4 id="2-通信层的可靠性设计"><a href="#2-通信层的可靠性设计" class="headerlink" title="2. 通信层的可靠性设计"></a>2. 通信层的可靠性设计</h4><p>2.1 链路有效性检测<br>​    心跳检测机制分为三个层面：<br>​        1.TCP 层面的心跳检测，即 TCP 的 Keep-Alive 机制，它的作用域是整个 TCP 协议栈。<br>​        2. 协议层的心跳检测，主要存在于长连接协议中。例如 MQTT 协议。<br>​        3. 应用层的心跳检测，它主要由各业务产品通过约定方式定时给对方发送心跳消息实现。<br>​    心跳检测策略如下：<br>​        1．连续 N 次心跳检测都没有收到对方的 Pong 应答消息或者 Ping 请求消息，则认为链路已经发生逻辑失效，这被称作心跳超时。<br>​        2．读取和发送心跳消息的时候如何直接发生了 IO 异常，说明链路已经失效，这被称为心跳失败。​<br>  2.2 客户端断连重连<br>  ​    1．服务端因为某种原因，主动关闭连接，客户端检测到链路被正常关闭。<br>  ​    2．服务端因为宕机等故障，强制关闭连接，客户端检测到链路被 Rest 掉。<br>  ​    3．心跳检测超时，客户端主动关闭连接。<br>  ​    4．客户端因为其它原因（例如解码失败），强制关闭连接。<br>  ​    5．网络类故障，例如网络丢包、超时、单通等，导致链路中断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public int checkHealth() &#123;&#125;</span><br></pre></td></tr></table></figure><p>  2.3 缓存重发<br>  ​    消息队列中积压了部分消息，此时链路中断，这会导致部分消息并没有真正发送给通信对端<br>  ​        1．调用 Netty ChannelHandlerContext 的 write 方法时，返回 ChannelFuture 对象，我们在 ChannelFuture 中注册发送结果监听 Listener。<br>  ​        2．在 Listener 的 operationComplete 方法中判断操作结果，如果操作不成功，将之前发送的消息对象添加到重发队列中。<br>  ​        3．链路重连成功之后，根据策略，将缓存队列中的消息重新发送给通信对端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最终写入数据</span></span><br><span class="line">channel.writeAndFlush(byteBuf).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">         <span class="keyword">if</span> ((!dataQueue.isEmpty()) &amp;&amp; channel.isWritable() &amp;&amp; (!isWriting())) &#123;</span><br><span class="line">              dataProcessor();</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">               <span class="comment">//缓存重发</span></span><br><span class="line">  &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>  2.4 客户端超时保护</p><ol><li><p>在同步阻塞 I/O 模型中，连接操作是同步阻塞的，如果不设置超时时间，客户端 I/O 线程可能会被长时间阻塞，这会导致系统可用 I/O 线程数的减少。<br>  ​    2. 业务层需要：大多数系统都会对业务流程执行时间有限制，例如 WEB 交互类的响应时间要小于 3S。客户端设置连接超时时间是为了实现业务层的超时。<br>  ​<br>  2.5 针对客户端的并发连接数流控<br>  ​    检查登录次数<br>  ​    目前简单判断一段时间内不允许再登录<br>  2.6 内存保护<br>  ​    1. 链路总数的控制：每条链路都包含接收和发送缓冲区，链路个数太多容易导致内存溢出。<br>  ​    2. 单个缓冲区的上限控制：防止非法长度或者消息过大导致内存溢出。<br>  ​        缓冲区的创建方式通常有两种：<br>  ​            1. 容量预分配，在实际读写过程中如果不够再扩展。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf byteBuf = com.eastmoney.quote.service.core.common.BufAllocator.newBuffer(resMinData.getByteData().length + <span class="number">28</span>);</span><br></pre></td></tr></table></figure><p>  ​            2. 根据协议消息长度创建缓冲区。    </p><ol start="3"><li>缓冲区内存释放：防止因为缓冲区使用不当导致的内存泄露。</li><li>NIO 消息发送队列的长度上限控制。</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (buf.readableBytes() &gt;= ServerInfo.getInstance().getChunkSize()) &#123;</span><br><span class="line">    writeBuf(buf);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (batchBuf == <span class="keyword">null</span>) &#123;</span><br><span class="line">        batchBuf = BufAllocator.newBuffer();</span><br><span class="line">    &#125;</span><br><span class="line">    batchBuf.writeBytes(buf);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       buf.release();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       LOG.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-RPC-调用层的可靠性设计"><a href="#3-RPC-调用层的可靠性设计" class="headerlink" title="3. RPC 调用层的可靠性设计"></a>3. RPC 调用层的可靠性设计</h4><p>3.1 RPC 调用异常场景<br>​    3.1.1 服务路由失败<br>​    3.1.2 服务端超时<br>​    3.1.3 服务端调用失败<br>3.2 RPC 调用可靠性方案<br>​    3.2.1 注册中心与链路检测双保险机制<br>​    3.2.2 集群容错策略</p><h4 id="4-第三方服务依赖故障隔离"><a href="#4-第三方服务依赖故障隔离" class="headerlink" title="4. 第三方服务依赖故障隔离"></a>4. 第三方服务依赖故障隔离</h4><p>4.1 总体策略<br>4.2 异步化<br>4.3. 基于 Hystrix 的第三方依赖故障隔离</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;挖坑待填…&lt;/p&gt;
&lt;p&gt;本文以《Netty权威指南（第二版）》第23章&lt;strong&gt;可靠性&lt;/strong&gt;为基础，结合实际项目中的应用，实现RPC框架的可靠性设计。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
      <category term="RPC" scheme="http://yoursite.com/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>线上服务性能调优：Netty高性能编程</title>
    <link href="http://yoursite.com/2018/11/16/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%EF%BC%9ANetty%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/11/16/线上服务性能调优：Netty高性能编程/</id>
    <published>2018-11-16T03:28:20.479Z</published>
    <updated>2019-03-25T08:32:03.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>我的Netty通信框架学习是从李林峰老师的《Netty权威指南（第二版）》开始的，书中从原始的I/O模型到Netty的高性能、可靠性等高级特性进行了由浅入深的讲解。偶然的机会，发现了李林峰老师在InfoQ上的专栏：<a href="https://www.infoq.cn/profile/1278176" target="_blank" rel="noopener">InfoQ_李林峰</a>，当前还保持着不错的更新频率，大家感兴趣的可以关注一下。学习本身就是一个不断获取知识然后投入实践的过程，本文将简单记录下在我自己的项目中是如何实践Netty高性能编程的。</p><a id="more"></a><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>声明：本文将以《Netty权威指南（第二版）》第22章<strong>高性能之道</strong>为基础，对项目中的实际应用进行梳理，可以看做是自己的一份学习笔记，方便记忆及以后查看，不做其他用途。</p><h3 id="传统-RPC-调用性能差的三宗罪"><a href="#传统-RPC-调用性能差的三宗罪" class="headerlink" title="传统 RPC 调用性能差的三宗罪"></a>传统 RPC 调用性能差的三宗罪</h3><ul><li><p>网络传输方式问题：</p><p>传统的 RPC 框架或者基于 RMI 等方式的远程服务（过程）调用采用了同步阻塞 IO，当客户端的并发压力或者网络时延增大之后，同步阻塞 IO 会由于频繁的 wait 导致 IO 线程经常性的阻塞，由于线程无法高效的工作，IO 处理能力自然下降。</p></li><li><p>序列化方式问题：<br>Java 序列化存在如下几个典型问题：</p><ul><li>无法跨语言使用；</li><li>序列化后的码流太大，网络传输还是持久化到磁盘，都会导致额外的资源占用；</li><li>序列化性能差（CPU 资源占用高）；</li></ul></li><li><p>线程模型问题：<br>由于采用同步阻塞 IO，这会导致每个 TCP 连接都占用 1 个线程，当 IO 读写阻塞导致线程无法及时释放时，会导致系统性能急剧下降；</p></li></ul><h3 id="高性能的三个主题"><a href="#高性能的三个主题" class="headerlink" title="高性能的三个主题"></a>高性能的三个主题</h3><p>​    1) 传输：用什么样的通道将数据发送给对方，BIO、NIO 或者 AIO，IO 模型在很大程度上决定了框架的性能。<br>​    2) 协议：采用什么样的通信协议，HTTP 或者内部私有协议。协议的选择不同，性能模型也不同。相比于公有协议，内部私有协议的性能通常可以被设计的更优。<br>​    3) 线程：数据报如何读取？读取之后的编解码在哪个线程进行，编解码后的消息如何派发，Reactor 线程模型的不同，对性能的影响也非常大。</p><h3 id="Netty-高性能编程实践"><a href="#Netty-高性能编程实践" class="headerlink" title="Netty 高性能编程实践"></a>Netty 高性能编程实践</h3><h4 id="1-异步非阻塞通信"><a href="#1-异步非阻塞通信" class="headerlink" title="1. 异步非阻塞通信"></a>1. 异步非阻塞通信</h4><p>与 Socket 类和 ServerSocket 类相对应，NIO 也提供了 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">"Epoll"</span>.equals(ServerInfo.getInstance().getEventLoopGroup())) &#123;</span><br><span class="line">    bossGroup = <span class="keyword">new</span> EpollEventLoopGroup();</span><br><span class="line">    workerGroup = <span class="keyword">new</span> EpollEventLoopGroup();</span><br><span class="line">    serverBootstrap = serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">            .channel(EpollServerSocketChannel.class);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    serverBootstrap = serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">            .channel(NioServerSocketChannel.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-零拷贝"><a href="#2-零拷贝" class="headerlink" title="2. 零拷贝"></a>2. 零拷贝</h4><p>​    1) Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title">newBufferType</span><span class="params">(<span class="keyword">byte</span> type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (type == BYTEBUF_TYPE_POOLED_DIRECT) &#123;</span><br><span class="line"><span class="keyword">return</span> PooledByteBufAllocator.DEFAULT.directBuffer().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == BYTEBUF_TYPE_UNPOOLED_DIRECT) &#123;</span><br><span class="line"><span class="keyword">return</span> UnpooledByteBufAllocator.DEFAULT.directBuffer().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == BYTEBUF_TYPE_POOLED_HEAP) &#123;</span><br><span class="line"><span class="keyword">return</span> PooledByteBufAllocator.DEFAULT.buffer().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == BYTEBUF_TYPE_UNPOOLED_HEAP) &#123;</span><br><span class="line"><span class="keyword">return</span> UnpooledByteBufAllocator.DEFAULT.buffer().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> UnpooledByteBufAllocator.DEFAULT.buffer().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    2) Netty 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompositeByteBuf <span class="title">compositeBuffer</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ServerInfo.getInstance().getByteBufType() == BYTEBUF_TYPE_POOLED_DIRECT) &#123;</span><br><span class="line"><span class="keyword">return</span> PooledByteBufAllocator.DEFAULT.compositeDirectBuffer();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ServerInfo.getInstance().getByteBufType() == BYTEBUF_TYPE_UNPOOLED_DIRECT) &#123;</span><br><span class="line"><span class="keyword">return</span> UnpooledByteBufAllocator.DEFAULT.compositeDirectBuffer();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ServerInfo.getInstance().getByteBufType() == BYTEBUF_TYPE_POOLED_HEAP) &#123;</span><br><span class="line"><span class="keyword">return</span> PooledByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ServerInfo.getInstance().getByteBufType() == BYTEBUF_TYPE_UNPOOLED_HEAP) &#123;</span><br><span class="line"><span class="keyword">return</span> UnpooledByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> UnpooledByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    3) Netty 的文件传输采用了 transferTo 方法，它可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。</p><p>​    在实际的开发项目中，没有使用文件传输方法，顾该特性没有使用到。</p><h4 id="3-内存池"><a href="#3-内存池" class="headerlink" title="3. 内存池"></a>3. 内存池</h4><p>为了尽量重用缓冲区，Netty 提供了基于内存池的缓冲区重用机制。Netty 提供了多种内存管理策略，通过在启动辅助类中配置相关参数，可以实现差异化的定制。<br>PooledDirectByteBuf 的 newInstance 方法实现：</p><ul><li>通过 RECYCLER 的 get 方法循环使用 ByteBuf 对象，如果是非内存池实现，则直接创建一个新的 ByteBuf 对象。</li><li>从缓冲池中获取 ByteBuf 之后，调用 AbstractReferenceCountedByteBuf 的 setRefCnt 方法设置引用计数器，用于对象的引用计数和内存回收（类似 JVM 垃圾回收机制）。</li></ul><p>在上面零拷贝的实例中，可以看到对内存池<strong>UnpooledByteBufAllocator</strong>的使用。</p><h4 id="4-高效的-Reactor-线程模型"><a href="#4-高效的-Reactor-线程模型" class="headerlink" title="4. 高效的 Reactor 线程模型"></a>4. 高效的 Reactor 线程模型</h4><p>Reactor 线程模型分为以下三种：</p><p>​    1) Reactor 单线程模型；<br>​    2) Reactor 多线程模型；<br>​    3) 主从 Reactor 多线程模型；</p><p>实际应用中，我们使用的是主从 Reactor 多线程模型，代码实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bossGroup = <span class="keyword">new</span> EpollEventLoopGroup();</span><br><span class="line">workerGroup = <span class="keyword">new</span> EpollEventLoopGroup();</span><br><span class="line">serverBootstrap = serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                        .channel(EpollServerSocketChannel.class);</span><br></pre></td></tr></table></figure><p>服务端启动时创建了两个NioEventLoopGroup，实际上他们是两个独立的Reactor线程池，BossGroup用于服务端处理客户端建立TCP连接的请求，WorkerGroup用于处理I/O相关的读写操作，或则执行系统的Task，定时Task。</p><p>BossGroup线程池具体作用：<br>1)接收客户端的连接，初始化Channel参数；<br>2)将链路状态变更时间通知给ChannelPipeline；</p><p>WorkerGroup线程池具体作用：<br>​    1)异步读取通信对端的数据报，发送读事件到ChannelPipeline；<br>​    2)异步发送消息到通信对端，调用ChannelPipeline的消息发送接口；<br>​    3)执行系统调用、定时任务Task；</p><h4 id="5-无锁化的串行设计理念"><a href="#5-无锁化的串行设计理念" class="headerlink" title="5. 无锁化的串行设计理念"></a>5. 无锁化的串行设计理念</h4><p>为了尽可能提升性能，Netty 采用了串行无锁化设计，在 IO 线程内部进行串行操作，避免多线程竞争导致的性能下降。表面上看，串行化设计似乎 CPU 利用率不高，并发程度不够。但是，通过调整 NIO 线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列 - 多个工作线程模型性能更优。<br>具体实现：</p><p>Netty 的 NioEventLoop 读取到消息之后，直接调用 ChannelPipeline 的 fireChannelRead(Object msg)，只要用户不主动切换线程，一直会由 NioEventLoop 调用到用户的 Handler，期间不进行线程切换。</p><h4 id="6-高效的并发编程"><a href="#6-高效的并发编程" class="headerlink" title="6. 高效的并发编程"></a>6. 高效的并发编程</h4><p>1) volatile 的大量、正确使用 ;<br>2) CAS 和原子类的广泛使用；<br>3) 线程安全容器的使用；</p><p>举例说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推送注册列表</span></span><br><span class="line"><span class="keyword">private</span> ConcurrentHashMap&lt;Short, ResPush&gt; pushList = <span class="keyword">new</span> ConcurrentHashMap&lt;Short, ResPush&gt;();</span><br><span class="line"><span class="comment">// 推送数据队列</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">private</span> ArrayBlockingQueue&lt;Object&gt; dataQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Object&gt;(QUEUE_SIZE_MAX);</span><br></pre></td></tr></table></figure><p>4) 通过读写锁提升并发性能。</p><p>举例说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock writeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!writeLock.tryLock(<span class="number">10</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//写入数据操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-高性能的序列化框架"><a href="#7-高性能的序列化框架" class="headerlink" title="7. 高性能的序列化框架"></a>7. 高性能的序列化框架</h4><p>1) 序列化后的码流大小（网络带宽的占用）；</p><p>首先通过定制私有协议：增量+FAST协议，有效缩减每次请求或推送的数据返回包的大小，然后通过gzip/zip压缩、控制每个返回包的大小等手段实现降低网络带宽的占用。</p><p>其中压缩代码实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ServerInfo.getInstance().isZip()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (header.getZip() == ResHeader.RES_HEADER_ZIP_TO_GZIP) &#123;</span><br><span class="line">        <span class="comment">//压缩写入out，压缩后长度</span></span><br><span class="line">        bodyLen = GZipUtils.compress(bodyBuf, out);</span><br><span class="line">        header.setZip(ResHeader.RES_HEADER_ZIP_GZIP);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (header.getZip() == ResHeader.RES_HEADER_ZIP_TO_ZIP) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[bodyBuf.readableBytes()];</span><br><span class="line">        bodyBuf.readBytes(bytes);</span><br><span class="line">        <span class="keyword">byte</span>[] compress = ZipUtil.compress(bytes);</span><br><span class="line">        out.writeBytes(compress);</span><br><span class="line">        header.setZip(ResHeader.RES_HEADER_ZIP_ZIP);</span><br><span class="line">        bodyLen = compress.length;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bodyLen = bodyBuf.readableBytes();</span><br><span class="line">        <span class="keyword">if</span> (bodyLen &gt;= ServerInfo.getInstance().getZipMaxLength()) &#123;</span><br><span class="line">             <span class="comment">//压缩写入out，压缩后长度</span></span><br><span class="line">             bodyLen = GZipUtils.compress(bodyBuf, out);</span><br><span class="line">             <span class="comment">//压缩</span></span><br><span class="line">             header.setZip(ResHeader.RES_HEADER_ZIP_GZIP);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             out.writeBytes(bodyBuf);</span><br><span class="line">             header.setZip(ResHeader.RES_HEADER_ZIP_UNZIP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2) 序列化 &amp; 反序列化的性能（CPU 资源占用）；</p><p>因为涉及到私有协议的定制，不适合展开细讲，这里大体提一下，在序列化优化这方面，我们使用了增量+FAST协议栈的方式，包体协议定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UINT[] dps; //标识每一字段数据精度</span><br><span class="line">UINT baseNum; //基准数据id (int)</span><br><span class="line">TmpData</span><br><span class="line">&#123;</span><br><span class="line">BIT_VECTOR flag;//数据二进制位</span><br><span class="line">UINT[] diff;//增量数据 (int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>依次读入数据，选取基准数据，后续读入数据根据基准数据做增量，减少返回包数据大小。</p></li><li><p>增量数据设置：</p><ul><li><p>flag：     </p><p>​    ①第一位如果设置（isSet(0)），表示是全量数据，后面n-1位没有设置；</p><pre><code>②第一位如果没有设置，表示增量，后面n-1位设置过的表示有增量数据，未设置过的表示该位数据与基准数据对应数据相同。</code></pre></li><li><p>增量数据返回的数据与flag位是否设置相对应。</p></li></ul></li><li><p>私有协议同时支持可配置的全量拉取、注册推送等模式，降低服务器压力；</p></li></ul><p>3) 是否支持跨语言（异构系统的对接和开发语言切换）。</p><p>本项目中通过定制化私有协议实现了RPC服务与不同的客户端：终端、API、Web服务、Excel等的跨语言通信。</p><h4 id="8-灵活的-TCP-参数配置能力"><a href="#8-灵活的-TCP-参数配置能力" class="headerlink" title="8. 灵活的 TCP 参数配置能力"></a>8. 灵活的 TCP 参数配置能力</h4><p>1) SO_RCVBUF 和 SO_SNDBUF：通常建议值为 128K 或者 256K；<br>2) SO_TCPNODELAY：NAGLE 算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法；<br>3) 软中断：如果 Linux 内核版本支持 RPS（2.6.35 以上版本），开启 RPS 后可以实现软中断，提升网络吞吐量。</p><p>TCP/Socket的设置，具体有 SO_REUSEADDR， TCP_NODELAY， SO_KEEPALIVE，SO_LINGER， SO_TIMEOUT， SO_BACKLOG，SO_SNDBUF， SO_RCVBUF。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>迫于篇幅限制，本文只是单纯的对Netty的高性能编程实践进行了简单的罗列，实际在开发过程中，每一项改动都需要结合JVM监控工具及运维监控平台进行大量的参数修改及压力测试，力求找到RPC服务性能的最优解。当然根据生产环境的不同，这些特性的使用也不完全一致，需要我们具体对待。</p><p>通过对Netty高性能编程的时间以及JVM调优，线上服务的性能其实是有了不小的提升：</p><p>​    内存占用方面，报价接口服务内存占用从 25G 降低到 21G，实时接口服务内存占用从 26G 降低到 13G；<br>​    CPU 占用方面，线上 RPC 服务的 CPU 占用率从高峰期 1100%降低到 600%左右，服务器负载从 16 降低到 11；<br>​    I/O 带宽方面，返回包数据大小减小了 30%～36%。</p><p>最后还是要感谢李林峰老师，给我RPC服务的Netty性能调优提供了清晰的思路。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;我的Netty通信框架学习是从李林峰老师的《Netty权威指南（第二版）》开始的，书中从原始的I/O模型到Netty的高性能、可靠性等高级特性进行了由浅入深的讲解。偶然的机会，发现了李林峰老师在InfoQ上的专栏：&lt;a href=&quot;https://www.infoq.cn/profile/1278176&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;InfoQ_李林峰&lt;/a&gt;，当前还保持着不错的更新频率，大家感兴趣的可以关注一下。学习本身就是一个不断获取知识然后投入实践的过程，本文将简单记录下在我自己的项目中是如何实践Netty高性能编程的。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty直接内存泄露问题排查</title>
    <link href="http://yoursite.com/2018/11/16/Netty%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    <id>http://yoursite.com/2018/11/16/Netty直接内存泄露/</id>
    <published>2018-11-16T02:50:20.893Z</published>
    <updated>2019-03-25T07:06:41.487Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf21c6726a92.png" alt="netty.png"></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在做接口服务内存和CPU优化，使用Netty版本为<code>netty-all-4.1.29.Final</code>，对于行情数据我们采用Netty的直接内存进行存储，Netty的几种<code>ByteBuf</code>介绍见：<a href="https://f8f-1bearcat.github.io/2018/11/19/Netty%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%AF%B9%E8%B1%A1/" target="_blank" rel="noopener">Netty常见内存结构</a> ，当前我们使用的是<code>PooledByteBufAllocator</code>，所以每次内存使用完毕后都需要通过<code>release()</code>方法手动回收直接内存。</p><p>使用Netty的直接内存有点与C类似，自己malloc的对象需要自己free；但与C不同的是，在内有引用计数器，外有Java的GC的场景下，Netty直接内存的使用更为复杂，对内存的使用稍有纰漏就会导致整个服务挂掉。在一次优化版本中，就出现了很严重的Netty直接内存泄露的问题。<br><a id="more"></a></p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>前一天盘后我们部署了某个优化版本到灰度服务器上，第二天行情数据下发后伴随着用户量增长，接口服务在很短的时间内不可用。</p><p>通过运维平台调取了当天该服务器上的内存使用情况：</p><p><img src="https://i.loli.net/2018/11/19/5bf2700185b45.png" alt="SZVPC内存使用情况.png"></p><p>可以发现在上午9:00~11:00时间段内，接口服务多次挂掉后自动重启，中午版本回退后服务才恢复正常。</p><h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><h3 id="一、查看系统日志"><a href="#一、查看系统日志" class="headerlink" title="一、查看系统日志"></a>一、查看系统日志</h3><p>首先查看服务异常时间段内服务器上的日志，可以发现在短时间内日志打印了非常多的直接内存分配异常<code>OutOfDirectMemoryError</code>：</p><p><img src="https://i.loli.net/2018/11/19/5bf28a9a2d455.png" alt="直接内存分配异常.png"></p><p>日志显示直接内存Direct Memory不够用了，该服务器上配置了堆内存12G，直接内存18G，与异常中打印的最大可分配直接内存相匹配；</p><p><img src="https://i.loli.net/2018/11/19/5bf2701a7dc76.png" alt="内存配置.png"></p><p>根据之前的内存使用情况可以断定在服务正常状态下，18G直接内存是能满足接口服务使用场景的，那就可以断定单纯地在配置中增大可分配直接内存的大小不能解决问题。</p><h3 id="二、确认异常抛出原因"><a href="#二、确认异常抛出原因" class="headerlink" title="二、确认异常抛出原因"></a>二、确认异常抛出原因</h3><p>通过上面OOM异常日志，可以追踪到<code>PlatformDependent.java</code>的<code>incrementMemoryCounter(int capacity)</code>方法。</p><p><img src="https://i.loli.net/2018/11/19/5bf21b9878c32.png" alt=""></p><p>我们可以看到这个方法是Netty自身对已使用直接内存进行计数，当计数器<code>DIRECT_MEMORY_COUNTER</code>已使用内存大于直接内存上限<code>DIRECT_MEMORY_LIMIT</code>时，抛出一个OutOfDirectMemoryError异常，这个直接内存上限即上面我们在配置文件中通过<code>-XX:MaxDirectMemorySize</code>配置的。关于Netty的OutOfDirectMemoryError问题见：<a href="https://f8f-1bearcat.github.io/2018/11/19/Netty%E7%9A%84OutOfDirectMemoryError%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">关于Netty的OutOfDirectMemoryError问题</a> 。</p><p>无法分配直接内存无非是以下两种情况导致的：</p><ol><li>分配的直接内存最终没有<code>release()</code>掉，使直接内存不断被分配使用而没有回收掉，最终达到可用上限产生内存泄露；</li><li>因用户网络异常或者传输的数据量过大等问题，使得直接内存的释放回收速度小于其分配的速度，最终无内存可分配抛出OOM。</li></ol><p>如果是前者，就需要找出没有正确<code>release()</code>的代码进行修改；如果是后者，则需要在write的时候，添加流控措施，避免到达内存限制。</p><h3 id="三、Netty内存泄漏的监测机制"><a href="#三、Netty内存泄漏的监测机制" class="headerlink" title="三、Netty内存泄漏的监测机制"></a>三、Netty内存泄漏的监测机制</h3><p>Netty本身提供了内存泄漏的监测机制（详细介绍见：<a href="https://f8f-1bearcat.github.io/2018/11/19/Netty%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%AF%B9%E8%B1%A1/" target="_blank" rel="noopener">Netty引用计数对象</a>），我们可以通过在配置文件中配置<code>-Dio.netty.leakDetectionLevel</code>对分配的ByteBuf进行跟踪。</p><p><img src="https://i.loli.net/2018/11/19/5bf27013c719b.png" alt="leakDetection.png"></p><p>如果服务有内存泄露，则会打印如下日志：</p><blockquote><p>LEAK: ByteBuf.release() was not called before it’s garbage-collected. Enable advanced leak reporting to find out where the leak occurred. To enable advanced leak reporting, specify the JVM option ‘-Dio.netty.leakDetectionLevel=paranoid’ or call ResourceLeakDetector .setLevel()</p></blockquote><p>因为是功能测试，所以在异常服务上，我将监测的级别配置为paranoid，运行一段时间后查看服务日志，发现并未有<strong>LEAK </strong>日志打印，看来通过Netty自身的监测机制定位问题这条路走不通。</p><h3 id="四、Arthas查看直接内存使用情况"><a href="#四、Arthas查看直接内存使用情况" class="headerlink" title="四、Arthas查看直接内存使用情况"></a>四、Arthas查看直接内存使用情况</h3><p>我们知道服务是因为已使用直接内存达到了可分配上限才挂掉的，那通过查看服务器上<code>DIRECT_MEMORY_COUNTER</code>的大小能不能发现问题呢？这时候不得不提到Java诊断神器Arthas了（详细介绍见：<a href="https://f8f-1bearcat.github.io/2018/11/19/Arthas%E2%80%94%E5%BC%80%E6%BA%90Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/" target="_blank" rel="noopener">介绍一款开源Java诊断工具—Arthas</a> ）。</p><p>通过Arthas进入到当前服务进程，执行sc命令来查看<code>PlatformDependent.java</code>类的成员变量：</p><blockquote><p>sc -df io.netty.util.internal.PlatformDependent</p></blockquote><p>可以看到命令执行后当前时间的<strong>已分配直接内存</strong>和<strong>可分配直接内存上限</strong>两个参数的值：</p><p><img src="https://i.loli.net/2018/11/19/5bf26527165f9.png" alt="directmemory.png"></p><p>使用Arthas来查看确实简单便捷，但是因为只能查看一个时间点的变量的值（<del>也可能是我的打开方式不对</del>），对我们解决问题帮助不是很大，所以还是用笨办法吧，即通过起一个线程来定时打印直接内存的值。</p><h3 id="五、日志打印直接内存"><a href="#五、日志打印直接内存" class="headerlink" title="五、日志打印直接内存"></a>五、日志打印直接内存</h3><h4 id="直接内存定时打印"><a href="#直接内存定时打印" class="headerlink" title="直接内存定时打印"></a>直接内存定时打印</h4><p>这里我写了一个线程，每两秒将通过反射获取的<code>DIRECT_MEMORY_COUNTER</code>参数的值在日志中实时打印出来，方便我们调试。</p><p><img src="https://i.loli.net/2018/11/19/5bf26713a10a9.png" alt="直接内存打印.png"></p><h4 id="模拟客户端进行压力测试"><a href="#模拟客户端进行压力测试" class="headerlink" title="模拟客户端进行压力测试"></a>模拟客户端进行压力测试</h4><p>为了能明显地看到内存分配的数值变化，这里我通过编写TestMain模拟客户端用户来请求接口服务数据；</p><p><img src="https://i.loli.net/2018/11/19/5bf269a675904.png" alt="压力测试.png"></p><p>并设置模拟用户量为200，将有问题的服务部署到开发服务器上进行压力测试。</p><p><img src="https://i.loli.net/2018/11/19/5bf2699bdaf27.png" alt="压力测试用户.png"></p><h4 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h4><p>首先将开发服务器上接口服务启动，这是当前服务的端口连接数为0，即没有用户访问，这时服务已使用的直接内存维持在一个稳定的值256MB（如下图前几条日志所示）；当把压力测试程序启动，随着用户连接数涨到200，服务已使用的直接内存迅速飙升（如下图选中日志所示），一直达到可用内存上限18G，最终导致服务不可用，整个用时不到5分钟！</p><p><img src="https://i.loli.net/2018/11/19/5bf2746f146fc.png" alt="内存日志2.png"></p><p>到这里我们可以得出结论，本次内存泄露与接口服务处理上游数据的过程无关，而是在处理用户请求并返回数据的过程中抛出的。</p><p>到这里问题的定位范围进一步缩小，我还是采用了虽然繁琐但是直接有效的方法：范围从大到小地对请求返回数据过程中分配及使用直接内存的代码块进行注释，并部署到开发服务器上进行测试。</p><p>其中的具体操作过程略去不表，其实结果证明这个方法确实是很有效的，我只重新部署哦了两次服务就找到了问题代码：</p><p><img src="https://i.loli.net/2018/11/19/5bf280fb7fd1e.png" alt="callback.png"></p><p>当我把上图选中代码注释掉后，再进行压力测试接口服务已使用直接内存的值维持在256MB不再增长，如下图所示：</p><p><img src="https://i.loli.net/2018/11/19/5bf272fdb0bbf.png" alt="内存日志1.png"></p><p>进入到<code>callback()</code>方法最终修改了下图所示代码，对已分配但位使用的直接内存进行<code>release()</code>回收释放，重新部署，测试通过。</p><p><img src="https://i.loli.net/2018/11/19/5bf280fb09e34.png" alt="代码修改.png"></p><h3 id="六、后续"><a href="#六、后续" class="headerlink" title="六、后续"></a>六、后续</h3><p>我提交了代码盘后通过CI重新发布到之前出现异常的服务器上，几个交易日过去了，问题没有再出现。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>1.对于Netty直接内存问题，我们可以通过三种手段来定位问题：Netty自身的内存泄露监测机制；Arthas等第三方工具；发射获取并打印直接内存数值。</p><p>2.这次问题的出现是只在ByteBuf使用之后进行了回收，没有考虑到在异常情况下ByteBuf没有成功传递到下一个Hanlder（<del>其实考虑到了，只不过疏忽了这个分支</del>），这时也要把分配了没有使用的直接内存进行回收。</p><p>3.至于为什么Netty自身的监测机制没有打印LEAK日志，后面我会再研究一下。</p><p>最后希望大家都能：</p><p><img src="https://i.loli.net/2018/11/19/5bf28b9a947e9.png" alt="表情.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf21c6726a92.png&quot; alt=&quot;netty.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在做接口服务内存和CPU优化，使用Netty版本为&lt;code&gt;netty-all-4.1.29.Final&lt;/code&gt;，对于行情数据我们采用Netty的直接内存进行存储，Netty的几种&lt;code&gt;ByteBuf&lt;/code&gt;介绍见：&lt;a href=&quot;https://f8f-1bearcat.github.io/2018/11/19/Netty%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%AF%B9%E8%B1%A1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Netty常见内存结构&lt;/a&gt; ，当前我们使用的是&lt;code&gt;PooledByteBufAllocator&lt;/code&gt;，所以每次内存使用完毕后都需要通过&lt;code&gt;release()&lt;/code&gt;方法手动回收直接内存。&lt;/p&gt;
&lt;p&gt;使用Netty的直接内存有点与C类似，自己malloc的对象需要自己free；但与C不同的是，在内有引用计数器，外有Java的GC的场景下，Netty直接内存的使用更为复杂，对内存的使用稍有纰漏就会导致整个服务挂掉。在一次优化版本中，就出现了很严重的Netty直接内存泄露的问题。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java(10)</title>
    <link href="http://yoursite.com/2018/11/15/Effective%20Java(10)/"/>
    <id>http://yoursite.com/2018/11/15/Effective Java(10)/</id>
    <published>2018-11-15T09:32:56.881Z</published>
    <updated>2018-11-19T05:34:25.830Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf24a39023ab.jpg" alt="effective-java.jpg"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>Effective Java第10章 并发 学习笔记</p><a id="more"></a><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="66-同步访问共享的可变数据"><a href="#66-同步访问共享的可变数据" class="headerlink" title="66 同步访问共享的可变数据"></a>66 同步访问共享的可变数据</h3><ul><li>程序不会终止，后台线程永远在循环。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> stopRequested;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">Thread </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf24a39023ab.jpg&quot; alt=&quot;effective-java.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;Effective Java第10章 并发 学习笔记&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Effective Java" scheme="http://yoursite.com/tags/Effective-Java/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java(8)</title>
    <link href="http://yoursite.com/2018/11/15/Effective%20Java(8)/"/>
    <id>http://yoursite.com/2018/11/15/Effective Java(8)/</id>
    <published>2018-11-15T09:20:20.664Z</published>
    <updated>2018-11-19T05:36:25.968Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf24a39023ab.jpg" alt="effective-java.jpg"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>Effective Java第8章 通用程序设计 学习笔记</p><a id="more"></a><h2 id="通用程序设计"><a href="#通用程序设计" class="headerlink" title="通用程序设计"></a>通用程序设计</h2><h3 id="45-将局部变量作用域最小化"><a href="#45-将局部变量作用域最小化" class="headerlink" title="45 将局部变量作用域最小化"></a>45 将局部变量作用域最小化</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>增强代码的<strong>可读性</strong>和<strong>维护性</strong>，并降低 <strong>出错</strong>的可能性。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li>在局部变量第一次使用的地方声明。</li><li>几乎每个局部变量的声明都应该包含一个初始化表达式。</li><li>使方法小而集中</li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><ul><li><strong>try-catch</strong></li><li><strong>for</strong>循环与<strong>while</strong>循环对比</li></ul><h3 id="46-for-each循环优先于传统的for循环"><a href="#46-for-each循环优先于传统的for循环" class="headerlink" title="46 for-each循环优先于传统的for循环"></a>46 for-each循环优先于传统的for循环</h3><h4 id="for循环缺点"><a href="#for循环缺点" class="headerlink" title="for循环缺点"></a>for循环缺点</h4><ul><li><p><strong>迭代器</strong>和<strong>索引变量</strong>在每个循环中出现三次，其中有两次很容易出错，且编译器不能发现错误。</p><h4 id="for-each循环的优点"><a href="#for-each循环的优点" class="headerlink" title="for-each循环的优点"></a>for-each循环的优点</h4></li><li><p>通过完全隐藏迭代器或者索引变量，避免了混乱或者出错的很可能。</p></li><li>利用<code>for-each</code>循环不会有性能损失，在某些情况下，还稍有性能优势。因其对数组索引的边界值只计算一次。</li><li><p>在对多个集合进行嵌套式迭代时，<code>for-each</code>循环能避免<code>for</code>循环可能出现的问题，同时兼顾代码简洁。  </p><blockquote><p>传统for循环嵌套迭代</p></blockquote><pre><code>enum Face {ONE, TWO, THREE, FOUR, FIVE, SIX}  ...Collection&lt;Face&gt; faces = Array.asList(Face.values());for (Iterator&lt;Face&gt; i = faces.iterator(); i.hasNext; )    for (Iterator&lt;Face&gt; j = faces.iterator(); j.hasNext; )        Sysytem.out.println(i.next() + &quot; &quot; + j.next());</code></pre><blockquote><p>for-each嵌套迭代</p></blockquote><pre><code>for (Suit suit : suits)    for (Rank rank : ranks)        deck.add (new Card (suit, rank));</code></pre></li><li><code>for-each</code>循环不仅能遍历集合和数组，还能遍历任何实现<code>Iterable</code>接口的对象。<h4 id="有三种常见的情况无法使用for-each循环"><a href="#有三种常见的情况无法使用for-each循环" class="headerlink" title="有三种常见的情况无法使用for-each循环"></a>有三种常见的情况无法使用for-each循环</h4></li></ul><ol><li>过滤——需要遍历集合，并删除选定的元素。</li><li>转换——需要遍历列表或数组，并取代它部分或全部的元素值。</li><li>平行迭代——需要并行的遍历多个集合。</li></ol><h3 id="47-了解和使用类库"><a href="#47-了解和使用类库" class="headerlink" title="47 了解和使用类库"></a>47 了解和使用类库</h3><h4 id="类库中值得注意的两个工具"><a href="#类库中值得注意的两个工具" class="headerlink" title="类库中值得注意的两个工具"></a>类库中值得注意的两个工具</h4><ul><li><strong>java.util</strong>包中Collections Framework（集合框架）</li><li><strong>java.util.concurrent</strong>包</li></ul><h3 id="48-如果需要精确的答案，请避免使用float和double"><a href="#48-如果需要精确的答案，请避免使用float和double" class="headerlink" title="48 如果需要精确的答案，请避免使用float和double"></a>48 如果需要精确的答案，请避免使用float和double</h3><ul><li><strong>float</strong> 和 <strong>double</strong> 执行<em>二进制浮点运算</em>，没有提供完全精确的结果，尤其不适合用于货币计算。</li><li><p>使用<strong>BigDecimal</strong>、<strong>int</strong> 或者 <strong>long</strong>进行货币计算。</p><blockquote><ul><li>使用<strong>BigDecimal</strong>缺点：与基本运算类型相比，不方便，而且很慢；优点： 系统记录十进制小数点，允许完全控制舍入，数值超过18位数字。</li><li>选用<strong>int</strong>或者 <strong>long</strong>取决于所涉及数值的大小，同时自己处理十进制小数点。数值没有超过9位数字用 <strong>int</strong>，数值没有超过18位数字用<strong>float</strong>。</li></ul></blockquote></li></ul><h3 id="49-基本类型优于装箱基本类型"><a href="#49-基本类型优于装箱基本类型" class="headerlink" title="49 基本类型优于装箱基本类型"></a>49 基本类型优于装箱基本类型</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><blockquote><p>举例：int，double，boolean</p></blockquote><h4 id="装箱基本类型"><a href="#装箱基本类型" class="headerlink" title="装箱基本类型"></a>装箱基本类型</h4><blockquote><p>举例：Integer，Double，Boolean</p></blockquote><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>基本类型只有值，而装箱基本类型则具有与它们的值不同的同一性（对象引用）；</li><li>基本类型只有功能完备的值，而每个装箱基本类型还有个非功能值：<strong>null</strong>；</li><li>基本类型通常比装箱基本类型更节省时间和空间。</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><p>对装箱基本类型使用 <strong>==</strong> 操作符几乎总是错误的； </p><blockquote><p>比较器错误地返回1；  </p></blockquote><pre><code>public int compare(Integer first, Interger second) {    return first &lt; second ? -1 : (first == sencond ? 0 : 1);}</code></pre></li><li><p>当一项操作中混合使用基本类型与装箱基本类型时，装箱基本类型会自动拆箱。如果<strong>null</strong>对象引用被拆箱，则抛出NullPointerException异常。</p><blockquote><p>抛出NullPointerException异常</p></blockquote><pre><code>static Integer i;public static void main(String[] args) {    if (i == 42)        System.out.println(&quot;123&quot;);}</code></pre></li><li><p>循环中装箱基本类型的变量被反复装箱和拆箱，产生严重性能问题。</p><pre><code>Long sum = 0L;</code></pre><p>  ​    for (long i = 0; i &lt; Integer.MAX_VALUE; i++) {<br>  ​        sum += i;<br>  ​    }</p></li></ul><h3 id="50-如果其他类型更适合，则尽量避免使用字符串"><a href="#50-如果其他类型更适合，则尽量避免使用字符串" class="headerlink" title="50 如果其他类型更适合，则尽量避免使用字符串"></a>50 如果其他类型更适合，则尽量避免使用字符串</h3><h4 id="不应该使用字符串的情形"><a href="#不应该使用字符串的情形" class="headerlink" title="不应该使用字符串的情形"></a>不应该使用字符串的情形</h4><ul><li>字符串不适合代替其他的值类型</li><li>字符串不适合代替枚举类型</li><li>字符串不适合代替聚集类型</li><li>字符串不适合代替能力表（capabilities）</li></ul><h3 id="51-当心字符串连接的性能"><a href="#51-当心字符串连接的性能" class="headerlink" title="51 当心字符串连接的性能"></a>51 当心字符串连接的性能</h3><p>由于字符串不可变，在连接字符串时，它们的内容都要被拷贝。如果数量巨大，应使用<strong>StringBuilder</strong>的 <strong>append</strong>方法。</p><h3 id="52-通过接口引用对象"><a href="#52-通过接口引用对象" class="headerlink" title="52 通过接口引用对象"></a>52 通过接口引用对象</h3><ul><li><p>优先使用接口而不是类来引用对象。如果有合适的接口类型存在，参数、返回值、变量和域都应该用接口类型进声明。 </p><blockquote><p>里氏替换原则</p></blockquote><pre><code>//通过接口引用对象 List&lt;String&gt; lists = new ArrayList&lt;String&gt;(); //通过类引用对象 ×ArrayList&lt;String&gt; lists = new ArrayList&lt;String&gt;();</code></pre></li><li>如果没有合适的接口存在，用类来引用对象。<ul><li>情形一  <strong>值类</strong>，例如<code>String</code>和<code>BigInteger</code>。值类通常是final的，很少会用多个实现，并且很少有对应的接口。</li><li>情形二  对象属于框架，框架的基本类型为类不是接口，例如<code>java.util.TimerTask</code>。使用相关的<strong>基类</strong>引用对象，不用实现类。</li><li>情形三  类实现了接口，但提供了接口中不存在的额外方法，例如<code>LinkedHashMap</code>。</li></ul></li></ul><h3 id="53-接口优于反射机制"><a href="#53-接口优于反射机制" class="headerlink" title="53 接口优于反射机制"></a>53 接口优于反射机制</h3><h4 id="反射机制的弊端"><a href="#反射机制的弊端" class="headerlink" title="反射机制的弊端"></a>反射机制的弊端</h4><ul><li>丧失了编译时类型检查的好处。</li><li>执行反射访问的代码冗长。</li><li>性能损失。</li></ul><h3 id="54-55-56-待续"><a href="#54-55-56-待续" class="headerlink" title="54 55 56 待续"></a>54 55 56 待续</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf24a39023ab.jpg&quot; alt=&quot;effective-java.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;Effective Java第8章 通用程序设计 学习笔记&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Effective Java" scheme="http://yoursite.com/tags/Effective-Java/"/>
    
  </entry>
  
</feed>
