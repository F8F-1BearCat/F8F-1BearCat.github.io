<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Magical Cat</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-19T07:28:42.623Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>F8F-1BearCat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>介绍一款开源Java诊断工具—Arthas</title>
    <link href="http://yoursite.com/2018/11/19/Arthas%E2%80%94%E5%BC%80%E6%BA%90Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/11/19/Arthas—开源Java诊断工具/</id>
    <published>2018-11-19T06:48:50.651Z</published>
    <updated>2018-11-19T07:28:42.623Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf2661ea96ae.png" alt="arthas.png"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>Arthas（阿尔萨斯）是阿里巴巴开源的 Java 诊断工具，深受开发者喜爱。</p><p>当你遇到以下类似问题而束手无策时，Arthas 可以帮助你解决：</p><pre><code>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！是否有一个全局视角来查看系统的运行状况？有什么办法可以监控到JVM的实时运行状态？</code></pre><p>Arthas 采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。</p><a id="more"></a><p>未完待续…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf2661ea96ae.png&quot; alt=&quot;arthas.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;Arthas（阿尔萨斯）是阿里巴巴开源的 Java 诊断工具，深受开发者喜爱。&lt;/p&gt;
&lt;p&gt;当你遇到以下类似问题而束手无策时，Arthas 可以帮助你解决：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？

我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？

遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？

线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！

是否有一个全局视角来查看系统的运行状况？

有什么办法可以监控到JVM的实时运行状态？
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Arthas 采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="开发工具" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
      <category term="alibaba" scheme="http://yoursite.com/tags/alibaba/"/>
    
  </entry>
  
  <entry>
    <title>Netty的OutOfDirectMemoryError问题</title>
    <link href="http://yoursite.com/2018/11/19/Netty%E7%9A%84OutOfDirectMemoryError%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/11/19/Netty的OutOfDirectMemoryError问题/</id>
    <published>2018-11-19T05:47:24.351Z</published>
    <updated>2018-11-19T05:48:30.883Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf21c6726a92.png" alt="netty.png"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>挖坑…</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf21c6726a92.png&quot; alt=&quot;netty.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;挖坑…&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Netty引用计数对象</title>
    <link href="http://yoursite.com/2018/11/19/Netty%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/11/19/Netty引用计数对象/</id>
    <published>2018-11-19T05:42:35.208Z</published>
    <updated>2018-11-19T05:43:44.331Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf21c6726a92.png" alt="netty.png"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>挖坑…</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf21c6726a92.png&quot; alt=&quot;netty.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;挖坑…&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>线上应用故障排查：高内存占用</title>
    <link href="http://yoursite.com/2018/11/16/%E7%BA%BF%E4%B8%8A%E5%BA%94%E7%94%A8%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%EF%BC%9A%E9%AB%98%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8/"/>
    <id>http://yoursite.com/2018/11/16/线上应用故障排查：高内存占用/</id>
    <published>2018-11-16T09:04:30.994Z</published>
    <updated>2018-11-19T05:43:48.675Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn2.iconfinder.com/data/icons/oxygen/128x128/mimetypes/text-x-java.png" alt="图片"></p><p>挖坑…<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn2.iconfinder.com/data/icons/oxygen/128x128/mimetypes/text-x-java.png&quot; alt=&quot;图片&quot;&gt;&lt;/p&gt;
&lt;p&gt;挖坑…&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>线上应用故障排查：高CPU占用</title>
    <link href="http://yoursite.com/2018/11/16/%E7%BA%BF%E4%B8%8A%E5%BA%94%E7%94%A8%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%EF%BC%9A%E9%AB%98CPU%E5%8D%A0%E7%94%A8/"/>
    <id>http://yoursite.com/2018/11/16/线上应用故障排查：高CPU占用/</id>
    <published>2018-11-16T03:28:20.479Z</published>
    <updated>2018-11-19T05:43:52.795Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn2.iconfinder.com/data/icons/oxygen/128x128/mimetypes/text-x-java.png" alt="图片"></p><p>挖坑…<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn2.iconfinder.com/data/icons/oxygen/128x128/mimetypes/text-x-java.png&quot; alt=&quot;图片&quot;&gt;&lt;/p&gt;
&lt;p&gt;挖坑…&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>Netty直接内存泄露</title>
    <link href="http://yoursite.com/2018/11/16/Netty%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    <id>http://yoursite.com/2018/11/16/Netty直接内存泄露/</id>
    <published>2018-11-16T02:50:20.893Z</published>
    <updated>2018-11-19T09:56:02.179Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf21c6726a92.png" alt="netty.png"></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在做接口服务内存和CPU优化，使用Netty版本为<code>netty-all-4.1.29.Final</code>，对于行情数据我们采用Netty的直接内存进行存储，Netty的几种<code>ByteBuf</code>介绍见：<a href="https://f8f-1bearcat.github.io/2018/11/19/Netty%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%AF%B9%E8%B1%A1/" target="_blank" rel="noopener">Netty常见内存结构</a> ，当前我们使用的是<code>PooledByteBufAllocator</code>，所以每次内存使用完毕后都需要通过<code>release()</code>方法手动回收直接内存。</p><p>使用Netty的直接内存有点与C类似，自己malloc的对象需要自己free；但与C不同的是，在内有引用计数器，外有Java的GC的场景下，Netty直接内存的使用更为服务，对内存的使用稍有纰漏就会导致整个服务挂掉。在一次优化版本中，就出现了很严重的Netty直接内存泄露的问题。<br><a id="more"></a></p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>前一天盘后我们部署了某个优化版本到灰度服务器上，第二天行情数据下发后伴随着用户量增长，接口服务在很短的时间内不可用。</p><p>通过运维平台调取了当天该服务器上的内存使用情况：</p><p><img src="https://i.loli.net/2018/11/19/5bf2700185b45.png" alt="SZVPC内存使用情况.png"></p><p>可以发现在上午9:00~11:00时间段内，接口服务多次挂掉后自动重启，中午版本回退后服务才恢复正常。</p><h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><h3 id="一、查看系统日志"><a href="#一、查看系统日志" class="headerlink" title="一、查看系统日志"></a>一、查看系统日志</h3><p>首先查看服务异常时间段内服务器上的日志，可以发现在短时间内日志打印了非常多的直接内存分配异常<code>OutOfDirectMemoryError</code>：</p><p><img src="https://i.loli.net/2018/11/19/5bf27017e9fa0.png" alt="直接内存分配异常.png"></p><p>日志显示直接内存Direct Memory不够用了，该服务器上配置了堆内存12G，直接内存18G，与异常中打印的最大可分配直接内存相匹配；</p><p><img src="https://i.loli.net/2018/11/19/5bf2701a7dc76.png" alt="内存配置.png"></p><p>根据之前的内存使用情况可以断定在服务正常状态下，18G直接内存是能满足接口服务使用场景的，那就可以断定单纯地在配置中增大可分配直接内存的大小不能解决问题。</p><h3 id="二、确认异常抛出原因"><a href="#二、确认异常抛出原因" class="headerlink" title="二、确认异常抛出原因"></a>二、确认异常抛出原因</h3><p>通过上面OOM异常日志，可以追踪到<code>PlatformDependent.java</code>的<code>incrementMemoryCounter(int capacity)</code>方法。</p><p><img src="https://i.loli.net/2018/11/19/5bf21b9878c32.png" alt=""></p><p>我们可以看到这个方法是Netty自身对已使用直接内存进行计数，当计数器<code>DIRECT_MEMORY_COUNTER</code>已使用内存大于直接内存上限<code>DIRECT_MEMORY_LIMIT</code>时，抛出一个OutOfDirectMemoryError异常，这个直接内存上限即上面我们在配置文件中通过<code>-XX:MaxDirectMemorySize</code>配置的。关于Netty的OutOfDirectMemoryError问题见：<a href="https://f8f-1bearcat.github.io/2018/11/19/Netty%E7%9A%84OutOfDirectMemoryError%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">关于Netty的OutOfDirectMemoryError问题</a> 。</p><p>无法分配直接内存无非是以下两种情况导致的：</p><ol><li>分配的直接内存最终没有<code>release()</code>掉，使直接内存不断被分配使用而没有回收掉，最终达到可用上限产生内存泄露；</li><li>因用户网络异常或者传输的数据量过大等问题，使得直接内存的释放回收速度小于其分配的速度，最终无内存可分配抛出OOM。</li></ol><p>如果是前者，就需要找出没有正确<code>release()</code>的代码进行修改；如果是后者，则需要在write的时候，添加流控措施，避免到达内存限制。</p><h3 id="三、Netty内存泄漏的监测机制"><a href="#三、Netty内存泄漏的监测机制" class="headerlink" title="三、Netty内存泄漏的监测机制"></a>三、Netty内存泄漏的监测机制</h3><p>Netty本身提供了内存泄漏的监测机制（详细介绍见：<a href="https://f8f-1bearcat.github.io/2018/11/19/Netty%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%AF%B9%E8%B1%A1/" target="_blank" rel="noopener">Netty引用计数对象</a>），我们可以通过在配置文件中配置<code>-Dio.netty.leakDetectionLevel</code>对分配的ByteBuf进行跟踪。</p><p><img src="https://i.loli.net/2018/11/19/5bf27013c719b.png" alt="leakDetection.png"></p><p>如果服务有内存泄露，则会打印如下日志：</p><blockquote><p>LEAK: ByteBuf.release() was not called before it’s garbage-collected. Enable advanced leak reporting to find out where the leak occurred. To enable advanced leak reporting, specify the JVM option ‘-Dio.netty.leakDetectionLevel=paranoid’ or call ResourceLeakDetector .setLevel()</p></blockquote><p>因为是功能测试，所以在异常服务上，我将监测的级别配置为paranoid，运行一段时间后查看服务日志，发现并未有<strong>LEAK </strong>日志打印，看来通过Netty自身的监测机制定位问题这条路走不通。</p><h3 id="四、Arthas查看直接内存使用情况"><a href="#四、Arthas查看直接内存使用情况" class="headerlink" title="四、Arthas查看直接内存使用情况"></a>四、Arthas查看直接内存使用情况</h3><p>我们知道服务是因为已使用直接内存达到了可分配上限才挂掉的，那通过查看服务器上<code>DIRECT_MEMORY_COUNTER</code>的大小能不能发现问题呢？这时候不得不提到Java诊断神器Arthas了（详细介绍见：<a href="https://f8f-1bearcat.github.io/2018/11/19/Arthas%E2%80%94%E5%BC%80%E6%BA%90Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/" target="_blank" rel="noopener">介绍一款开源Java诊断工具—Arthas</a> ）。</p><p>通过Arthas进入到当前服务进程，执行sc命令来查看<code>PlatformDependent.java</code>类的成员变量：</p><blockquote><p>sc -df io.netty.util.internal.PlatformDependent</p></blockquote><p>可以看到命令执行后当前时间的<strong>已分配直接内存</strong>和<strong>可分配直接内存上限</strong>两个参数的值：</p><p><img src="https://i.loli.net/2018/11/19/5bf26527165f9.png" alt="directmemory.png"></p><p>使用Arthas来查看确实简单便捷，但是因为只能查看一个时间点的变量的值（<del>也可能是我的打开方式不对</del>），对我们解决问题帮助不是很大，所以还是用笨办法吧，即通过起一个线程来定时打印直接内存的值。</p><h3 id="五、日志打印直接内存"><a href="#五、日志打印直接内存" class="headerlink" title="五、日志打印直接内存"></a>五、日志打印直接内存</h3><h4 id="直接内存定时打印"><a href="#直接内存定时打印" class="headerlink" title="直接内存定时打印"></a>直接内存定时打印</h4><p>这里我写了一个线程，每两秒将通过反射获取的<code>DIRECT_MEMORY_COUNTER</code>参数的值在日志中实时打印出来，方便我们调试。</p><p><img src="https://i.loli.net/2018/11/19/5bf26713a10a9.png" alt="直接内存打印.png"></p><h4 id="模拟客户端进行压力测试"><a href="#模拟客户端进行压力测试" class="headerlink" title="模拟客户端进行压力测试"></a>模拟客户端进行压力测试</h4><p>为了能明显地看到内存分配的数值变化，这里我通过编写TestMain模拟客户端用户来请求接口服务数据；</p><p><img src="https://i.loli.net/2018/11/19/5bf269a675904.png" alt="压力测试.png"></p><p>并设置模拟用户量为200，将有问题的服务部署到开发服务器上进行压力测试。</p><p><img src="https://i.loli.net/2018/11/19/5bf2699bdaf27.png" alt="压力测试用户.png"></p><h4 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h4><p>首先将开发服务器上接口服务启动，这是当前服务的端口连接数为0，即没有用户访问，这时服务已使用的直接内存维持在一个稳定的值256MB（如下图前几条日志所示）；当把压力测试程序启动，随着用户连接数涨到200，服务已使用的直接内存迅速飙升（如下图选中日志所示），一直达到可用内存上限18G，最终导致服务不可用，整个用时不到5分钟！</p><p><img src="https://i.loli.net/2018/11/19/5bf2746f146fc.png" alt="内存日志2.png"></p><p>到这里我们可以得出结论，本次内存泄露与接口服务处理上游数据的过程无关，而是在处理用户请求并返回数据的过程中抛出的。</p><p>到这里问题的定位范围进一步缩小，我还是采用了虽然繁琐但是直接有效的方法：范围从大到小地对请求返回数据过程中分配及使用直接内存的代码块进行注释，并部署到开发服务器上进行测试。</p><p>其中的具体操作过程略去不表，其实结果证明这个方法确实是很有效的，我只重新部署哦了两次服务就找到了问题代码：</p><p><img src="https://i.loli.net/2018/11/19/5bf280fb7fd1e.png" alt="callback.png"></p><p>当我把上图选中代码注释掉后，再进行压力测试接口服务已使用直接内存的值维持在256MB不再增长，如下图所示：</p><p><img src="https://i.loli.net/2018/11/19/5bf272fdb0bbf.png" alt="内存日志1.png"></p><p>进入到<code>callback()</code>方法最终修改了下图所示代码，对已分配但位使用的直接内存进行<code>release()</code>回收释放，重新部署，测试通过。</p><p><img src="https://i.loli.net/2018/11/19/5bf280fb09e34.png" alt="代码修改.png"></p><h3 id="六、后续"><a href="#六、后续" class="headerlink" title="六、后续"></a>六、后续</h3><p>我提交了代码盘后通过CI重新发布到之前出现异常的服务器上，几个交易日过去了，问题没有再出现。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>1.对于Netty直接内存问题，我们可以通过三种手段来定位问题：Netty自身的内存泄露监测机制；Arthas等第三方工具；发射获取并打印直接内存数值。</p><p>2.这次问题的出现是只在ByteBuf使用之后进行了回收，没有考虑到在异常情况下ByteBuf没有成功传递到下一个Hanlder（<del>其实考虑到了，只不过疏忽了这个分支</del>），这时也要把分配了没有使用的直接内存进行回收。</p><p>3.至于为什么Netty自身的监测机制没有打印LEAK日志，后面我会再研究一下。</p><p>最后希望大家都能：</p><p><img src="https://i.loli.net/2018/11/19/5bf286c80b22c.jpg" alt="表情.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf21c6726a92.png&quot; alt=&quot;netty.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在做接口服务内存和CPU优化，使用Netty版本为&lt;code&gt;netty-all-4.1.29.Final&lt;/code&gt;，对于行情数据我们采用Netty的直接内存进行存储，Netty的几种&lt;code&gt;ByteBuf&lt;/code&gt;介绍见：&lt;a href=&quot;https://f8f-1bearcat.github.io/2018/11/19/Netty%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%AF%B9%E8%B1%A1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Netty常见内存结构&lt;/a&gt; ，当前我们使用的是&lt;code&gt;PooledByteBufAllocator&lt;/code&gt;，所以每次内存使用完毕后都需要通过&lt;code&gt;release()&lt;/code&gt;方法手动回收直接内存。&lt;/p&gt;
&lt;p&gt;使用Netty的直接内存有点与C类似，自己malloc的对象需要自己free；但与C不同的是，在内有引用计数器，外有Java的GC的场景下，Netty直接内存的使用更为服务，对内存的使用稍有纰漏就会导致整个服务挂掉。在一次优化版本中，就出现了很严重的Netty直接内存泄露的问题。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java(10)</title>
    <link href="http://yoursite.com/2018/11/15/Effective%20Java(10)/"/>
    <id>http://yoursite.com/2018/11/15/Effective Java(10)/</id>
    <published>2018-11-15T09:32:56.881Z</published>
    <updated>2018-11-19T05:34:25.830Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf24a39023ab.jpg" alt="effective-java.jpg"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>Effective Java第10章 并发 学习笔记</p><a id="more"></a><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="66-同步访问共享的可变数据"><a href="#66-同步访问共享的可变数据" class="headerlink" title="66 同步访问共享的可变数据"></a>66 同步访问共享的可变数据</h3><ul><li>程序不会终止，后台线程永远在循环。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> stopRequested;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">Thread </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf24a39023ab.jpg&quot; alt=&quot;effective-java.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;Effective Java第10章 并发 学习笔记&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Effective Java" scheme="http://yoursite.com/tags/Effective-Java/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java(8)</title>
    <link href="http://yoursite.com/2018/11/15/Effective%20Java(8)/"/>
    <id>http://yoursite.com/2018/11/15/Effective Java(8)/</id>
    <published>2018-11-15T09:20:20.664Z</published>
    <updated>2018-11-19T05:36:25.968Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf24a39023ab.jpg" alt="effective-java.jpg"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>Effective Java第8章 通用程序设计 学习笔记</p><a id="more"></a><h2 id="通用程序设计"><a href="#通用程序设计" class="headerlink" title="通用程序设计"></a>通用程序设计</h2><h3 id="45-将局部变量作用域最小化"><a href="#45-将局部变量作用域最小化" class="headerlink" title="45 将局部变量作用域最小化"></a>45 将局部变量作用域最小化</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>增强代码的<strong>可读性</strong>和<strong>维护性</strong>，并降低 <strong>出错</strong>的可能性。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li>在局部变量第一次使用的地方声明。</li><li>几乎每个局部变量的声明都应该包含一个初始化表达式。</li><li>使方法小而集中</li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><ul><li><strong>try-catch</strong></li><li><strong>for</strong>循环与<strong>while</strong>循环对比</li></ul><h3 id="46-for-each循环优先于传统的for循环"><a href="#46-for-each循环优先于传统的for循环" class="headerlink" title="46 for-each循环优先于传统的for循环"></a>46 for-each循环优先于传统的for循环</h3><h4 id="for循环缺点"><a href="#for循环缺点" class="headerlink" title="for循环缺点"></a>for循环缺点</h4><ul><li><p><strong>迭代器</strong>和<strong>索引变量</strong>在每个循环中出现三次，其中有两次很容易出错，且编译器不能发现错误。</p><h4 id="for-each循环的优点"><a href="#for-each循环的优点" class="headerlink" title="for-each循环的优点"></a>for-each循环的优点</h4></li><li><p>通过完全隐藏迭代器或者索引变量，避免了混乱或者出错的很可能。</p></li><li>利用<code>for-each</code>循环不会有性能损失，在某些情况下，还稍有性能优势。因其对数组索引的边界值只计算一次。</li><li><p>在对多个集合进行嵌套式迭代时，<code>for-each</code>循环能避免<code>for</code>循环可能出现的问题，同时兼顾代码简洁。  </p><blockquote><p>传统for循环嵌套迭代</p></blockquote><pre><code>enum Face {ONE, TWO, THREE, FOUR, FIVE, SIX}  ...Collection&lt;Face&gt; faces = Array.asList(Face.values());for (Iterator&lt;Face&gt; i = faces.iterator(); i.hasNext; )    for (Iterator&lt;Face&gt; j = faces.iterator(); j.hasNext; )        Sysytem.out.println(i.next() + &quot; &quot; + j.next());</code></pre><blockquote><p>for-each嵌套迭代</p></blockquote><pre><code>for (Suit suit : suits)    for (Rank rank : ranks)        deck.add (new Card (suit, rank));</code></pre></li><li><code>for-each</code>循环不仅能遍历集合和数组，还能遍历任何实现<code>Iterable</code>接口的对象。<h4 id="有三种常见的情况无法使用for-each循环"><a href="#有三种常见的情况无法使用for-each循环" class="headerlink" title="有三种常见的情况无法使用for-each循环"></a>有三种常见的情况无法使用for-each循环</h4></li></ul><ol><li>过滤——需要遍历集合，并删除选定的元素。</li><li>转换——需要遍历列表或数组，并取代它部分或全部的元素值。</li><li>平行迭代——需要并行的遍历多个集合。</li></ol><h3 id="47-了解和使用类库"><a href="#47-了解和使用类库" class="headerlink" title="47 了解和使用类库"></a>47 了解和使用类库</h3><h4 id="类库中值得注意的两个工具"><a href="#类库中值得注意的两个工具" class="headerlink" title="类库中值得注意的两个工具"></a>类库中值得注意的两个工具</h4><ul><li><strong>java.util</strong>包中Collections Framework（集合框架）</li><li><strong>java.util.concurrent</strong>包</li></ul><h3 id="48-如果需要精确的答案，请避免使用float和double"><a href="#48-如果需要精确的答案，请避免使用float和double" class="headerlink" title="48 如果需要精确的答案，请避免使用float和double"></a>48 如果需要精确的答案，请避免使用float和double</h3><ul><li><strong>float</strong> 和 <strong>double</strong> 执行<em>二进制浮点运算</em>，没有提供完全精确的结果，尤其不适合用于货币计算。</li><li><p>使用<strong>BigDecimal</strong>、<strong>int</strong> 或者 <strong>long</strong>进行货币计算。</p><blockquote><ul><li>使用<strong>BigDecimal</strong>缺点：与基本运算类型相比，不方便，而且很慢；优点： 系统记录十进制小数点，允许完全控制舍入，数值超过18位数字。</li><li>选用<strong>int</strong>或者 <strong>long</strong>取决于所涉及数值的大小，同时自己处理十进制小数点。数值没有超过9位数字用 <strong>int</strong>，数值没有超过18位数字用<strong>float</strong>。</li></ul></blockquote></li></ul><h3 id="49-基本类型优于装箱基本类型"><a href="#49-基本类型优于装箱基本类型" class="headerlink" title="49 基本类型优于装箱基本类型"></a>49 基本类型优于装箱基本类型</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><blockquote><p>举例：int，double，boolean</p></blockquote><h4 id="装箱基本类型"><a href="#装箱基本类型" class="headerlink" title="装箱基本类型"></a>装箱基本类型</h4><blockquote><p>举例：Integer，Double，Boolean</p></blockquote><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>基本类型只有值，而装箱基本类型则具有与它们的值不同的同一性（对象引用）；</li><li>基本类型只有功能完备的值，而每个装箱基本类型还有个非功能值：<strong>null</strong>；</li><li>基本类型通常比装箱基本类型更节省时间和空间。</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><p>对装箱基本类型使用 <strong>==</strong> 操作符几乎总是错误的； </p><blockquote><p>比较器错误地返回1；  </p></blockquote><pre><code>public int compare(Integer first, Interger second) {    return first &lt; second ? -1 : (first == sencond ? 0 : 1);}</code></pre></li><li><p>当一项操作中混合使用基本类型与装箱基本类型时，装箱基本类型会自动拆箱。如果<strong>null</strong>对象引用被拆箱，则抛出NullPointerException异常。</p><blockquote><p>抛出NullPointerException异常</p></blockquote><pre><code>static Integer i;public static void main(String[] args) {    if (i == 42)        System.out.println(&quot;123&quot;);}</code></pre></li><li><p>循环中装箱基本类型的变量被反复装箱和拆箱，产生严重性能问题。</p><pre><code>Long sum = 0L;</code></pre><p>  ​    for (long i = 0; i &lt; Integer.MAX_VALUE; i++) {<br>  ​        sum += i;<br>  ​    }</p></li></ul><h3 id="50-如果其他类型更适合，则尽量避免使用字符串"><a href="#50-如果其他类型更适合，则尽量避免使用字符串" class="headerlink" title="50 如果其他类型更适合，则尽量避免使用字符串"></a>50 如果其他类型更适合，则尽量避免使用字符串</h3><h4 id="不应该使用字符串的情形"><a href="#不应该使用字符串的情形" class="headerlink" title="不应该使用字符串的情形"></a>不应该使用字符串的情形</h4><ul><li>字符串不适合代替其他的值类型</li><li>字符串不适合代替枚举类型</li><li>字符串不适合代替聚集类型</li><li>字符串不适合代替能力表（capabilities）</li></ul><h3 id="51-当心字符串连接的性能"><a href="#51-当心字符串连接的性能" class="headerlink" title="51 当心字符串连接的性能"></a>51 当心字符串连接的性能</h3><p>由于字符串不可变，在连接字符串时，它们的内容都要被拷贝。如果数量巨大，应使用<strong>StringBuilder</strong>的 <strong>append</strong>方法。</p><h3 id="52-通过接口引用对象"><a href="#52-通过接口引用对象" class="headerlink" title="52 通过接口引用对象"></a>52 通过接口引用对象</h3><ul><li><p>优先使用接口而不是类来引用对象。如果有合适的接口类型存在，参数、返回值、变量和域都应该用接口类型进声明。 </p><blockquote><p>里氏替换原则</p></blockquote><pre><code>//通过接口引用对象 List&lt;String&gt; lists = new ArrayList&lt;String&gt;(); //通过类引用对象 ×ArrayList&lt;String&gt; lists = new ArrayList&lt;String&gt;();</code></pre></li><li>如果没有合适的接口存在，用类来引用对象。<ul><li>情形一  <strong>值类</strong>，例如<code>String</code>和<code>BigInteger</code>。值类通常是final的，很少会用多个实现，并且很少有对应的接口。</li><li>情形二  对象属于框架，框架的基本类型为类不是接口，例如<code>java.util.TimerTask</code>。使用相关的<strong>基类</strong>引用对象，不用实现类。</li><li>情形三  类实现了接口，但提供了接口中不存在的额外方法，例如<code>LinkedHashMap</code>。</li></ul></li></ul><h3 id="53-接口优于反射机制"><a href="#53-接口优于反射机制" class="headerlink" title="53 接口优于反射机制"></a>53 接口优于反射机制</h3><h4 id="反射机制的弊端"><a href="#反射机制的弊端" class="headerlink" title="反射机制的弊端"></a>反射机制的弊端</h4><ul><li>丧失了编译时类型检查的好处。</li><li>执行反射访问的代码冗长。</li><li>性能损失。</li></ul><h3 id="54-55-56-待续"><a href="#54-55-56-待续" class="headerlink" title="54 55 56 待续"></a>54 55 56 待续</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf24a39023ab.jpg&quot; alt=&quot;effective-java.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;Effective Java第8章 通用程序设计 学习笔记&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Effective Java" scheme="http://yoursite.com/tags/Effective-Java/"/>
    
  </entry>
  
</feed>
