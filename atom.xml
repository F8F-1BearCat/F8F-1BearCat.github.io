<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Magical Cat</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-31T06:43:45.956Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>F8F-1BearCat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>同步、异步、阻塞、非阻塞IO</title>
    <link href="http://yoursite.com/2019/01/29/%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9EIO/"/>
    <id>http://yoursite.com/2019/01/29/同步、异步、阻塞、非阻塞IO/</id>
    <published>2019-01-29T06:58:00.260Z</published>
    <updated>2019-01-31T06:43:45.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近在整理过去一段时间内Netty性能调优的工作，涉及到了Netty的NIO/Epoll等异步非阻塞通信，索性复习一下常见的几种IO模型。看到CSDN上这篇文章写得很清晰易懂，<a href="https://blog.csdn.net/historyasamirror/article/details/5778378" target="_blank" rel="noopener">IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）</a>，在此基础上整理了一下，方便记忆及以后查看。</p><a id="more"></a><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>IO发生时会经历两个阶段：</p><ul><li><p>等待数据</p></li><li><p>将数据从内核复制到用户空间</p></li></ul><p>不同的IO模型就是根据在这两个阶段所做的处理不同进行区分的。</p><h3 id="Blocking-IO"><a href="#Blocking-IO" class="headerlink" title="Blocking IO"></a>Blocking IO</h3><p><img src="https://i.loli.net/2019/01/30/5c5151d73a80d.jpg" alt="blocking IO.jpg"></p><p><strong>阻塞IO模型（BIO）</strong>：应用进程调用recvfrom，kernel开始了IO的第一阶段：等待数据，等到数据准备好了，kernel开始第二阶段：将数据从内核复制到用户空间。在IO的这两个阶段执行期间，应用进程一直处于block状态，直到kernel返回结果，应用进程阻塞才解除。</p><p>举例：你在美团上点了一份外卖，下单后外卖小哥开始取餐（阶段一），取到餐后再进行配送（阶段二），期间你一直站在门口等（block状态），直到收到外卖才继续自己的事情。</p><h3 id="Nonblocking-IO"><a href="#Nonblocking-IO" class="headerlink" title="Nonblocking IO"></a>Nonblocking IO</h3><p><img src="https://i.loli.net/2019/01/30/5c5151d7b62f1.jpg" alt="non-blocking IO.jpg"></p><p><strong>非阻塞IO模型（NIO）</strong>：应用进程调用recvfrom，kernel开始了IO的第一阶段：等待数据，如果kernel中的数据还没有准备好，就返回应用进程EWOULDBLOCK，应用进程收到返回后会一直调用recvfrom询问kernel，直到数据准备好，在此期间应用进程处于非block状态；然后kernel将数据从内核复制到用户空间，并block应用进程，直到成功返回后阻塞状态解除。所以非阻塞IO和阻塞IO不是完全对立的，在IO第二阶段二者均处于block状态。</p><p>举例：你在美团上点了一份外卖，下单后外卖小哥开始取餐（阶段一），在取餐期间你坐在屋里一遍看剧一边不断打电话给外卖小哥询问取到了没，直到小哥说他拿到了；这时小哥取到餐后进行配送（阶段二），你也起身站在门口等（block状态），直到收到外卖。</p><h3 id="IO-multiplexing"><a href="#IO-multiplexing" class="headerlink" title="IO multiplexing"></a>IO multiplexing</h3><p><img src="https://i.loli.net/2019/01/30/5c5151d7af63b.jpg" alt="IO multiplexing.jpg"></p><p><strong>IO复用模型</strong>：应用进程调用select，通过select可以不断的轮询所负责的所有socket，当某个socket的数据准备好了，select就会返回信息，然后用户态进程调用recvfrom，将数据从内核复制到用户空间。对于每一个socket，一般都设置成为non-blocking，但是整个应用进程受阻于select调用；同样，在IO的第二阶段，应用进程也是出于block状态。</p><p>如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于单个process就可以同时处理多个网络连接的IO。</p><p>Linux关于IO复用的使用，有三种不同的API，select、poll和epoll，关于这三种API的实现分析，可以参考下这篇文章：<a href="https://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="noopener">select、poll、epoll之间的区别总结[整理]</a>。</p><p>举例：这次你在美团上一次点了好几份外卖，美团的消息系统（select等API调用）推给你说等有外卖取到了就发消息给你，让你留意消息（block状态），然后几个外卖小哥就到不同的店去取餐（阶段一）。等取到餐了，如果你用的是select或poll版本的美团，消息推给你说你有订单已经取到了，但是不告诉你是哪家；如果你用的是epoll版本的美团，消息推给你说你有订单已经取到了，而且还告诉你是碳烤羊排。收到消息之后你就到门口去等（block状态），外卖小哥进行配送（阶段二），直到收到外卖才继续自己的事情。</p><h3 id="Asynchronous-IO"><a href="#Asynchronous-IO" class="headerlink" title="Asynchronous IO"></a>Asynchronous IO</h3><p><img src="https://i.loli.net/2019/01/30/5c5151d704ff1.jpg" alt="Asynchronous IO.jpg"></p><p><strong>异步IO模型（AIO）</strong>：应用进程调用aio_read，kernel收到请求后会立刻返回，等数据准备好，并且复制到用户空间后执行事先指定好的函数，整个过程应用进程都处于非block状态。</p><p>举例：你发现自己出去等太大笨蛋了，在美团上点了一份外卖，看到下单成功后就去看剧了。外卖小哥开始取餐（阶段一），取到餐后再进行配送（阶段二），最后送到你门口，整个过程你都在干自己的事情，没有一直等着（非block状态）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="IO模型对比"><a href="#IO模型对比" class="headerlink" title="IO模型对比"></a>IO模型对比</h3><p><img src="https://i.loli.net/2019/01/30/5c5151d774bba.jpg" alt="IO Models.jpg"></p><p>因为信号驱动式IO（signal-driven I/O）使用较少，正文中没提及。</p><p><strong>阻塞IO和非阻塞IO</strong>：调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p><p><strong>同步IO和异步IO</strong>：synchronous IO做”IO operation”的时候会将process阻塞，blocking IO，non-blocking IO，IO multiplexing因为都阻塞于recvfrom调用，都属于synchronous IO。</p><p><strong>非阻塞IO和异步IO</strong>：在数据准备阶段，non-blocking IO中进程不会被block，但是它仍然要求进程去主动的check，而asynchronous IO中应用进程进程将整个IO操作交给kernel来完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;最近在整理过去一段时间内Netty性能调优的工作，涉及到了Netty的NIO/Epoll等异步非阻塞通信，索性复习一下常见的几种IO模型。看到CSDN上这篇文章写得很清晰易懂，&lt;a href=&quot;https://blog.csdn.net/historyasamirror/article/details/5778378&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）&lt;/a&gt;，在此基础上整理了一下，方便记忆及以后查看。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>读懂Young GC日志</title>
    <link href="http://yoursite.com/2018/12/18/%E8%AF%BB%E6%87%82Young%20GC%E6%97%A5%E5%BF%97/"/>
    <id>http://yoursite.com/2018/12/18/读懂Young GC日志/</id>
    <published>2018-12-18T06:46:08.526Z</published>
    <updated>2018-12-19T01:41:01.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>在进行JVM调优时我们经常需要通过日志信息来分析G1GC的性能，本文就日志中可供收集的数据和信息进行了简单介绍。<br><a id="more"></a></p><h2 id="Young-GC日志"><a href="#Young-GC日志" class="headerlink" title="Young GC日志"></a>Young GC日志</h2><p>下面选取了SZVPC线上报价服务的一段Young GC日志：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;Heap before GC invocations=<span class="number">38623</span> (full <span class="number">4</span>):</span><br><span class="line"> garbage-first heap   total <span class="number">25165824</span>K, used <span class="number">11321508</span>K [<span class="number">0x00000001c0000000</span>, <span class="number">0x00000001c040c000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  region size <span class="number">4096</span>K, <span class="number">307</span> young (<span class="number">1257472</span>K), <span class="number">26</span> survivors (<span class="number">106496</span>K)</span><br><span class="line"> Metaspace       used <span class="number">23093</span>K, capacity <span class="number">23236</span>K, committed <span class="number">29440</span>K, reserved <span class="number">1075200</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 2444<span class="title">K</span>, <span class="title">capacity</span> 2510<span class="title">K</span>, <span class="title">committed</span> 3328<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line">2018-12-18T11:19:27.084+0800: 671040.790: [GC pause (G1 Evacuation Pause) (young), 0.3639131 secs]</span><br><span class="line">   [Parallel Time: <span class="number">354.4</span> ms, GC Workers: <span class="number">13</span>]</span><br><span class="line">      [<span class="function">GC Worker <span class="title">Start</span> <span class="params">(ms)</span>: Min: 671040790.4, Avg: 671040790.6, Max: 671040790.8, Diff: 0.4]</span></span><br><span class="line"><span class="function">      [Ext Root <span class="title">Scanning</span> <span class="params">(ms)</span>: Min: 0.8, Avg: 1.0, Max: 1.2, Diff: 0.4, Sum: 13.0]</span></span><br><span class="line"><span class="function">      [Update <span class="title">RS</span> <span class="params">(ms)</span>: Min: 22.6, Avg: 23.0, Max: 23.6, Diff: 1.0, Sum: 299.6]</span></span><br><span class="line"><span class="function">         [Processed Buffers: Min: 24, Avg: 32.5, Max: 39, Diff: 15, Sum: 422]</span></span><br><span class="line"><span class="function">      [Scan <span class="title">RS</span> <span class="params">(ms)</span>: Min: 201.4, Avg: 202.0, Max: 202.4, Diff: 1.0, Sum: 2625.9]</span></span><br><span class="line"><span class="function">      [Code Root <span class="title">Scanning</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.0, Sum: 0.2]</span></span><br><span class="line"><span class="function">      [Object <span class="title">Copy</span> <span class="params">(ms)</span>: Min: 126.9, Avg: 127.2, Max: 127.8, Diff: 0.9, Sum: 1653.5]</span></span><br><span class="line"><span class="function">      [<span class="title">Termination</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.6, Max: 0.9, Diff: 0.9, Sum: 8.3]</span></span><br><span class="line"><span class="function">         [Termination Attempts: Min: 1, Avg: 278.6, Max: 349, Diff: 348, Sum: 3622]</span></span><br><span class="line"><span class="function">      [GC Worker <span class="title">Other</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.1, Max: 0.3, Diff: 0.2, Sum: 1.6]</span></span><br><span class="line"><span class="function">      [GC Worker <span class="title">Total</span> <span class="params">(ms)</span>: Min: 353.8, Avg: 354.0, Max: 354.2, Diff: 0.4, Sum: 4602.1]</span></span><br><span class="line"><span class="function">      [GC Worker <span class="title">End</span> <span class="params">(ms)</span>: Min: 671041144.5, Avg: 671041144.6, Max: 671041144.7, Diff: 0.2]</span></span><br><span class="line"><span class="function">   [Code Root Fixup: 0.0 ms]</span></span><br><span class="line"><span class="function">   [Code Root Purge: 0.0 ms]</span></span><br><span class="line"><span class="function">   [Clear CT: 1.7 ms]</span></span><br><span class="line"><span class="function">   [Other: 7.8 ms]</span></span><br><span class="line"><span class="function">      [Choose CSet: 0.0 ms]</span></span><br><span class="line"><span class="function">      [Ref Proc: 0.6 ms]</span></span><br><span class="line"><span class="function">      [Ref Enq: 0.0 ms]</span></span><br><span class="line"><span class="function">      [Redirty Cards: 2.5 ms]</span></span><br><span class="line"><span class="function">      [Humongous Register: 0.2 ms]</span></span><br><span class="line"><span class="function">      [Humongous Reclaim: 0.1 ms]</span></span><br><span class="line"><span class="function">      [Free CSet: 3.0 ms]</span></span><br><span class="line"><span class="function">   [Eden: 1124.0<span class="title">M</span><span class="params">(<span class="number">1124.0</span>M)</span>-&gt;0.0<span class="title">B</span><span class="params">(<span class="number">1132.0</span>M)</span> Survivors: 104.0M-&gt;96.0M Heap: 10.8<span class="title">G</span><span class="params">(<span class="number">24.0</span>G)</span>-&gt;9968.2<span class="title">M</span><span class="params">(<span class="number">24.0</span>G)</span>]</span></span><br><span class="line"><span class="function">Heap after GC invocations</span>=<span class="number">38624</span> (full <span class="number">4</span>):</span><br><span class="line"> garbage-first heap   total <span class="number">25165824</span>K, used <span class="number">10207396</span>K [<span class="number">0x00000001c0000000</span>, <span class="number">0x00000001c040c000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  region size <span class="number">4096</span>K, <span class="number">24</span> young (<span class="number">98304</span>K), <span class="number">24</span> survivors (<span class="number">98304</span>K)</span><br><span class="line"> Metaspace       used <span class="number">23093</span>K, capacity <span class="number">23236</span>K, committed <span class="number">29440</span>K, reserved <span class="number">1075200</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 2444<span class="title">K</span>, <span class="title">capacity</span> 2510<span class="title">K</span>, <span class="title">committed</span> 3328<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"> [Times: user=4.64 sys=0.00, real=0.36 secs]</span><br></pre></td></tr></table></figure></p><h4 id="日志信息详解："><a href="#日志信息详解：" class="headerlink" title="日志信息详解："></a>日志信息详解：</h4><ul><li><p><strong>garbage-first heap   total 25165824K, used 11321508K [0x00000001c0000000, 0x00000001c040c000, 0x00000007c0000000)</strong></p><p>可以看出GC的类型为G1，Heap的总大小为25165824K，已使用11321508K。</p></li><li><p><strong>region size 4096K, 307 young (1257472K), 26 survivors (106496K)</strong></p><p>每个region的大小为4096K，新生代307个region，survivor区26个region。</p></li><li><p><strong>Metaspace       used 23093K, capacity 23236K, committed 29440K, reserved 1075200K<br> class space    used 2444K, capacity 2510K, committed 3328K, reserved 1048576K</strong></p><p>java8去掉了永久区（Permanent），新增元数据区（Metaspace）。</p></li><li><p><strong>671040.790: [GC pause (G1 Evacuation Pause) (young), 0.3639131 secs]</strong></p><p>G1停顿清理(young) regions，即新生代minor GC。本次停顿在JVM启动后671040.790 s后触发，且停顿持续时间为0.3639131 s，根据系统时间（wall clock time）测定。</p></li><li><p><strong>[Parallel Time: 354.4 ms, GC Workers: 13]</strong></p><p>收集过程是多线程并发执行的，日志表明在354.4ms（real time）时间内，下面的活动是由13个线程并行完成的：</p><ol><li><p><code>GC Worker Start (ms)</code></p><p>收集线程开始的时间，匹配停顿开始时的时间戳。使用的是相对时间，Min是最早开始时间，Avg是平均开始时间，Max是最晚开始时间，Diff是Max-Min。 如果Min和Max差别很大，那么可能表明使用了太多线程或者机器上的其他进程正在从JVM内部的垃圾收集进程中窃取CPU时间。</p></li><li><p><code>Ext Root Scanning (ms)</code></p><p>扫描外部（非heap）roots如类加载器、JNI引用、JVM 系统roots等的耗时，Sum是Cpu time。</p></li><li><p><code>Update RS (ms)</code></p><p>每个线程更新Remembered Set的耗时。</p></li><li><p><code>Scan RS (ms)</code></p><p>扫描CS中的region对应的RSet，因为RSet是points-into，所以这样实现避免了扫描old generadion region，但是会产生float garbage。</p></li><li><p><code>Code Root Scanning (ms)</code></p><p>扫描code roots如本地变量的耗时。code roots指的是经过JIT编译后的代码里，引用了heap中的对象。引用关系保存在RSet中。</p></li><li><p><code>Object Copy (ms)</code></p><p>从收集region拷贝存活的对象到新region的耗时。</p></li><li><p><code>Termination (ms)</code></p><p>工作线程确保它们能够安全地停止并且没有更多的工作要做最终终止所用的耗时。在结束前，它会检查其他线程是否还有未扫描完的引用，如果有，则”偷”过来，完成后再申请结束，这个时间是线程之前互相同步所花费的时间。</p><ul><li><p><code>Termination Attempts</code></p><p>工作线程尝试终止的次数，如果实际还有更多的工作要做，那么尝试就会失败，现在终止还为时过早。</p></li></ul></li><li><p><code>GC Worker Other (ms)</code></p><p>花费在其他杂项（不值得在日志中单独占用一个部分）上的时间。</p></li><li><p><code>GC Worker Total (ms)</code></p><p>所用工作线程耗时之和。</p></li><li><p><code>GC Worker End (ms)</code></p><p>每个线程结束的时间戳，通常它们应该大致相等。</p></li></ol></li><li><p><strong>[Code Root Fixup: 0.0 ms]</strong></p><p>用来将code root修正到正确的evacuate之后的对象位置所花费的时间。</p></li><li><p><strong>[Code Root Purge: 0.0 ms]</strong></p><p>清除code root的耗时，code root中的引用已经失效，不再指向Region中的对象，所以需要被清除。</p></li><li><p><strong>[Clear CT: 1.7 ms]</strong></p><p>清除RSet的card table的耗时，这个任务在serial模式下执行。</p></li><li><p><strong>[Other: 7.8 ms]</strong></p><p>下面所列的其他事项共耗时7.8ms：</p><ol><li><p><code>[Choose CSet: 0.0 ms]</code></p><p>查找Collection Set的region的耗时；</p></li><li><p><code>[Ref Proc: 0.6 ms]</code></p><p>Reference Process， 处理引用对象的耗时；</p></li><li><p><code>[Ref Enq: 0.0 ms]</code></p><p>Reference enqueue，引用对象排队到引用队列的耗时；</p></li><li><p><code>[Redirty Cards: 2.5 ms]</code>略</p></li><li><p><code>[Humongous Register: 0.2 ms]</code>略</p></li><li><p><code>[Humongous Reclaim: 0.1 ms]</code>略</p></li><li><p><code>[Free CSet: 3.0 ms]</code></p><p>清理Collection Set数据结构的耗时；</p></li></ol></li><li><p><strong>[Eden: 1124.0M(1124.0M)-&gt;0.0B(1132.0M) Survivors: 104.0M-&gt;96.0M Heap: 10.8G(24.0G)-&gt;9968.2M(24.0G)]</strong></p><p>分别代表：停顿前后Eden区已用内存和容量；停顿前后Survivor区使用的内存；停顿前后整个Heap已用内存和容量。</p></li><li><p><strong>[Times: user=4.64 sys=0.00, real=0.36 secs]</strong></p><p>整个GC事件的持续时间，从以下不同的类别来测量：</p><ol><li><p><strong>user</strong> - 本次垃圾收集中GC线程所消耗的总体CPU时间；</p></li><li><p><strong>sys</strong> - OS调用或等待系统事件的耗时；</p></li><li><p><strong>real</strong> - 应用程序停止的时间（Clock time）。在GC活动可并行执行的情况下，这个数值理想上应为：（user时间 + sys时间）/ GC所用的线程数，在这个case里线程数是13。要注意的是，有些活动不能并行执行，因此该数值总会超过这个比例一定数量。</p></li></ol></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html" target="_blank" rel="noopener">Getting Started with the G1 Garbage Collector</a></p><p><a href="https://blogs.oracle.com/poonam/understanding-g1-gc-logs" target="_blank" rel="noopener">Understanding G1 GC Logs</a></p><p><a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations/g1/evacuation-pause-fully-young" target="_blank" rel="noopener">JAVA GARBAGE COLLECTION HANDBOOK</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;在进行JVM调优时我们经常需要通过日志信息来分析G1GC的性能，本文就日志中可供收集的数据和信息进行了简单介绍。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="G1GC" scheme="http://yoursite.com/tags/G1GC/"/>
    
  </entry>
  
  <entry>
    <title>JDK命令行工具</title>
    <link href="http://yoursite.com/2018/12/13/JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/12/13/JDK命令行工具/</id>
    <published>2018-12-13T02:10:02.308Z</published>
    <updated>2018-12-13T02:10:02.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>挖坑…</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;挖坑…&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>线上服务CPU负载高问题排查（一）</title>
    <link href="http://yoursite.com/2018/12/06/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1CPU%E8%B4%9F%E8%BD%BD%E9%AB%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/12/06/线上服务CPU负载高问题排查（一）/</id>
    <published>2018-12-06T05:49:15.410Z</published>
    <updated>2018-12-07T01:40:34.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>使用Arthas定位CPU占用率过高的问题，</p><p>未完待续…</p><a id="more"></a><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p><img src="https://i.loli.net/2018/12/06/5c08d11e024ef.png" alt="top.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;使用Arthas定位CPU占用率过高的问题，&lt;/p&gt;
&lt;p&gt;未完待续…&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>线上服务CPU负载高问题排查（二）</title>
    <link href="http://yoursite.com/2018/12/06/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1CPU%E8%B4%9F%E8%BD%BD%E9%AB%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/12/06/线上服务CPU负载高问题排查（二）/</id>
    <published>2018-12-06T05:49:15.410Z</published>
    <updated>2018-12-13T07:25:27.009Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在进行接口服务优化，前面对处理大量数据的线程进行了优化，具体见：<a href="https://f8f-1bearcat.github.io/2018/12/06/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1CPU%E8%B4%9F%E8%BD%BD%E9%AB%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">线上服务CPU负载高问题排查（一）</a> 。当优化后的版本部署到灰度服务器上时，原以为CPU占用率会明显地降低，然而事实却狠狠地打了脸，非但该服务的CPU占用及负载没有降低，反而远远差于上次优化之前版本及线上的服务。是优化方向错了，还是引入了新的问题？<br><a id="more"></a></p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>通过运维中心<code>zabbix</code>面板查看该机房上所有的报价服务负载情况，新部署接口服务的负载情况如下图红线所示：<br><img src="https://i.loli.net/2018/12/06/5c08d1299cb5d.png" alt="load_before.png"><br>可以发现在上午11:00~14:00时间段内，该接口服务的负载明显高于其他几台服务。CPU利用率的情况与负载类似。</p><h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><h3 id="一、比较用户数量"><a href="#一、比较用户数量" class="headerlink" title="一、比较用户数量"></a>一、比较用户数量</h3><p>5个服务都部署在SZVPC机房，并且可以确定服务运行环境是相同的，那么首先需要确认是否是该服务用户量过大导致的。</p><p>登录CRT，通过<code>netstat -antp|grep &#39;port&#39;|wc -l</code>命令查看服务器上的实时用户连接数。对比该机房的5个报价服务发现，所有服务的实时用户连接数大体相等，不存在优化版本服务用户连接远大于其他几台服务的情况。到这里可以得出结论是新部署的服务本身有问题。</p><h3 id="二、定位高CPU占用线程"><a href="#二、定位高CPU占用线程" class="headerlink" title="二、定位高CPU占用线程"></a>二、定位高CPU占用线程</h3><p>1、在上一篇的CPU高负载排查过程中，我们定位到是组合和账户的数据处理线程CPU占用率高。那首先，可以确定下上次优化有没有解决这两个线程的CPU占用问题。</p><p>通过Arthas进入到当前服务进程，执行<code>thread -n 5 -i 1000</code>命令来查看当前CPU占用最高的几个线程。分析堆栈信息，可以看到改完之后的服务组合账户线程的CPU占用率已经降低了，至少前5个线程里面不见他们的踪影。</p><p><img src="https://i.loli.net/2018/12/13/5c11f7ed83ec2.png" alt="thread5.png"></p><p>2、排除了组合账户线程的影响，下一步就要定位到底是什么线程占用CPU最高。通过<code>$ top</code>命令，查看CPU实时使用情况（注：图为后面补加的，数据可能有出入）：<br><img src="https://i.loli.net/2018/12/07/5c09d1aa96940.png" alt="top_load.png"><br>可以看出pid为26810的进程CPU占用率竟然达到了1000%，而这个进程就是接口服务的进程。</p><p>3、经典的命令行工具，如<em>ps</em>或<em>top</em>，都可以用来显示线程级别的信息，下面列举了这两种方法的使用。</p><p>方法一：通过<code>$ ps -mp &lt;pid&gt; -o tid,THREAD,time</code>命令，查看线程列表。到这里确认tid为8592…的这三个线程CPU占用率最高，且占用CPU的时间也很长。</p><p><img src="https://i.loli.net/2018/12/07/5c09de2a7f8c5.png" alt="thread.png"></p><p>方法二：通过<code>$ top -H -p &lt;pid&gt;</code>命令，查看线程列表，得出的结论与方法一一致。</p><p>​            <img src="https://i.loli.net/2018/12/07/5c09de2511265.png" alt="top_thread.png"></p><p>4、定位到线程tid之后，就可以用<code>jstack</code>命令查看线程具体的堆栈信息了，不过<code>jstack</code>命令中线程id使用16进制，因而首先需要通过 <code>$ echo &quot;obase=16;&lt;tid&gt;&quot;|bc</code>或 <code>$ printf &quot;%x\n&quot; &lt;tid&gt;</code>命令将tid转为16进制。</p><p><img src="https://i.loli.net/2018/12/07/5c09de1cb3c4b.png" alt="16.png"></p><p>以tid8592为例，转为16进制后为2190，再通过<code>$ jstack &lt;pid&gt; |grep &lt;tid&gt; -C 20</code>命令查看该线程的堆栈信息。</p><p><img src="https://i.loli.net/2018/12/07/5c09de3041b0a.png" alt="thread_stack.png"></p><h3 id="三、分析"><a href="#三、分析" class="headerlink" title="三、分析"></a>三、分析</h3><p>Gang worker是JVM 用于做新生代垃圾回收（monir gc）的一个线程，#号后面是线程编号。从线程的堆栈信息可以看出是JVM的GC线程一直在占用大量CPU.定位到垃圾收集器的问题，可以通过<code>jstat -gcutil &lt;pid&gt; 1000 100</code>命令统计GC回收的情况（没发现有什么异常）。</p><p><img src="https://i.loli.net/2018/12/13/5c11f7d2e9c4d.png" alt="gcutil.png"></p><p>对应的参数如下：</p><ul><li><strong>S0：</strong>幸存1区当前使用比例</li><li><strong>S1：</strong>幸存2区当前使用比例</li><li><strong>E：</strong>伊甸园区使用比例</li><li><strong>O：</strong>老年代使用比例</li><li><strong>M：</strong>元数据区使用比例</li><li><strong>CCS：</strong>压缩使用比例</li><li><strong>YGC：</strong>年轻代垃圾回收次数</li><li><strong>FGC：</strong>老年代垃圾回收次数</li><li><strong>FGCT：</strong>老年代垃圾回收消耗时间</li><li><strong>GCT：</strong>垃圾回收消耗总时间</li></ul><p>通过<code>jinfo -flags &lt;pid&gt;</code>命令，查看该服务器上的JVM内存参数设置，看到了这一条配置：<code>-Xmx12g -XX:MaxDirectMemorySize=18g</code>，原来之前的服务版本中已经不使用直接内存，而是全都使用堆内存，而这里JVM配置却没有改过来，由此推测是服务的内存分配不够用导致频繁GC，进而引起CPU负载过高。</p><p><img src="https://i.loli.net/2018/12/13/5c11f7f40440c.png" alt="jinfo.png"></p><h3 id="四、后续"><a href="#四、后续" class="headerlink" title="四、后续"></a>四、后续</h3><p>修改JVM的配置，将最大堆内存设置为<code>-Xmx=24g</code>，重启服务运行一段时候后发现CPU负载迅速降了下来，并一直低于线上服务的负载。</p><p><img src="https://i.loli.net/2018/12/06/5c08d1312b7aa.png" alt="load_after.png"></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>1 有关JVM调优相关的可以参考这一系列博客，写的很详尽：<a href="https://www.cnblogs.com/wyb628/p/8566337.html" target="_blank" rel="noopener">Java内存泄露分析系列</a>。</p><p>2 这次问题解决也是凑巧去看了一眼JVM参数，本身GC回收具体什么地方占用了CPU，迫于时间关系实际上没有准确定位到，后面再研究吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在进行接口服务优化，前面对处理大量数据的线程进行了优化，具体见：&lt;a href=&quot;https://f8f-1bearcat.github.io/2018/12/06/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1CPU%E8%B4%9F%E8%BD%BD%E9%AB%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%EF%BC%88%E4%B8%80%EF%BC%89/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;线上服务CPU负载高问题排查（一）&lt;/a&gt; 。当优化后的版本部署到灰度服务器上时，原以为CPU占用率会明显地降低，然而事实却狠狠地打了脸，非但该服务的CPU占用及负载没有降低，反而远远差于上次优化之前版本及线上的服务。是优化方向错了，还是引入了新的问题？&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Netty源码之writeAndFlush()流程与异步</title>
    <link href="http://yoursite.com/2018/12/06/Netty%E6%BA%90%E7%A0%81%E4%B9%8BwriteAndFlush()%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%BC%82%E6%AD%A5/"/>
    <id>http://yoursite.com/2018/12/06/Netty源码之writeAndFlush()流程与异步/</id>
    <published>2018-12-06T01:14:11.376Z</published>
    <updated>2018-12-06T05:39:23.734Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf21c6726a92.png" alt="netty.png"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>挖坑…</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf21c6726a92.png&quot; alt=&quot;netty.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;挖坑…&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Linux之sed用法</title>
    <link href="http://yoursite.com/2018/12/05/Linux%E4%B9%8Bsed%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2018/12/05/Linux之sed用法/</id>
    <published>2018-12-05T01:33:22.380Z</published>
    <updated>2019-01-28T07:50:04.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Linux sed命令是利用script来处理、编辑文本文件。</p><a id="more"></a><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>sed [OPTION]... {script-only-if-no-other-script} [input-file]...</code></p><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li>-n, –quiet, –silent<br>​                 suppress automatic printing of pattern space</li><li>-e script, –expression=script<br>​                 add the script to the commands to be executed</li><li>-f script-file, –file=script-file<br>​                 add the contents of script-file to the commands to be executed<br> –follow-symlinks<br>​                 follow symlinks when processing in place; hard links<br>​                 will still be broken.</li><li>-i[SUFFIX], –in-place[=SUFFIX]<br>​                 edit files in place (makes backup if extension supplied).<br>​                 The default operation mode is to break symbolic and hard links.<br>​                 This can be changed with –follow-symlinks and –copy.</li><li>-c, –copy<br>​                 use copy instead of rename when shuffling files in -i mode.<br>​                 While this will avoid breaking links (symbolic or hard), the<br>​                 resulting editing operation is not atomic.  This is rarely<br>​                 the desired mode; –follow-symlinks is usually enough, and<br>​                 it is both faster and more secure.</li><li>-l N, –line-length=N<br>​                 specify the desired line-wrap length for the `l’ command<br>  –posix<br>​                 disable all GNU extensions.</li><li>-r, –regexp-extended<br>​                 use extended regular expressions in the script.</li><li>-s, –separate<br>​                 consider files as separate rather than as a single continuous<br>​                 long stream.</li><li>-u, –unbuffered<br>​                 load minimal amounts of data from the input files and flush<br>​                 the output buffers more often</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>查看某段时间的服务日志：<code>sed -n &#39;/1970-01-01 01:01/,$p&#39; 1.log |more</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Linux sed命令是利用script来处理、编辑文本文件。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>浅谈OGNL表达式</title>
    <link href="http://yoursite.com/2018/11/30/%E6%B5%85%E8%B0%88OGNL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/11/30/浅谈OGNL表达式/</id>
    <published>2018-11-30T02:29:36.063Z</published>
    <updated>2018-11-30T02:33:36.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>挖坑…</p><p>OGNL特殊用法请参考：<a href="https://github.com/alibaba/arthas/issues/71" target="_blank" rel="noopener">https://github.com/alibaba/arthas/issues/71</a><br>OGNL表达式官方指南：<a href="https://commons.apache.org/proper/commons-ognl/language-guide.html" target="_blank" rel="noopener">https://commons.apache.org/proper/commons-ognl/language-guide.html</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;挖坑…&lt;/p&gt;
&lt;p&gt;OGNL特殊用法请参考：&lt;a href=&quot;https://github.com/alibaba/arthas/issues/71&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/alibaba/arthas/issues/71&lt;/a&gt;&lt;br&gt;OGNL表达式官方指南：&lt;a href=&quot;https://commons.apache.org/proper/commons-ognl/language-guide.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://commons.apache.org/proper/commons-ognl/language-guide.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="OGNL" scheme="http://yoursite.com/tags/OGNL/"/>
    
  </entry>
  
  <entry>
    <title>Logback以及Log4j2性能测试对比</title>
    <link href="http://yoursite.com/2018/11/28/Logback%E4%BB%A5%E5%8F%8ALog4j2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2018/11/28/Logback以及Log4j2性能测试对比/</id>
    <published>2018-11-28T01:06:32.907Z</published>
    <updated>2018-11-28T01:08:41.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>挖坑…</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;挖坑…&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Logback" scheme="http://yoursite.com/tags/Logback/"/>
    
      <category term="Log4j2" scheme="http://yoursite.com/tags/Log4j2/"/>
    
  </entry>
  
  <entry>
    <title>quartz定时任务时间设置</title>
    <link href="http://yoursite.com/2018/11/28/quartz%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/11/28/quartz定时任务时间设置/</id>
    <published>2018-11-28T01:03:26.828Z</published>
    <updated>2018-11-28T01:04:54.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>挖坑…</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;挖坑…&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Quartz任务调度" scheme="http://yoursite.com/tags/Quartz%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>几种日志框架对比</title>
    <link href="http://yoursite.com/2018/11/21/%E5%87%A0%E7%A7%8D%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2018/11/21/几种日志框架对比/</id>
    <published>2018-11-21T05:47:25.784Z</published>
    <updated>2018-11-21T05:49:47.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>挖坑…</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;挖坑…&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>介绍一款开源Java诊断工具—Arthas</title>
    <link href="http://yoursite.com/2018/11/19/Arthas%E2%80%94%E5%BC%80%E6%BA%90Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/11/19/Arthas—开源Java诊断工具/</id>
    <published>2018-11-19T06:48:50.651Z</published>
    <updated>2019-01-28T08:43:18.477Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf2661ea96ae.png" alt="arthas.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Arthas（阿尔萨斯）是阿里巴巴开源的 Java 诊断工具，深受开发者喜爱。</p><p>当你遇到以下类似问题而束手无策时，Arthas 可以帮助你解决：</p><pre><code>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！是否有一个全局视角来查看系统的运行状况？有什么办法可以监控到JVM的实时运行状态？</code></pre><p>Arthas 采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。</p><a id="more"></a><h2 id="常用命令示例"><a href="#常用命令示例" class="headerlink" title="常用命令示例"></a>常用命令示例</h2><ul><li>实时显示当前服务的线程、JVM等信息：</li></ul><p><code>dashboard</code></p><ul><li>在指定采样时间间隔<code>i</code>内展示当前最忙的前<code>n</code>个线程并打印堆栈：</li></ul><p><code>thread -n 10 -i 1000</code></p><ul><li>展示方法内部调用路径，并输出方法路径上的每个节点上耗时，跟据调用耗时过滤：</li></ul><p><code>trace [class-pattern] [method-pattern] #cost&gt;100</code></p><ul><li>方法执行数据观测：</li></ul><p><code>watch [class-pattern] [method-pattern] returnObj</code><br><code>watch [class-pattern] getInstance &quot;returnObj.getReqList().size()&quot;</code></p><ul><li>反编译指定已加载类的源码：</li></ul><p><code>jad [class-pattern]</code></p><ul><li>打印出类的Field信息：</li></ul><p><code>sc -df io.netty.util.internal.PlatformDependent</code></p><p>安装和更多命令列表参见官方文档：<a href="https://alibaba.github.io/arthas/index.html" target="_blank" rel="noopener">Arthas 用户文档 — Arthas 3.0.5-SNAPSHOT 文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf2661ea96ae.png&quot; alt=&quot;arthas.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Arthas（阿尔萨斯）是阿里巴巴开源的 Java 诊断工具，深受开发者喜爱。&lt;/p&gt;
&lt;p&gt;当你遇到以下类似问题而束手无策时，Arthas 可以帮助你解决：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？

我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？

遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？

线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！

是否有一个全局视角来查看系统的运行状况？

有什么办法可以监控到JVM的实时运行状态？
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Arthas 采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="开发工具" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
      <category term="alibaba" scheme="http://yoursite.com/tags/alibaba/"/>
    
  </entry>
  
  <entry>
    <title>Netty的OutOfDirectMemoryError问题</title>
    <link href="http://yoursite.com/2018/11/19/Netty%E7%9A%84OutOfDirectMemoryError%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/11/19/Netty的OutOfDirectMemoryError问题/</id>
    <published>2018-11-19T05:47:24.351Z</published>
    <updated>2018-11-19T05:48:30.883Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf21c6726a92.png" alt="netty.png"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>挖坑…</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf21c6726a92.png&quot; alt=&quot;netty.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;挖坑…&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Netty引用计数对象</title>
    <link href="http://yoursite.com/2018/11/19/Netty%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/11/19/Netty引用计数对象/</id>
    <published>2018-11-19T05:42:35.208Z</published>
    <updated>2019-01-28T09:16:53.831Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf21c6726a92.png" alt="netty.png"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>Netty学习笔记</p><a id="more"></a><p>官方文档：<a href="https://netty.io/wiki/reference-counted-objects.html" target="_blank" rel="noopener">https://netty.io/wiki/reference-counted-objects.html</a></p><p>文档翻译：<a href="https://damacheng009.iteye.com/blog/2013657" target="_blank" rel="noopener">https://damacheng009.iteye.com/blog/2013657</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf21c6726a92.png&quot; alt=&quot;netty.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;Netty学习笔记&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>线上服务性能调优：高内存占用</title>
    <link href="http://yoursite.com/2018/11/16/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%EF%BC%9A%E9%AB%98%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8/"/>
    <id>http://yoursite.com/2018/11/16/线上服务性能调优：高内存占用/</id>
    <published>2018-11-16T09:04:30.994Z</published>
    <updated>2018-11-21T08:02:12.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><a id="more"></a><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>线上服务性能调优：高CPU占用</title>
    <link href="http://yoursite.com/2018/11/16/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%EF%BC%9A%E9%AB%98CPU%E5%8D%A0%E7%94%A8/"/>
    <id>http://yoursite.com/2018/11/16/线上服务性能调优：高CPU占用/</id>
    <published>2018-11-16T03:28:20.479Z</published>
    <updated>2018-11-21T08:02:18.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><a id="more"></a><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>Netty直接内存泄露</title>
    <link href="http://yoursite.com/2018/11/16/Netty%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    <id>http://yoursite.com/2018/11/16/Netty直接内存泄露/</id>
    <published>2018-11-16T02:50:20.893Z</published>
    <updated>2018-12-06T07:28:47.632Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf21c6726a92.png" alt="netty.png"></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在做接口服务内存和CPU优化，使用Netty版本为<code>netty-all-4.1.29.Final</code>，对于行情数据我们采用Netty的直接内存进行存储，Netty的几种<code>ByteBuf</code>介绍见：<a href="https://f8f-1bearcat.github.io/2018/11/19/Netty%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%AF%B9%E8%B1%A1/" target="_blank" rel="noopener">Netty常见内存结构</a> ，当前我们使用的是<code>PooledByteBufAllocator</code>，所以每次内存使用完毕后都需要通过<code>release()</code>方法手动回收直接内存。</p><p>使用Netty的直接内存有点与C类似，自己malloc的对象需要自己free；但与C不同的是，在内有引用计数器，外有Java的GC的场景下，Netty直接内存的使用更为复杂，对内存的使用稍有纰漏就会导致整个服务挂掉。在一次优化版本中，就出现了很严重的Netty直接内存泄露的问题。<br><a id="more"></a></p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>前一天盘后我们部署了某个优化版本到灰度服务器上，第二天行情数据下发后伴随着用户量增长，接口服务在很短的时间内不可用。</p><p>通过运维平台调取了当天该服务器上的内存使用情况：</p><p><img src="https://i.loli.net/2018/11/19/5bf2700185b45.png" alt="SZVPC内存使用情况.png"></p><p>可以发现在上午9:00~11:00时间段内，接口服务多次挂掉后自动重启，中午版本回退后服务才恢复正常。</p><h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><h3 id="一、查看系统日志"><a href="#一、查看系统日志" class="headerlink" title="一、查看系统日志"></a>一、查看系统日志</h3><p>首先查看服务异常时间段内服务器上的日志，可以发现在短时间内日志打印了非常多的直接内存分配异常<code>OutOfDirectMemoryError</code>：</p><p><img src="https://i.loli.net/2018/11/19/5bf28a9a2d455.png" alt="直接内存分配异常.png"></p><p>日志显示直接内存Direct Memory不够用了，该服务器上配置了堆内存12G，直接内存18G，与异常中打印的最大可分配直接内存相匹配；</p><p><img src="https://i.loli.net/2018/11/19/5bf2701a7dc76.png" alt="内存配置.png"></p><p>根据之前的内存使用情况可以断定在服务正常状态下，18G直接内存是能满足接口服务使用场景的，那就可以断定单纯地在配置中增大可分配直接内存的大小不能解决问题。</p><h3 id="二、确认异常抛出原因"><a href="#二、确认异常抛出原因" class="headerlink" title="二、确认异常抛出原因"></a>二、确认异常抛出原因</h3><p>通过上面OOM异常日志，可以追踪到<code>PlatformDependent.java</code>的<code>incrementMemoryCounter(int capacity)</code>方法。</p><p><img src="https://i.loli.net/2018/11/19/5bf21b9878c32.png" alt=""></p><p>我们可以看到这个方法是Netty自身对已使用直接内存进行计数，当计数器<code>DIRECT_MEMORY_COUNTER</code>已使用内存大于直接内存上限<code>DIRECT_MEMORY_LIMIT</code>时，抛出一个OutOfDirectMemoryError异常，这个直接内存上限即上面我们在配置文件中通过<code>-XX:MaxDirectMemorySize</code>配置的。关于Netty的OutOfDirectMemoryError问题见：<a href="https://f8f-1bearcat.github.io/2018/11/19/Netty%E7%9A%84OutOfDirectMemoryError%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">关于Netty的OutOfDirectMemoryError问题</a> 。</p><p>无法分配直接内存无非是以下两种情况导致的：</p><ol><li>分配的直接内存最终没有<code>release()</code>掉，使直接内存不断被分配使用而没有回收掉，最终达到可用上限产生内存泄露；</li><li>因用户网络异常或者传输的数据量过大等问题，使得直接内存的释放回收速度小于其分配的速度，最终无内存可分配抛出OOM。</li></ol><p>如果是前者，就需要找出没有正确<code>release()</code>的代码进行修改；如果是后者，则需要在write的时候，添加流控措施，避免到达内存限制。</p><h3 id="三、Netty内存泄漏的监测机制"><a href="#三、Netty内存泄漏的监测机制" class="headerlink" title="三、Netty内存泄漏的监测机制"></a>三、Netty内存泄漏的监测机制</h3><p>Netty本身提供了内存泄漏的监测机制（详细介绍见：<a href="https://f8f-1bearcat.github.io/2018/11/19/Netty%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%AF%B9%E8%B1%A1/" target="_blank" rel="noopener">Netty引用计数对象</a>），我们可以通过在配置文件中配置<code>-Dio.netty.leakDetectionLevel</code>对分配的ByteBuf进行跟踪。</p><p><img src="https://i.loli.net/2018/11/19/5bf27013c719b.png" alt="leakDetection.png"></p><p>如果服务有内存泄露，则会打印如下日志：</p><blockquote><p>LEAK: ByteBuf.release() was not called before it’s garbage-collected. Enable advanced leak reporting to find out where the leak occurred. To enable advanced leak reporting, specify the JVM option ‘-Dio.netty.leakDetectionLevel=paranoid’ or call ResourceLeakDetector .setLevel()</p></blockquote><p>因为是功能测试，所以在异常服务上，我将监测的级别配置为paranoid，运行一段时间后查看服务日志，发现并未有<strong>LEAK </strong>日志打印，看来通过Netty自身的监测机制定位问题这条路走不通。</p><h3 id="四、Arthas查看直接内存使用情况"><a href="#四、Arthas查看直接内存使用情况" class="headerlink" title="四、Arthas查看直接内存使用情况"></a>四、Arthas查看直接内存使用情况</h3><p>我们知道服务是因为已使用直接内存达到了可分配上限才挂掉的，那通过查看服务器上<code>DIRECT_MEMORY_COUNTER</code>的大小能不能发现问题呢？这时候不得不提到Java诊断神器Arthas了（详细介绍见：<a href="https://f8f-1bearcat.github.io/2018/11/19/Arthas%E2%80%94%E5%BC%80%E6%BA%90Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/" target="_blank" rel="noopener">介绍一款开源Java诊断工具—Arthas</a> ）。</p><p>通过Arthas进入到当前服务进程，执行sc命令来查看<code>PlatformDependent.java</code>类的成员变量：</p><blockquote><p>sc -df io.netty.util.internal.PlatformDependent</p></blockquote><p>可以看到命令执行后当前时间的<strong>已分配直接内存</strong>和<strong>可分配直接内存上限</strong>两个参数的值：</p><p><img src="https://i.loli.net/2018/11/19/5bf26527165f9.png" alt="directmemory.png"></p><p>使用Arthas来查看确实简单便捷，但是因为只能查看一个时间点的变量的值（<del>也可能是我的打开方式不对</del>），对我们解决问题帮助不是很大，所以还是用笨办法吧，即通过起一个线程来定时打印直接内存的值。</p><h3 id="五、日志打印直接内存"><a href="#五、日志打印直接内存" class="headerlink" title="五、日志打印直接内存"></a>五、日志打印直接内存</h3><h4 id="直接内存定时打印"><a href="#直接内存定时打印" class="headerlink" title="直接内存定时打印"></a>直接内存定时打印</h4><p>这里我写了一个线程，每两秒将通过反射获取的<code>DIRECT_MEMORY_COUNTER</code>参数的值在日志中实时打印出来，方便我们调试。</p><p><img src="https://i.loli.net/2018/11/19/5bf26713a10a9.png" alt="直接内存打印.png"></p><h4 id="模拟客户端进行压力测试"><a href="#模拟客户端进行压力测试" class="headerlink" title="模拟客户端进行压力测试"></a>模拟客户端进行压力测试</h4><p>为了能明显地看到内存分配的数值变化，这里我通过编写TestMain模拟客户端用户来请求接口服务数据；</p><p><img src="https://i.loli.net/2018/11/19/5bf269a675904.png" alt="压力测试.png"></p><p>并设置模拟用户量为200，将有问题的服务部署到开发服务器上进行压力测试。</p><p><img src="https://i.loli.net/2018/11/19/5bf2699bdaf27.png" alt="压力测试用户.png"></p><h4 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h4><p>首先将开发服务器上接口服务启动，这是当前服务的端口连接数为0，即没有用户访问，这时服务已使用的直接内存维持在一个稳定的值256MB（如下图前几条日志所示）；当把压力测试程序启动，随着用户连接数涨到200，服务已使用的直接内存迅速飙升（如下图选中日志所示），一直达到可用内存上限18G，最终导致服务不可用，整个用时不到5分钟！</p><p><img src="https://i.loli.net/2018/11/19/5bf2746f146fc.png" alt="内存日志2.png"></p><p>到这里我们可以得出结论，本次内存泄露与接口服务处理上游数据的过程无关，而是在处理用户请求并返回数据的过程中抛出的。</p><p>到这里问题的定位范围进一步缩小，我还是采用了虽然繁琐但是直接有效的方法：范围从大到小地对请求返回数据过程中分配及使用直接内存的代码块进行注释，并部署到开发服务器上进行测试。</p><p>其中的具体操作过程略去不表，其实结果证明这个方法确实是很有效的，我只重新部署哦了两次服务就找到了问题代码：</p><p><img src="https://i.loli.net/2018/11/19/5bf280fb7fd1e.png" alt="callback.png"></p><p>当我把上图选中代码注释掉后，再进行压力测试接口服务已使用直接内存的值维持在256MB不再增长，如下图所示：</p><p><img src="https://i.loli.net/2018/11/19/5bf272fdb0bbf.png" alt="内存日志1.png"></p><p>进入到<code>callback()</code>方法最终修改了下图所示代码，对已分配但位使用的直接内存进行<code>release()</code>回收释放，重新部署，测试通过。</p><p><img src="https://i.loli.net/2018/11/19/5bf280fb09e34.png" alt="代码修改.png"></p><h3 id="六、后续"><a href="#六、后续" class="headerlink" title="六、后续"></a>六、后续</h3><p>我提交了代码盘后通过CI重新发布到之前出现异常的服务器上，几个交易日过去了，问题没有再出现。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>1.对于Netty直接内存问题，我们可以通过三种手段来定位问题：Netty自身的内存泄露监测机制；Arthas等第三方工具；发射获取并打印直接内存数值。</p><p>2.这次问题的出现是只在ByteBuf使用之后进行了回收，没有考虑到在异常情况下ByteBuf没有成功传递到下一个Hanlder（<del>其实考虑到了，只不过疏忽了这个分支</del>），这时也要把分配了没有使用的直接内存进行回收。</p><p>3.至于为什么Netty自身的监测机制没有打印LEAK日志，后面我会再研究一下。</p><p>最后希望大家都能：</p><p><img src="https://i.loli.net/2018/11/19/5bf28b9a947e9.png" alt="表情.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf21c6726a92.png&quot; alt=&quot;netty.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在做接口服务内存和CPU优化，使用Netty版本为&lt;code&gt;netty-all-4.1.29.Final&lt;/code&gt;，对于行情数据我们采用Netty的直接内存进行存储，Netty的几种&lt;code&gt;ByteBuf&lt;/code&gt;介绍见：&lt;a href=&quot;https://f8f-1bearcat.github.io/2018/11/19/Netty%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%AF%B9%E8%B1%A1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Netty常见内存结构&lt;/a&gt; ，当前我们使用的是&lt;code&gt;PooledByteBufAllocator&lt;/code&gt;，所以每次内存使用完毕后都需要通过&lt;code&gt;release()&lt;/code&gt;方法手动回收直接内存。&lt;/p&gt;
&lt;p&gt;使用Netty的直接内存有点与C类似，自己malloc的对象需要自己free；但与C不同的是，在内有引用计数器，外有Java的GC的场景下，Netty直接内存的使用更为复杂，对内存的使用稍有纰漏就会导致整个服务挂掉。在一次优化版本中，就出现了很严重的Netty直接内存泄露的问题。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java(10)</title>
    <link href="http://yoursite.com/2018/11/15/Effective%20Java(10)/"/>
    <id>http://yoursite.com/2018/11/15/Effective Java(10)/</id>
    <published>2018-11-15T09:32:56.881Z</published>
    <updated>2018-11-19T05:34:25.830Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf24a39023ab.jpg" alt="effective-java.jpg"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>Effective Java第10章 并发 学习笔记</p><a id="more"></a><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="66-同步访问共享的可变数据"><a href="#66-同步访问共享的可变数据" class="headerlink" title="66 同步访问共享的可变数据"></a>66 同步访问共享的可变数据</h3><ul><li>程序不会终止，后台线程永远在循环。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> stopRequested;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">Thread </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf24a39023ab.jpg&quot; alt=&quot;effective-java.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;Effective Java第10章 并发 学习笔记&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Effective Java" scheme="http://yoursite.com/tags/Effective-Java/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java(8)</title>
    <link href="http://yoursite.com/2018/11/15/Effective%20Java(8)/"/>
    <id>http://yoursite.com/2018/11/15/Effective Java(8)/</id>
    <published>2018-11-15T09:20:20.664Z</published>
    <updated>2018-11-19T05:36:25.968Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf24a39023ab.jpg" alt="effective-java.jpg"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>Effective Java第8章 通用程序设计 学习笔记</p><a id="more"></a><h2 id="通用程序设计"><a href="#通用程序设计" class="headerlink" title="通用程序设计"></a>通用程序设计</h2><h3 id="45-将局部变量作用域最小化"><a href="#45-将局部变量作用域最小化" class="headerlink" title="45 将局部变量作用域最小化"></a>45 将局部变量作用域最小化</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>增强代码的<strong>可读性</strong>和<strong>维护性</strong>，并降低 <strong>出错</strong>的可能性。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li>在局部变量第一次使用的地方声明。</li><li>几乎每个局部变量的声明都应该包含一个初始化表达式。</li><li>使方法小而集中</li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><ul><li><strong>try-catch</strong></li><li><strong>for</strong>循环与<strong>while</strong>循环对比</li></ul><h3 id="46-for-each循环优先于传统的for循环"><a href="#46-for-each循环优先于传统的for循环" class="headerlink" title="46 for-each循环优先于传统的for循环"></a>46 for-each循环优先于传统的for循环</h3><h4 id="for循环缺点"><a href="#for循环缺点" class="headerlink" title="for循环缺点"></a>for循环缺点</h4><ul><li><p><strong>迭代器</strong>和<strong>索引变量</strong>在每个循环中出现三次，其中有两次很容易出错，且编译器不能发现错误。</p><h4 id="for-each循环的优点"><a href="#for-each循环的优点" class="headerlink" title="for-each循环的优点"></a>for-each循环的优点</h4></li><li><p>通过完全隐藏迭代器或者索引变量，避免了混乱或者出错的很可能。</p></li><li>利用<code>for-each</code>循环不会有性能损失，在某些情况下，还稍有性能优势。因其对数组索引的边界值只计算一次。</li><li><p>在对多个集合进行嵌套式迭代时，<code>for-each</code>循环能避免<code>for</code>循环可能出现的问题，同时兼顾代码简洁。  </p><blockquote><p>传统for循环嵌套迭代</p></blockquote><pre><code>enum Face {ONE, TWO, THREE, FOUR, FIVE, SIX}  ...Collection&lt;Face&gt; faces = Array.asList(Face.values());for (Iterator&lt;Face&gt; i = faces.iterator(); i.hasNext; )    for (Iterator&lt;Face&gt; j = faces.iterator(); j.hasNext; )        Sysytem.out.println(i.next() + &quot; &quot; + j.next());</code></pre><blockquote><p>for-each嵌套迭代</p></blockquote><pre><code>for (Suit suit : suits)    for (Rank rank : ranks)        deck.add (new Card (suit, rank));</code></pre></li><li><code>for-each</code>循环不仅能遍历集合和数组，还能遍历任何实现<code>Iterable</code>接口的对象。<h4 id="有三种常见的情况无法使用for-each循环"><a href="#有三种常见的情况无法使用for-each循环" class="headerlink" title="有三种常见的情况无法使用for-each循环"></a>有三种常见的情况无法使用for-each循环</h4></li></ul><ol><li>过滤——需要遍历集合，并删除选定的元素。</li><li>转换——需要遍历列表或数组，并取代它部分或全部的元素值。</li><li>平行迭代——需要并行的遍历多个集合。</li></ol><h3 id="47-了解和使用类库"><a href="#47-了解和使用类库" class="headerlink" title="47 了解和使用类库"></a>47 了解和使用类库</h3><h4 id="类库中值得注意的两个工具"><a href="#类库中值得注意的两个工具" class="headerlink" title="类库中值得注意的两个工具"></a>类库中值得注意的两个工具</h4><ul><li><strong>java.util</strong>包中Collections Framework（集合框架）</li><li><strong>java.util.concurrent</strong>包</li></ul><h3 id="48-如果需要精确的答案，请避免使用float和double"><a href="#48-如果需要精确的答案，请避免使用float和double" class="headerlink" title="48 如果需要精确的答案，请避免使用float和double"></a>48 如果需要精确的答案，请避免使用float和double</h3><ul><li><strong>float</strong> 和 <strong>double</strong> 执行<em>二进制浮点运算</em>，没有提供完全精确的结果，尤其不适合用于货币计算。</li><li><p>使用<strong>BigDecimal</strong>、<strong>int</strong> 或者 <strong>long</strong>进行货币计算。</p><blockquote><ul><li>使用<strong>BigDecimal</strong>缺点：与基本运算类型相比，不方便，而且很慢；优点： 系统记录十进制小数点，允许完全控制舍入，数值超过18位数字。</li><li>选用<strong>int</strong>或者 <strong>long</strong>取决于所涉及数值的大小，同时自己处理十进制小数点。数值没有超过9位数字用 <strong>int</strong>，数值没有超过18位数字用<strong>float</strong>。</li></ul></blockquote></li></ul><h3 id="49-基本类型优于装箱基本类型"><a href="#49-基本类型优于装箱基本类型" class="headerlink" title="49 基本类型优于装箱基本类型"></a>49 基本类型优于装箱基本类型</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><blockquote><p>举例：int，double，boolean</p></blockquote><h4 id="装箱基本类型"><a href="#装箱基本类型" class="headerlink" title="装箱基本类型"></a>装箱基本类型</h4><blockquote><p>举例：Integer，Double，Boolean</p></blockquote><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>基本类型只有值，而装箱基本类型则具有与它们的值不同的同一性（对象引用）；</li><li>基本类型只有功能完备的值，而每个装箱基本类型还有个非功能值：<strong>null</strong>；</li><li>基本类型通常比装箱基本类型更节省时间和空间。</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><p>对装箱基本类型使用 <strong>==</strong> 操作符几乎总是错误的； </p><blockquote><p>比较器错误地返回1；  </p></blockquote><pre><code>public int compare(Integer first, Interger second) {    return first &lt; second ? -1 : (first == sencond ? 0 : 1);}</code></pre></li><li><p>当一项操作中混合使用基本类型与装箱基本类型时，装箱基本类型会自动拆箱。如果<strong>null</strong>对象引用被拆箱，则抛出NullPointerException异常。</p><blockquote><p>抛出NullPointerException异常</p></blockquote><pre><code>static Integer i;public static void main(String[] args) {    if (i == 42)        System.out.println(&quot;123&quot;);}</code></pre></li><li><p>循环中装箱基本类型的变量被反复装箱和拆箱，产生严重性能问题。</p><pre><code>Long sum = 0L;</code></pre><p>  ​    for (long i = 0; i &lt; Integer.MAX_VALUE; i++) {<br>  ​        sum += i;<br>  ​    }</p></li></ul><h3 id="50-如果其他类型更适合，则尽量避免使用字符串"><a href="#50-如果其他类型更适合，则尽量避免使用字符串" class="headerlink" title="50 如果其他类型更适合，则尽量避免使用字符串"></a>50 如果其他类型更适合，则尽量避免使用字符串</h3><h4 id="不应该使用字符串的情形"><a href="#不应该使用字符串的情形" class="headerlink" title="不应该使用字符串的情形"></a>不应该使用字符串的情形</h4><ul><li>字符串不适合代替其他的值类型</li><li>字符串不适合代替枚举类型</li><li>字符串不适合代替聚集类型</li><li>字符串不适合代替能力表（capabilities）</li></ul><h3 id="51-当心字符串连接的性能"><a href="#51-当心字符串连接的性能" class="headerlink" title="51 当心字符串连接的性能"></a>51 当心字符串连接的性能</h3><p>由于字符串不可变，在连接字符串时，它们的内容都要被拷贝。如果数量巨大，应使用<strong>StringBuilder</strong>的 <strong>append</strong>方法。</p><h3 id="52-通过接口引用对象"><a href="#52-通过接口引用对象" class="headerlink" title="52 通过接口引用对象"></a>52 通过接口引用对象</h3><ul><li><p>优先使用接口而不是类来引用对象。如果有合适的接口类型存在，参数、返回值、变量和域都应该用接口类型进声明。 </p><blockquote><p>里氏替换原则</p></blockquote><pre><code>//通过接口引用对象 List&lt;String&gt; lists = new ArrayList&lt;String&gt;(); //通过类引用对象 ×ArrayList&lt;String&gt; lists = new ArrayList&lt;String&gt;();</code></pre></li><li>如果没有合适的接口存在，用类来引用对象。<ul><li>情形一  <strong>值类</strong>，例如<code>String</code>和<code>BigInteger</code>。值类通常是final的，很少会用多个实现，并且很少有对应的接口。</li><li>情形二  对象属于框架，框架的基本类型为类不是接口，例如<code>java.util.TimerTask</code>。使用相关的<strong>基类</strong>引用对象，不用实现类。</li><li>情形三  类实现了接口，但提供了接口中不存在的额外方法，例如<code>LinkedHashMap</code>。</li></ul></li></ul><h3 id="53-接口优于反射机制"><a href="#53-接口优于反射机制" class="headerlink" title="53 接口优于反射机制"></a>53 接口优于反射机制</h3><h4 id="反射机制的弊端"><a href="#反射机制的弊端" class="headerlink" title="反射机制的弊端"></a>反射机制的弊端</h4><ul><li>丧失了编译时类型检查的好处。</li><li>执行反射访问的代码冗长。</li><li>性能损失。</li></ul><h3 id="54-55-56-待续"><a href="#54-55-56-待续" class="headerlink" title="54 55 56 待续"></a>54 55 56 待续</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf24a39023ab.jpg&quot; alt=&quot;effective-java.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;Effective Java第8章 通用程序设计 学习笔记&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Effective Java" scheme="http://yoursite.com/tags/Effective-Java/"/>
    
  </entry>
  
</feed>
