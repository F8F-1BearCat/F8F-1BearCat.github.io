<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Magical Cat</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-25T08:46:37.915Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>F8F-1BearCat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Shenandoah GC官方文档（译）</title>
    <link href="http://yoursite.com/2019/06/21/Shenandoah%20GC%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E8%AF%91%EF%BC%89/"/>
    <id>http://yoursite.com/2019/06/21/Shenandoah GC官方文档（译）/</id>
    <published>2019-06-21T05:53:19.964Z</published>
    <updated>2019-06-25T08:46:37.915Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/03/28/5c9c829850beb.jpg" alt="OpenJDK.jpg"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>Shenandoah是低停顿时间的垃圾收集器，通过与正在运行的Java程序并发地执行更多垃圾收集工作来缩短GC停顿时间。Shenandoah并发地完成大部分GC工作，包括并发整理，这意味着它的停顿时间不再与堆的大小成正比。收集200GB堆或2GB堆的垃圾应具有类似的低停顿行为。</p><p>本文对Shenandoah GC官方文档进行简单翻译，方便对该垃圾收集器的使用，原文参见： <a href="https://wiki.openjdk.java.net/display/shenandoah/Main" target="_blank" rel="noopener">Shenandoah wiki page</a>。</p><a id="more"></a><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>Shenandoah是区域化的收集器，它将堆保持为region集合。</p><p>常规的Shenandoah GC周期如下所示：</p><p><img src="https://cr.openjdk.java.net/~shade/shenandoah/shenandoah-gc-cycle.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GC(3) Pause Init Mark 0.771ms</span><br><span class="line">GC(3) Concurrent marking 76480M-&gt;77212M(102400M) 633.213ms</span><br><span class="line">GC(3) Pause Final Mark 1.821ms</span><br><span class="line">GC(3) Concurrent cleanup 77224M-&gt;66592M(102400M) 3.112ms</span><br><span class="line">GC(3) Concurrent evacuation 66592M-&gt;75640M(102400M) 405.312ms</span><br><span class="line">GC(3) Pause Init Update Refs 0.084ms</span><br><span class="line">GC(3) Concurrent update references  75700M-&gt;76424M(102400M) 354.341ms</span><br><span class="line">GC(3) Pause Final Update Refs 0.409ms</span><br><span class="line">GC(3) Concurrent cleanup 76244M-&gt;56620M(102400M) 12.242ms</span><br></pre></td></tr></table></figure><p>上面的阶段大致如下：</p><ol><li><strong>Init Mark（初始标记）</strong> ：启动并发标记。为并发标记阶段准备堆和应用程序线程，然后扫描根集。这是周期中第一次停顿，主要是对根集的扫描消耗时间。因此，停顿持续时间取决于根集大小。</li><li><strong>Concurrent Marking（并发标记）</strong> ：遍历堆，并追踪可达对象。此阶段与应用程序一起运行，其持续时间取决于堆中存活对象的数量和对象图的结构。由于应用程序可以在此阶段自由分配新数据，因此在并发标记期间堆占用率会上升。</li><li><strong>Final Mark（最终标记）</strong> ：通过排空所有挂起的标记/更新队列并重新扫描根集来完成并发标记。它还通过确定要疏散的region（collection set），预先疏散一些根来初始化疏散，并且通常为下一阶段准备运行时间。这项工作的一部分可以在<strong>Concurrent precleaning</strong> （并发预清理）阶段并发完成。这是周期中的第二次停顿，最主要的时间消耗方是排空队列和扫描根集的过程。</li><li><strong>Concurrent Cleanup（并发清理）</strong> ：回收当前垃圾region——即在并发标记之后检测到的没有存活对象的region。</li><li><strong>Concurrent Evacuation（并发疏散）</strong> ：将对象从collection set复制到其他region。<em>这是与其他OpenJDK GC的主要区别。</em>此阶段再次与应用程序一起运行，因此应用程序可以自由分配。其持续时间取决于该GC周期选择的collection set的大小。</li><li><strong>Init Update Refs（初始更新引用）</strong> ：初始化更新引用阶段。除了确保所有GC和应用程序线程都已完成疏散，然后为下一阶段准备GC之外，它几乎没有任何作用。这是周期中的第三次停顿，也是最短的停顿。</li><li><strong>Concurrent Update References（并发更新引用）</strong> ：遍历堆，并更新对并发疏散极端移动对象的引用。 <em>这是与其他OpenJDK GC的主要区别。</em>它的持续时间取决于堆中的对象数，但不取决于对象图结构，因为它会线性扫描堆。此阶段与应用程序同时运行。</li><li><strong>Final Update Refs（最终更新引用）</strong> ：通过重新更新现有根集来完成更新引用阶段。它还从collection set中回收region，因为现在堆没有对它们的（陈旧）对象的引用。这是周期中的最后一次停顿，其持续时间取决于根集的大小。</li><li><strong>Concurrent Cleanup（并发清理）</strong>：回收collection set region，这些region当前没有引用。</li></ol><h2 id="性能指南和诊断"><a href="#性能指南和诊断" class="headerlink" title="性能指南和诊断"></a>性能指南和诊断</h2><h3 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h3><p><strong>Heap sizes（堆大小）:</strong> 与几乎所有其他GC的性能一样，Shenandoah性能取决于堆大小。当有足够的堆空间能够满足并发阶段运行（参见下面的”<strong>Failure Modes</strong>（失败模式）”部分）时的分配时，它应该能够更好地运行。并发阶段的时间与live data set （LDS）的大小——live data占用的空间——相关。因此，合理的堆大小取决于LDS和工作负载中的分配压力：对于给定的分配速率，较大的LDS需要同比例的较大的堆大小；对于给定的LDS，较大的分配率需要较大的堆大小。对于那些具有很小live data set和适度分配压力的工作负载，1~2GB的堆就表现得不错了。我们通常在各种工作负载上测试4~128GB的堆，其中LDS大小最高达到80％。不要害羞地尝试不同的堆大小来适配你的工作负载。</p><p><strong>Pauses（停顿）:</strong> Shenandoah的停顿行为主要由根集操作主导：扫描和更新根。根集包括：局部变量，嵌入在生成的代码中的引用，interned Strings，类加载器的引用（例如，static final引用），JNI引用，JVMTI引用。拥有更大的根集通常意味着使用Shenandoah会有更长的停顿，除非具体的JDK版本具有同时执行部分工作的能力，并且Shenandoah能够使用它。二阶效应是：a）弱引用处理（在<strong>Final Mark</strong>（最终标记）阶段中发生），但仅适用于那些需要处理的引用； b）类的卸载和其他JDK清理（也会在<strong>Final Mark</strong>（最终标记）阶段时发生）。通过配置控制处理频率（包括完全禁用它）的其他选项和/或修改应用程序以更好地发挥作用，可以减轻这些二阶效应。</p><p><strong>Throughput（吞吐量）:</strong> 由于Shenandoah是并发GC，它在收集周期中使用屏障来维护不变量。这些屏障可能会导致可测量的吞吐量损失。请参阅下面的诊断部分，了解如何剖析那里发生的事情。 一些用户报告说，通过自然地将并发GC工作卸载到备用和其他空闲核心，使由于屏障导致的吞吐量损失得到了弥补；换句话说，在某些情况下，它会提高应用程序+JVM利用率以获得更高的应用程序吞吐量。</p><p>在大多数情况下，停顿时间在0~10ms之内，吞吐量损失在0~15％之内。实际性能数据在很大程度上取决于实际应用，负载文件等。对于没有大量根，弱引用和/或class churn的应用程序，停顿可以在亚毫秒范围内。对于不会使堆变异很多，或者当前编译器对其进行了很好的优化的应用程序，屏障开销可能接近于零。本节的其余部分描述了使用Shenandoah测试和诊断性能行为的方法。如果您怀疑具体用例有什么问题，请告知开发人员。有可能，这是一个可管理的issue或直接的bug。</p><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>基本配置和命令行选项：</p><ul><li><strong>-Xlog:gc</strong> (since JDK 9) or <strong>-verbose:gc</strong> (up to JDK 8)：打印单独的GC计时</li><li><strong>-Xlog:gc+ergo</strong> (since JDK 9) or <strong>-XX:+PrintGCDetails</strong> (up to JDK 8)：打印heuristics 决策，如果有异常值的话，打印异常值。</li><li><strong>-Xlog:gc+stats</strong> (since JDK 9) or <strong>-verbose:gc</strong> (up to JDK 8) ：在运行结束时，在Shenandoah内部计时上打印汇总表。</li></ul><p>在启用日志记录的情况下运行几乎总是一个好主意。该汇总表传达了有关GC性能的重要信息，我们几乎不可避免地要求在性能错误报告中提供一个。Heuristics 日志对于确定GC异常值非常有用。</p><p>其他推荐的JVM选项包括： </p><ul><li><strong>-XX:+AlwaysPreTouch</strong>：将堆页面提交到内存中以减少latency hiccups。</li><li><strong>-Xmx == -Xms</strong> ：使堆不可调整大小可以减少堆管理时的hiccups。对于Shenandoah，-Xms与其他收集器的相关性较低，因为它只将其视为“初始”堆大小（这可能在将来发生变化）。但是，与AlwaysPreTouch相结合，-Xmx == -Xms会在启动时提交所有内存，这可以避免在最终使用内存后出现hiccups。</li><li><strong>-XX:+UseTransparentHugePages</strong>： 这大大提高了大堆的性能。建议在Linux上将<em>/sys/kernel/mm/transparent_hugepage/enabled</em>和<em>/sys/kernel/mm/transparent_hugepage/defrag</em>设置为“<em>madvise</em>”。使用AlwaysPreTouch运行时，init/shutdown会更快，因为它将使用更大的页面进行预处理。它还将在启动时预先支付碎片整理成本。</li><li><strong>-XX:+UseNUMA</strong>：虽然Shenandoah尚未明确支持NUMA，但最好启用此功能以在多插槽主机上启用NUMA交叉存取。与AlwaysPreTouch相结合，它提供了比默认的开箱即用配置更好的性能。</li><li><strong>-XX:-UseBiasedLocking</strong>：在无竞争（偏向）锁定吞吐量与JVM根据需要启用和禁用它们的安全点之间存在权衡。对于面向延迟的工作负载，可以关闭偏向锁定。</li><li><strong>-XX:+DisableExplicitGC</strong>：从用户代码调用System.gc()强制Shenandoah执行STW Full GC，这对GC停顿不利；禁用此选项可以防止库执行此操作。还有一个替代 <strong>-XX:+ExplicitGCInvokesConcurrent</strong>，可以在System.gc()上强制并发循环而不是Full GC，建议您在System.gc()调用确实必要的情况下使用它。</li></ul><h3 id="Heuristics启发式方法"><a href="#Heuristics启发式方法" class="headerlink" title="Heuristics启发式方法"></a>Heuristics启发式方法</h3><p>Heuristics判断Shenandoah何时启动GC周期，以及它认为的该疏散的region。可以使用<strong>-XX:ShenandoahGCHeuristics = <name></name></strong>选择heuristics。一些heuristics方法接受配置参数，这可能有助于更好地为您的用例定制GC操作。可用的heuristics方法包括：</p><ol><li><p><strong>adaptive</strong> (default) 此启发式方法通过观察以前的GC周期，尝试启动下一个GC周期，以便在堆耗尽之前完成操作。</p><p>a. <strong>-XX:ShenandoahInitFreeThreshold=#</strong>： 触发”learning”集合的初始阈值。 </p><p>b. <strong>-XX:ShenandoahMinFreeThreshold=#</strong> ：heuristics无条件触发GC的可用空间阈值。</p><p>c. <strong>-XX:ShenandoahAllocSpikeFactor=#</strong>：要预留多少堆来承担分配峰值。</p><p>d. <strong>-XX:ShenandoahGarbageThreshold=#</strong>：设置region在标记为可收集之前需要包含的垃圾百分比。</p></li><li><p><strong>static</strong> 此启发式决定基于堆占用和分配压力启动GC周期。该启发式配置选项如下：</p><p>a. <strong>-XX:ShenandoahFreeThreshold=#</strong>：设置启动GC周期时的空闲堆的百分比</p><p>b. <strong>-XX:ShenandoahAllocationThreshold=#</strong>：在新GC周期开始之前，设置自上一个GC周期以来分配的内存百分比。</p><p>c. <strong>-XX:ShenandoahGarbageThreshold=#</strong>：设置region在标记为collection之前需要包含的垃圾百分比。</p></li><li><p><strong>compact</strong> 该启发式连续运行GC周期，只要分配发生，就在上一个周期结束后立即开始下一个周期。这种启发式方法通常会产生吞吐量开销，但能提供最快速的空间回收。配置选项：</p><p>a. <strong>-XX:ConcGCThreads=#</strong>：减少并发GC线程的数量，以便为应用程序运行腾出更多空间。</p><p>b. <strong>-XX:ShenandoahAllocationThreshold=#</strong>：在启动另一个周期之前，设置自上一个GC周期以来分配的内存百分比。</p></li><li><p><strong>passive</strong> 这种启发式方法告诉GC完全被动。一旦可用内存耗尽，将触发Full Stop-The-World GC。这种启发式方法用于功能测试，但有时它可用于将GC屏障的性能异常等分（见下文），或计算应用程序中的实际live data size。</p></li><li><p><strong>aggressive</strong> 这种启发式方法告诉GC完全活跃。它将在前一个GC周期结束后立即启动新的GC周期（如“compact”），并且疏散所有存活对象。这种启发式方法对收集器本身的功能测试很有用。它会导致严重的性能损失。</p></li></ol><p>在某些周期中，Update References阶段与Concurrent Marking阶段合并，通过启发式方法裁决。可以使用<strong>-XX:ShenandoahUpdateRefsEarly=[on|off]</strong>强制启用/禁用Update References 。</p><h3 id="失败模式"><a href="#失败模式" class="headerlink" title="失败模式"></a>失败模式</h3><p>像Shenandoah这样的并发GC隐含地依赖于收集速度比应用程序分配速度更快。如果分配压力很高，并且在GC运行时没有足够的空间来分配，则最终会发生 <em>Allocation Failure</em> 。Shenandoah有一个优雅的降级阶梯，有助于在这些情况下幸存下来。阶梯包括：</p><ol><li><em>Pacing</em> (<strong>-XX:+ShenandoahPacing</strong>, enabled by default).当GC运行时，它知道需要完成多少GC工作，以及有多少可用空间可供应用程序使用。当GC进度不够快时，pacer会尝试停止分配线程。在正常情况下，GC收集的速度比应用程序分配的速度快，pacer自然不会停止。注意，pacing会引入通常分析工具中不可见的本地per-thread延迟。这就是为什么停止不是无限期的，它们受<strong>-XX:ShenandoahPacingMaxDelay=#ms</strong>的限制。在最大延时到期后，无论如何都会发生分配。大多数时候，轻度分配的峰值会被pacer吸收。当分配压力非常高时，pacer将无法应对，并且降级将进入下一步。<br><em>Usual latency induced: &lt;10 ms</em></li><li><em>Degenerated GC</em> (<strong>-XX:+ShenandoahDegeneratedGC</strong>, enabled by default). 如果应用程序遇到分配失败，Shenandoah将陷入 stop-the-world 停顿，停止整个应用程序，并在停顿下继续GC周期。Degenerated GC 在stop-the-world 的情况下继续正在进行的“并发”周期。在许多情况下，分配失败发生在已完成大量GC工作、只剩一小部分GC工作等待完成之后，这就是STW停顿通常不大的原因。它将在GC日志、所有常见的监视和心跳线程中打印 GC pause：实际上，引发STW停顿的原因之一是使并发模式的失败可以清楚地被观察到。如果GC周期开始得太晚，或者发生了非常显着的分配峰值，将导致Degenerated GC。退化周期可能比并发周期更快，因为它不会与应用程序竞争资源，而且它使用<strong>-XX:ParallelGCThreads</strong>，而不是<strong>-XX:ConcCGThreads</strong>调整线程池大小。<br><em>Usual latency induced: &lt;100 ms, but can be more, depending on the degeneration point</em></li><li><em>Full GC</em>.如果没有任何帮助，例如当Degenerated GC没有释放足够的内存时，将产生Full GC，并最大化地对堆进行整理。某些场景，比如异常碎片化的堆，以及实现性能bug和overlook，只能由Full GC修复。如果至少有一些内存可用，这个最后阶段的GC能够保证应用程序不会因OOM而失败。<br><em>Usual latency induced: &gt;100 ms, but can be more, especially on a very occupied heap</em></li></ol><p>除了可以打印单个Degenerated GC和Full GC事件的常用GC日志之外，<strong>-Xlog:gc + stats</strong>将在运行结束时显示如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Under allocation pressure, concurrent cycles may cancel, and either continue cycle</span><br><span class="line">under stop-the-world pause or result in stop-the-world Full GC. Increase heap size,</span><br><span class="line">tune GC heuristics, set more aggressive pacing delay, or lower allocation rate</span><br><span class="line">to avoid Degenerated and Full GC cycles.</span><br><span class="line"> </span><br><span class="line"> 4912 successful concurrent GCs</span><br><span class="line">      0 invoked explicitly</span><br><span class="line"> </span><br><span class="line">    3 Degenerated GCs</span><br><span class="line">      3 caused by allocation failure</span><br><span class="line">         3 happened at Update Refs</span><br><span class="line">      0 upgraded to Full GC</span><br><span class="line"> </span><br><span class="line">    0 Full GCs</span><br><span class="line">      0 invoked explicitly</span><br><span class="line">      0 caused by allocation failure</span><br><span class="line">      0 upgraded from Degenerated GC</span><br><span class="line"> </span><br><span class="line">ALLOCATION PACING:</span><br><span class="line"> </span><br><span class="line">Max pacing delay is set for 10 ms.</span><br><span class="line"> </span><br><span class="line">Higher delay would prevent application outpacing the GC, but it will hide the GC latencies</span><br><span class="line">from the STW pause times. Pacing affects the individual threads, and so it would also be</span><br><span class="line">invisible to the usual profiling tools, but would add up to end-to-end application latency.</span><br><span class="line">Raise max pacing delay with care.</span><br><span class="line"> </span><br><span class="line">Actual pacing delays histogram:</span><br><span class="line">      From -         To        Count</span><br><span class="line">      1 ms -       2 ms:          87</span><br><span class="line">      2 ms -       4 ms:         142</span><br><span class="line">      4 ms -       8 ms:         297</span><br><span class="line">      8 ms -      16 ms:        1733</span><br><span class="line">     16 ms -      32 ms:          21</span><br><span class="line">     32 ms -      64 ms:           1</span><br></pre></td></tr></table></figure><p>从这一点来看，如果应用程序遇到以下任何一个降级步骤，可以尝试以下操作：</p><ul><li>为应用程序提供更多堆。满足在GC运行时更多的分配要求。</li><li>减少堆中的live data量。使GC周期更快地运行，并更好地应对分配。</li><li>削减分配压力。例如，减少分配线程的数量，或修复应用程序中的主要allocation hogs。</li><li>调整启发式算法，尽快启动GC周期。如果GC日志已经说GC正在运行连续周期，那么该项操作可能没什么用。</li><li>加快pacing延迟。这将导致更多的线程分配停滞，而不是升级到Degenerated和Full GC——注意，这仍然会给分配线程带来延迟！</li></ul><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>性能分析方法：</p><ol><li><p>一些奇怪的性能行为——如分配失败GC或耗时的最终标记——可以通过heuristics issues解释，你可以使用<strong>-Xlog:gc + ergo</strong>配置。如果你有长时间运行的工作负载，在<a href="http://icedtea.classpath.org/hg/shenandoah-visualizer/" target="_blank" rel="noopener">Shenandoah Visualizer</a>下运行可以让你理解高级GC行为，有时类似奇怪的行为在SV下很明显。</p></li><li><p>一些性能差异可以用Shenandoah下更大的分配压力解释，因为它包含每个对象的转发指针。查看分配率以确定其是否有问题，并可以通过实验进一步证实（例如，增强对象可以减少与其他收集器之间的性能差异）。在某些情况下，较大的内存占用意味着退出CPU cache，寻找L1/L2/LLC遗漏的差异。</p></li><li><p>许多吞吐量差异可以用GC屏障开销来解释。当使用<strong>-XX:ShenandoahGCHeuristics=passive</strong>运行时，<em>这是启发式方法独有的</em>，正确性不需要障碍，因此启发式方法禁用它们。然后可以有选择地启用屏障，并查看哪些屏障正在影响吞吐量性能。“passive”启发式禁用的障碍列表列在GC输出中，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ java -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=passive -Xlog:gc</span><br><span class="line">[0.002s][info][gc] Passive heuristics implies -XX:-ShenandoahSATBBarrier by default</span><br><span class="line">[0.002s][info][gc] Passive heuristics implies -XX:-ShenandoahKeepAliveBarrier by default</span><br><span class="line">[0.002s][info][gc] Passive heuristics implies -XX:-ShenandoahWriteBarrier by default</span><br><span class="line">[0.002s][info][gc] Passive heuristics implies -XX:-ShenandoahReadBarrier by default</span><br><span class="line">[0.002s][info][gc] Passive heuristics implies -XX:-ShenandoahStoreValReadBarrier by default</span><br><span class="line">[0.002s][info][gc] Passive heuristics implies -XX:-ShenandoahCASBarrier by default</span><br><span class="line">[0.002s][info][gc] Passive heuristics implies -XX:-ShenandoahAcmpBarrier by default</span><br><span class="line">[0.002s][info][gc] Passive heuristics implies -XX:-ShenandoahCloneBarrier by default</span><br><span class="line">[0.003s][info][gc] Using Shenandoah</span><br></pre></td></tr></table></figure></li><li><p>使用Linux perf可以轻松分析本机GC代码：</p><ol><li><p>Build OpenJDK with <strong>–with-native-debug-symbols=internal</strong>, this will get you the mapping to C++ code</p></li><li><p>Run the workload with <strong>perf record java …</strong> (plain profile) or <strong>perf record -g java …</strong> (call tree profile)</p></li><li><p>Open the report with <strong>perf report</strong></p></li><li><p>Navigate the report, and see where are suspiciously hot methods/paths are. Pressing <strong>“a”</strong>on the method usually gives a more detailed disassembly for it</p></li></ol></li><li><p>分析障碍代码需要启用PrintAssembly的构建。我们建议使用JMH -prof perfasm创建隔离的场景并查看Shenandoah下生成的代码。</p></li></ol><p>重要的是要明确GC停顿可能不是常规应用程序中响应时间的唯一重要来源。具有较大的GC停顿时间很快就会出现响应时间问题，但缺少长时间的GC停顿并不总是意味着良好的响应时间。排队延迟、网络延迟、其他服务延迟、OS调度程序抖动等都可能是影响因素。建议使用响应时间度量来运行Shenandoah，以全面了解系统中正在发生的事情，然后可以将其与GC停顿时间统计数据关联起来。</p><p>例如，这是一个带有jHiccup其中一个工作负载的示例报告：</p><p><img src="https://cr.openjdk.java.net/~shade/shenandoah/specjbb-preset4K-10min.png" alt=""></p><h2 id="功能诊断"><a href="#功能诊断" class="headerlink" title="功能诊断"></a>功能诊断</h2><p>本节介绍了可以诊断和/或调试Shenandoah的方法。</p><p>以下是缩小问题范围的步骤:</p><ol><li>使用 <strong>-XX:+ShenandoahVerify</strong>运行。这是针对GC bug的第一道防线，它在release和fastdebug构建中都可用。如果Verifier识别出一个问题，那么它很可能是GC bug。为了更好地诊断这一点，一个简单的复制器将是很方便的。在许多情况下，GC之前发生的事情很重要，例如GC所采取的最后操作。该历史记录通常记录在关联的hs_err_pidXXXX日志中，确保在报告bug时将其包含在内。</li><li>使用<strong>fastdebug build</strong>运行。在许多情况下，这将产生有意义的断言消息，指向GC检测到功能异常的最早时刻，而Shenandoah断言很多。这些构建可以通过添加<strong>–enable-debug</strong>来配置和重新构建生成。像往常一样，hs_err_pidXXXX.log方便地记录了有助于调查断言失败的环境和历史数据。</li><li>使用<strong>-XX:ShenandoahGCHeuristics=passive</strong>运行，它将仅执行stop-the-world GC，并避免执行大多数并发工作。如果问题在passive模式下消失，那么它一定是并发阶段和/或屏障中的bug。</li><li>使用不同的编译器运行：<strong>-Xint</strong>（仅限解释器），<strong>-XX:TieredStopAtLevel=1</strong>（仅限C1），<strong>-XX:-TieredCompilation</strong>（仅限解释器和C2）——剖析哪些模式失败，哪些没有。这将突出显示问题是在解释器、C1或C2中的屏障处理或优化。这通常有助于与fastdebug build相结合，因为编译器也会产生断言。</li><li>使用<strong>-XX:ShenandoahGCHeuristics=aggressive</strong>运行。这种启发式方法连续运行GC，并疏散所有非空region。由于Shenandoah并发执行大多数GC繁重工作，所以这不会阻止应用程序的执行，尽管在这种模式下GC将消耗更多的周期并降低应用程序的运行速度。注意，此模式下启用Verifier可能会将性能降低到不实用的水平。</li><li>使用<strong>-XX:+ShenandoahVerifyOptoBarriers</strong>（验证C2理想图中的屏障），<strong>-XX:VerifyStrictOopOperations</strong>（执行额外的检查来验证oop比较是否正确）添加更多验证。</li></ol><p>适用于Shenandoah的一般调试技术:</p><ol><li>在代码中围绕失败的断言放置日志语句，以便更好地理解问题。有了足够的日志记录，你就可以重新跟踪收集器中发生的所有事情。</li><li>在代码中可疑的部分周围添加更多的断言。查看shenandoahassert中的宏定义。hpp查看rich断言的可用性</li><li>附加一个本机调试器，例如gdb，通过请求VM在失败时使用<strong>-XX:OnError=”gdb - %p”</strong>执行外部操作(将％p替换为进程PID)</li><li>创建一个简单的复制器并交给Shenandoah开发人员。:)</li></ol><h2 id="构建，下载，安装，运行"><a href="#构建，下载，安装，运行" class="headerlink" title="构建，下载，安装，运行"></a>构建，下载，安装，运行</h2><p>自12以来，Shenandoah就在主线JDK中进行开发。除了主线构建之外，还有一些下游的构建可用于当前JDK。开发repos和builds之间的变更流程如下面的简化图所示。</p><p><img src="http://cr.openjdk.java.net/~shade/shenandoah/shenandoah-changes-flow.png" alt=""></p><p>如果你是早期采用者，尝试前沿构建应该在性能方面更有利可图，但可能会冒险暴露于尚未发现的bug。如果希望在实际部署中运行Shenandoah，则首选使用最稳定的版本。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/28/5c9c829850beb.jpg&quot; alt=&quot;OpenJDK.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;Shenandoah是低停顿时间的垃圾收集器，通过与正在运行的Java程序并发地执行更多垃圾收集工作来缩短GC停顿时间。Shenandoah并发地完成大部分GC工作，包括并发整理，这意味着它的停顿时间不再与堆的大小成正比。收集200GB堆或2GB堆的垃圾应具有类似的低停顿行为。&lt;/p&gt;
&lt;p&gt;本文对Shenandoah GC官方文档进行简单翻译，方便对该垃圾收集器的使用，原文参见： &lt;a href=&quot;https://wiki.openjdk.java.net/display/shenandoah/Main&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Shenandoah wiki page&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="OpenJDK" scheme="http://yoursite.com/tags/OpenJDK/"/>
    
  </entry>
  
  <entry>
    <title>G1GC官方文档（译）</title>
    <link href="http://yoursite.com/2019/04/09/G1GC%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E8%AF%91%EF%BC%89/"/>
    <id>http://yoursite.com/2019/04/09/G1GC官方文档（译）/</id>
    <published>2019-04-09T01:07:01.198Z</published>
    <updated>2019-04-10T01:26:44.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>本文对G1GC官方文档进行了翻译，原文地址：<a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html" target="_blank" rel="noopener">Getting Started with the G1 Garbage Collector</a><br><a id="more"></a></p><h2 id="Java技术和JVM"><a href="#Java技术和JVM" class="headerlink" title="Java技术和JVM"></a>Java技术和JVM</h2><h3 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h3><h4 id="JRE-JDK"><a href="#JRE-JDK" class="headerlink" title="JRE JDK"></a>JRE JDK</h4><p>略</p><h4 id="Java虚拟机（JVM）"><a href="#Java虚拟机（JVM）" class="headerlink" title="Java虚拟机（JVM）"></a>Java虚拟机（JVM）</h4><p>Java虚拟机（JVM）是​一种抽象计算机器。 JVM是一个程序，看起来像是编写在其中执行的程序的机器。这样，Java程序就被写入同一组接口和类库中。针对特定操作系统的每个JVM实现都将Java编程指令转换为在本地操作系统上运行的指令和命令。Java程序正是籍于此实现了平台独立性。</p><p>在Sun Microsystems，Inc完成的Java虚拟机的第一个原型实现模拟了由类似于当代个人数字助理（PDA）的手持设备托管的软件中的Java虚拟机指令集。Oracle当前的实现模拟移动，桌面和服务器设备上的Java虚拟机，但Java虚拟机不承担任何特定的实现技术，主机硬件或主机操作系统。它本身并不是解释，但也可以通过将其指令集编译为硅CPU来实现。它也可以用微代码实现或直接用硅实现。</p><p>Java虚拟机不知道Java编程语言，只知道特定的二进制格式，即类文件格式。类文件包含Java虚拟机指令（或字节码）和符号表，以及其他辅助信息。</p><p>出于安全考虑，Java虚拟机对类文件中的代码施加了强大的语法和结构约束。但是，任何具有可以用有效类文件表示的功能的语言都可以由Java虚拟机托管。由通用的，与机器无关的平台吸引，其他语言的实现者可以转向Java虚拟机作为其语言的交付工具。</p><h3 id="探索JVM体系结构"><a href="#探索JVM体系结构" class="headerlink" title="探索JVM体系结构"></a>探索JVM体系结构</h3><h4 id="Hotspot-架构"><a href="#Hotspot-架构" class="headerlink" title="Hotspot 架构"></a>Hotspot 架构</h4><p>HotSpot JVM拥有一个支持强大功能和基础的架构，并支持实现高性能和大规模可扩展性的能力。例如，HotSpot JVM JIT编译器生成动态优化。换句话说，他们在Java应用程序运行时做出优化决策，并生成针对底层系统架构的高性能本机机器指令。此外，通过其运行时环境和多线程垃圾收集器的成熟演进和持续工程，HotSpot JVM即使在最大的可用计算机系统上也能实现高可扩展性。</p><p><img src="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/gcslides/Slide1.png" alt="HotSpot JVM:Architecture"></p><p>JVM的主要组件包括类加载器，运行时数据区和执行引擎。</p><h4 id="Hotspot-关键组件"><a href="#Hotspot-关键组件" class="headerlink" title="Hotspot 关键组件"></a>Hotspot 关键组件</h4><p>以下图像突出显示了与性能相关的JVM的关键组件。</p><p><img src="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/gcslides/Slide2.png" alt="Key Hotaspot JVM Components"></p><p>在调整性能时，JVM有三个组件。堆是存储对象数据的位置。然后，此区域由启动时选择的垃圾收集器进行管理。 大多数调优选项都与调整堆大小和为您的情况选择最合适的垃圾收集器有关。JIT编译器对性能也有很大影响，但很少需要使用较新版本的JVM进行调优。</p><h3 id="性能基本知识"><a href="#性能基本知识" class="headerlink" title="性能基本知识"></a>性能基本知识</h3><p>通常在Java应用程序调优时，关注两个主要目标：响应性或吞吐量。下文将回顾这些概念。</p><h4 id="响应性"><a href="#响应性" class="headerlink" title="响应性"></a>响应性</h4><p>响应性是指应用程序或系统对请求数据响应的速度。例如：</p><pre><code>桌面UI响应事件的速度有多快网站返回页面的速度有多快返回数据库查询的速度有多快</code></pre><p>对于专注于响应性的应用程序，高停顿时间是不可接受的，侧重在短时间内做出回应。</p><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>吞吐量关注在特定时间段内应用程序工作量的最大化。衡量吞吐量的示例：</p><pre><code>在给定时间内完成的交易数量。批处理程序可在一小时内完成的作业数。可在一小时内完成的数据库查询数。</code></pre><p>对于专注于吞吐量的应用程序，高停顿时间是可接受的。由于高吞吐量应用程序在较长时间内专注于基准测试，因此不需要考虑快速响应时间。</p><h2 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h2><h3 id="G1垃圾收集器-1"><a href="#G1垃圾收集器-1" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h3><p>Garbage-First（G1）收集器是一种服务器风格的垃圾收集器，主要针对多处理器大内存的机器。它能高概率满足垃圾收集（GC）的停顿时间目标，同时实现高吞吐量。Oracle JDK 7 Update 4及更高版本完全支持G1垃圾收集器。G1收集器专为以下应用而设计：</p><ul><li>可以与CMS收集器等应用程序线程同时运行。</li><li>整理空闲内存时不会伴随长时间GC引起的高停顿。</li><li>需要GC停顿持续时间变得更加可预测。</li><li>不想牺牲很多吞吐量性能。</li><li>不需要更大的Java堆。</li></ul><p>G1被设计作为Concurrent Mark-Sweep Collector（CMS）的长期替代品。将G1与CMS进行比较，会发现存在以下差异使得G1成为更好的垃圾收集解决方案。一个区别是G1是“标记-整理”收集器，G1足够紧凑以完全避免使用细粒度的自由列表进行分配，而是依赖于区域。这大大简化了收集器的各个部分，并且主要消除了潜在的碎片问题。此外，G1提供比CMS收集器更可预测的垃圾收集暂停，并允许用户指定所需的暂停目标。</p><h4 id="G1操作概述"><a href="#G1操作概述" class="headerlink" title="G1操作概述"></a>G1操作概述</h4><p>旧的垃圾收集器（serial, parallel, CMS）都将堆分为三个部分：新生代、老年代和固定内存大小的永久代。</p><p><img src="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/HeapStructure.png" alt="Hotspot Heap Structure"></p><p>所有内存对象都在这三个部分之一结束生命周期。</p><p>G1收集器采用了不同的方法。</p><p><img src="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide9.png" alt="G1 Heap Allocation"></p><p><em>堆被分区为一组大小相等的堆region，每个region都是一个连续的虚拟内存区域。 某些region集具有与旧收集器中相同的角色（eden,survivor,old），但它们没有固定的大小。 这为内存使用提供了更大的灵活性。</em></p><p>执行垃圾收集时，G1以类似于CMS收集器的方式运行。G1执行并发全局标记阶段以确定整个堆中对象的活跃度。在标记阶段完成之后，G1知道哪些region基本上是空的。它首先在这些region上进行收集，这通常会产生大量的空闲内存。这就是为什么这种垃圾收集方法称为Garbage-First。顾名思义，G1将其收集和整理活动集中在堆的可能充满可回收对象（即垃圾）的区域。 G1使用暂停预测模型来满足用户定义的停顿时间目标，并根据指定的停顿时间目标选择要收集的区域数。</p><p>由G1确定适合回收的region，并使用疏散（evacuation）方式进行垃圾收集收集。G1将对象从堆的一个或多个region复制到堆上的单个region，并且在此过程中整理并释放内存。这种疏散在多处理器上并行执行，以减少停顿时间并提高吞吐量。因此，对于每次垃圾收集，G1会在用户定义的停顿时间内持续工作以减少碎片。这超出了以前两种方法的能力：CMS（Concurrent Mark Sweep）垃圾收集器不进行整理；ParallelOld垃圾收集仅执行整堆整理，这会导致相当长的停顿时间。</p><p>值得注意的是G1不是实时收集器。它以高概率但不是绝对确定性满足设定的停顿时间目标。基于先前收集过程中的数据，G1可以预估在用户指定的目标时间内收集多少region。因此，G1收集器对收集region的成本有一套相当准确的模型，它使用该模型来确定在停顿时间目标内时要收集哪些region和多少region。</p><p>注意：G1具有并发（与应用程序线程一起运行，例如，细化，标记，清理）和并行（多线程，例如，stop the world）阶段。Full GC仍然是单线程的，但如果正确调整，应用程序应该避免使用full GC。</p><h4 id="G1数据占位"><a href="#G1数据占位" class="headerlink" title="G1数据占位"></a>G1数据占位</h4><p>如果从ParallelOldGC或CMS收集器迁移到G1，你可能会看到更大的JVM进程大小。这主要与“accounting”数据结构有关，例如Remembered Sets和Collection Sets。</p><p><strong>Remembered Sets</strong>或RSet：跟踪对象引用到给定的region。堆中每个region都有一个RSet。RSet支持并行和独立收集region。RSets的总体占位影响小于5％。</p><p><strong>Collection Sets</strong>或CSets：将要在GC中收集的region集。在GC期间，CSet中的所有实时数据都被疏散（复制/移动）。区域集可以是Eden、survivor、和/或老年代。CSets对JVM的大小影响不到1％。</p><h4 id="推荐的G1使用场景"><a href="#推荐的G1使用场景" class="headerlink" title="推荐的G1使用场景"></a>推荐的G1使用场景</h4><p>第一个关注点是G1为运行需要低GC延迟大堆的应用程序的用户提供解决方案。这意味着堆大小约为6GB或更大，稳定且可预测的停顿时间低于0.5秒。</p><p>如果应用程序具有以下一个或多个特征，那么当前使用CMS或ParallelOldGC垃圾收集器运行的应用程序切换到G1后将得到提升。</p><ul><li>Full GC持续时间太长或太频繁。</li><li>对象分配率或提升率差异很大。</li><li>不期望的长GC或整理停顿（超过0.5到1秒）</li></ul><p><strong>注意：</strong>如果使用的是CMS或ParallelOldGC，并且应用程序没有经历长时间的GC停顿，那么使用当前的收集器就可以了。更改为G1收集器不是使用最新JDK的必要条件。</p><h2 id="回顾CMS垃圾收集"><a href="#回顾CMS垃圾收集" class="headerlink" title="回顾CMS垃圾收集"></a>回顾CMS垃圾收集</h2><h3 id="回顾传统GC及CMS"><a href="#回顾传统GC及CMS" class="headerlink" title="回顾传统GC及CMS"></a>回顾传统GC及CMS</h3><p>Concurrent Mark Sweep（CMS）收集器（也称为并发低停顿收集器）对老年代进行收集。它尝试通过与应用程序线程同时执行大部分垃圾收集工作，来最小化由于垃圾收集而导致的停顿。 通常，并发低停顿收集器不会复制或整理活动对象。无需移动活动对象即可完成垃圾收集。如果碎片成为问题，请分配更大的堆。</p><p><strong>注意：</strong>新生代的CMS收集器使用与并行收集器相同的算法。</p><h4 id="CMS收集阶段"><a href="#CMS收集阶段" class="headerlink" title="CMS收集阶段"></a>CMS收集阶段</h4><p>CMS收集器在堆的老年代上执行以下阶段：</p><table><thead><tr><th>Phase</th><th>Description</th></tr></thead><tbody><tr><td>(1) 初始标记     <em>(Stop the World Event)</em></td><td>老年代中的对象被“标记”为可达的，其中包括那些可以从新生代到达的对象。相较Minor GC的停顿时间，该阶段停顿时间通常较短。</td></tr><tr><td>(2) 并发标记</td><td>遍历可达对象的老年代对象图，与Java应用线程并发执行。从标记的对象开始扫描，并标记从GC roots可达的所有对象。Mutator线程在并发阶段2,3和5阶段执行，并且CMS在这些阶段中分配的任何对象（包括晋升的对象）立即被标记为存活对象。</td></tr><tr><td>(3) 重新标记      <em>(Stop the World Event)</em></td><td>查找并发标记阶段遗漏的对象，遗漏发生在并发收集器完成对该对象的跟踪之后，Java应用程序线程又进行了更新。</td></tr><tr><td>(4) 并发清理</td><td>收集在标记阶段标识为不可达的对象。死对象的收集将对象的空间添加到空闲列表以供稍后分配。此时可能会发生死对象的合并。请注意，不会移动存活对象。</td></tr><tr><td>(5) 重置</td><td>通过清除数据结构准备下一轮并发收集。</td></tr></tbody></table><h4 id="回顾垃圾收集步骤"><a href="#回顾垃圾收集步骤" class="headerlink" title="回顾垃圾收集步骤"></a>回顾垃圾收集步骤</h4><p>接下来，让我们一步一步查看CMS收集器操作。</p><ol><li><p><strong>CMS收集器堆结构</strong></p><p>堆被分成三个部分。</p><p><img src="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide1.png" alt="CMS Heap Structure">新生代分为Eden区和两个survivor区，老年代是一个连续的空间。对象在原地址上进行收集，除非有full GC，否则不会进行整理。</p></li><li><p><strong>CMS中Young GC工作原理</strong></p><p>新生代是浅绿色，老年代是蓝色。如果应用程序已运行一段时间，这就是CMS的样子，对象散落在老年代区域。</p><p><img src="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide2.png" alt="How Young GC works"></p><p>使用CMS，老年代对象在原地址上进行回收，没有移动操作。除非有full GC，否则不会进行整理。</p></li><li><p><strong>一次Young GC</strong></p><p>存活对象从Eden区和一个survivor区复制到另一个survivor区。任何已达到年龄阈值的老对象都将晋升到老年代。</p><p><img src="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide3.png" alt="Young Generation Collection"></p></li><li><p><strong>Young GC之后</strong></p><p>在Young GC之后，Eden区及其中一个survivor区被清空。</p><p><img src="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide4.png" alt="After Young GC"></p><p>新晋升的对象在图中以深蓝色显示，绿色对象是尚未晋升到老年代的幸存的新生代对象。</p></li><li><p><strong>CMS的老年代GC</strong></p><p>两次STW事件发生：初始标记和重新标记。当老年代达到一定的占用率时，CMS就会被启动。</p><p><img src="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide5.png" alt="Old Generation Collection with CMS"></p><p>（1）初始标记，短暂停顿阶段，对存活（可达的）对象进行标记。</p><p>（2）并发标记，在应用程序继续执行时并发地查找存活对象。</p><p>（3）重新标记，发现在前一阶段（2）并发标记期间遗漏的对象。</p></li><li><p><strong>老年代GC-并发清理</strong></p><p>在前一阶段未标记的对象将被回收，不进行整理。</p><p><img src="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide6.png" alt="Old Generation Collection - Concurrent Sweep"></p><p><strong>注意：</strong> Unmarked 对象 == Dead 对象</p></li><li><p><strong>老年代GC-清理之后</strong></p><p>在（4）清理阶段之后，可以看到已经释放了大量内存，并且没有进行任何整理。</p><p><img src="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide7.png" alt="Old Generation Collection - After Sweeping"></p><p>最后，CMS收集器将执行（5）重置阶段，并等待下一次达到GC阈值。</p></li></ol><h2 id="G1垃圾回收过程详解"><a href="#G1垃圾回收过程详解" class="headerlink" title="G1垃圾回收过程详解"></a>G1垃圾回收过程详解</h2><h3 id="The-G1-Garbage-Collector-Step-by-Step"><a href="#The-G1-Garbage-Collector-Step-by-Step" class="headerlink" title="The G1 Garbage Collector Step by Step"></a>The G1 Garbage Collector Step by Step</h3><p>G1收集器采用不同的方法来分配堆，下面的图片将逐步回顾G1系统。</p><ol><li><p><strong>G1 堆结构</strong></p><p>堆是一个分成许多固定大小region的内存区域。</p><p><img src="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide8.png" alt="G1 Heap Structure"></p><p>region大小由JVM在启动时选择，JVM通常将堆分为大约2000个region，大小从1到32Mb不等。</p></li><li><p><strong>G1 堆分配</strong></p><p>实际上，这些region被映射Eden、Survivor和老年代的逻辑表示。</p><p><img src="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide9.png" alt="G1 Heap Allocation"></p><p>图中的颜色显示哪个region与哪个角色相关联。存活对象从一个region疏散（即，复制或移动）到另一个region。region被设计为在停止或不停止所有其他应用程序线程的情况下并行收集。</p><p>如图所示，region可以分为Eden、Survivor和老年代region。此外，还有第四种被称为Humongous region的对象。这些region设计用于容纳大小为标准region大小的50％或更大的对象，它们存储为一组连续的region。 最后，最后一种类型的region将是堆的未使用region。</p><p><strong>注意：</strong>在撰写本文时，尚未优化收集humongous对象，因此应该避免创建此大小的对象。</p></li><li><p><strong>G1的Young GC原理</strong></p><p>堆被分成大约2000个region，最小大小为1Mb，最大大小为32Mb。蓝色region包含老年代对象，绿色region包含新生代对象。</p><p><img src="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide10.png" alt="Young Generation in G1"></p><p>请注意，region不需要像以前的垃圾收集器那样连续。</p></li><li><p><strong>G1的一次Young GC</strong></p><p>将存活对象疏散（即，复制或移动）到一个或多个survivor region。 如果满足年龄阈值，则将一些对象晋升为老年代region。</p><p><img src="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide11.png" alt="A Young GC in G1"></p><p>这是一次stop the world（STW）停顿，计算下一次Young GC的Eden大小和survivor大小。保留accounting信息以帮助计算大小，同时像停顿时间目标这样的事情被考虑在内。</p><p>这种方法可以很容易地调整region大小，使它们根据需要变大或变小。</p></li><li><p><strong>G1 Young GC结果</strong></p><p>存活对象已被疏散到survivor region或老年代region。</p><p><img src="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide12.png" alt="End of a Young GC with G1"></p><p>最近晋升的对象以深蓝色显示。深绿色为新生代幸存的survivor region。</p><p>对G1的新生代总结如下：</p><ul><li>堆是被分成region的单个内存空间。</li><li>新生代内存由一组非连续的region组成，这样可以在需要时轻松调整大小。</li><li>Young GC为STW事件，执行期间将停止所有应用程序线程。</li><li>Young GC使用多个线程并行完成。</li><li>存活对象被复制到新的survivor region或老年代region。</li></ul></li></ol><h3 id="G1的老年代收集"><a href="#G1的老年代收集" class="headerlink" title="G1的老年代收集"></a>G1的老年代收集</h3><h4 id="G1收集阶段-并发标记循环周期"><a href="#G1收集阶段-并发标记循环周期" class="headerlink" title="G1收集阶段 - 并发标记循环周期"></a>G1收集阶段 - 并发标记循环周期</h4><p>G1收集器在堆的老年代上执行以下阶段。请注意，某些阶段是新生代收集的一部分。</p><table><thead><tr><th>Phase</th><th>Description</th></tr></thead><tbody><tr><td>(1) 初始标记<em>(Stop the World Event)</em></td><td>这是一个STW事件。对G1来说初始标记可由一次普通的young GC完成。标记可能引用老年代对象的survivor region（root region）。</td></tr><tr><td>(2) Root Region 扫描</td><td>扫描引用老年代对象的survivor region，应用程序继续运行时会发生这种情况。 必须在young GC发生之前完成该阶段。</td></tr><tr><td>(3) 并发标记</td><td>在整个堆上查找存活对象，与应用程序并发执行。此阶段可被young GC中断。</td></tr><tr><td>(4) 重新标记<em>(Stop the World Event)</em></td><td>完成堆中存活对象的标记，使用名为snapshot-at-the-beginning（SATB）的算法，该算法比CMS收集器中使用的算法快得多。</td></tr><tr><td>(5) 清除<em>(Stop the World Event and Concurrent)</em></td><td>1 对存活对象和完全空闲region执行accounting。 （STW）</td></tr></tbody></table><p>2 清除Remembered Sets。 （STW）<br>3 重置空region并将其返回到空闲列表。 （并发） |<br>| (<em>) 复制 </em>(Stop the World Event)*               | STW停顿以疏散或复制存活对象到新的未使用region。新生代操作日志记录为<code>[GC pause (young)]</code>。新生代和老年代的混合收集日志记录为<code>[GC Pause (mixed)]</code>。 |</p><h4 id="G1-Old-Generation-Collection-Step-by-Step"><a href="#G1-Old-Generation-Collection-Step-by-Step" class="headerlink" title="G1 Old Generation Collection Step by Step"></a>G1 Old Generation Collection Step by Step</h4><p>接下来看一下这些阶段是如何与G1收集器中的老年代进行交互的。</p><ol start="6"><li><p><strong>初始标记阶段</strong></p><p>存活对象的初始标记搭载在young GC上，在日志中，这被称为<code>GC pause (young)(inital-mark)</code>。</p><p><img src="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide13.png" alt="Initial Marking Phase"></p></li><li><p><strong>并发标记阶段</strong></p><p>如果找到空region（由“X”表示），则在重新标记阶段立即将它们移除。此外，计算确定活跃度的“accounting”信息。</p><p><img src="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide14.png" alt="Concurrent Marking Phase"></p></li><li><p><strong>重新标记阶段</strong></p><p>空region被移除并回收。现在计算所有region的区域活跃度。</p><p><img src="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide15.png" alt="Remark Phase"></p></li><li><p><strong>复制/清除阶段</strong></p><p>G1选择具有最低“活跃度”的region，这些region可以被最快收集。 然后，这些region与young GC同时收集。 这在日志中表示为<code>[GC pause (mixed)]</code>，即新生代与老年代同时被收集。</p><p><img src="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide16.png" alt="Copying/Cleanup Phase"></p></li><li><p><strong>After Copying/Cleanup Phase</strong></p><p>选择的region已经被收集并整理，如图中所示的深蓝色区域和深绿色区域。</p><p><img src="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide17.png" alt="After Copying/Cleanup Phase"></p></li></ol><h4 id="Summary-of-Old-Generation-GC"><a href="#Summary-of-Old-Generation-GC" class="headerlink" title="Summary of Old Generation GC"></a>Summary of Old Generation GC</h4><p>对G1老年代收集的总结如下：</p><ul><li><p>并发标记阶段</p><ul><li><p>在应用程序运行时并发计算活跃度信息。</p><ul><li><p>活跃度信息确定在疏散停顿期间那些region最适合回收。</p></li><li><p>没有类似于CMS的清理阶段。</p></li></ul></li></ul></li><li><p>重新标记阶段</p><pre><code>- 使用 Snapshot-at-the-Beginning（SATB）算法，该算法比CMS使用的算法快得多。- 完全空的region被回收。</code></pre></li><li><p>复制/清除阶段</p><pre><code>- 新生代和老年代同时被收回。- 基于活跃度选择老年代区域。</code></pre></li></ul><h2 id="命令行参数及最佳实践"><a href="#命令行参数及最佳实践" class="headerlink" title="命令行参数及最佳实践"></a>命令行参数及最佳实践</h2><h3 id="Command-Line-Options-and-Best-Practices"><a href="#Command-Line-Options-and-Best-Practices" class="headerlink" title="Command Line Options and Best Practices"></a>Command Line Options and Best Practices</h3><p>在本节中，我们来看看G1的各种命令行选项。</p><h4 id="基本命令行"><a href="#基本命令行" class="headerlink" title="基本命令行"></a>基本命令行</h4><p>要启用G1收集器，请使用:<code>-XX:+UseG1GC</code></p><p>下面是一个示例命令行，用于启动JDK演示和示例下载中包含的Java2Demo：<br> <strong>java -Xmx50m -Xms50m -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -jar c:\javademos\demo\jfc\Java2D\Java2demo.jar</strong> </p><h4 id="关键命令行开关"><a href="#关键命令行开关" class="headerlink" title="关键命令行开关"></a>关键命令行开关</h4><p><strong>-XX:+UseG1GC</strong> - 告诉JVM使用G1垃圾收集器。</p><p><strong>-XX:MaxGCPauseMillis=200</strong> - 设置最大GC停顿时间的目标。这是一个soft goal，JVM将尽最大努力实现它。因此，停顿时间的目标有时会无法实现。默认值是200毫秒。</p><p><strong>-XX:InitiatingHeapOccupancyPercent=45</strong> - 用于启动并发GC循环的(整个)堆占用的百分比。G1使用它根据整个堆的占用情况(而不仅仅是其中一个代)触发并发GC循环。值0表示“执行固定的GC循环”。默认值为45(即， 45%已满或已占用)。</p><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>在使用G1时，您应该遵循一些最佳实践：</p><ol><li><p><strong>不要设置新生代的大小</strong></p><p>通过<code>-Xmn</code>显式地设置年轻代的大小会影响G1收集器的默认行为。</p><ul><li>G1将不再考虑收集的停顿时间目标。因此在本质上，设置新生代的大小会禁用停顿时间目标。</li><li>G1不再能够根据需要扩展和收缩新生代的空间。由于大小是固定的，所以不能对大小进行更改。</li></ul></li><li><p><strong>响应时间指标</strong></p><p>不使用平均响应时间(ART)作为设置<code>XX:MaxGCPauseMillis=&lt;N&gt;</code>的指标，而是考虑设置将在90%或更多的时间内满足目标的值。这意味着90%发出请求的用户的响应时间不会超过目标。记住，停顿时间是一个目标，并不能保证总是能实现。</p></li><li><p><strong>什么是疏散失败？</strong></p><p>在GC期间，对于幸存者和提升的对象，当JVM用尽堆区域时发生的升级失败。 堆无法扩展，因为它已经处于最大值。 当使用 <code>-XX:+PrintGCDetails</code>时，GC日志中会显示此信息： <strong>tospace overflow</strong>。 这很贵！</p><ul><li>GC仍然需要继续，因此必须释放空间。</li><li>未成功复制的对象必须在适当的位置使用。</li><li>必须重新生成对CSet中的区域的RSets的任何更新。</li><li>所有这些步骤都很昂贵。</li></ul></li><li><p><strong>怎样避免疏散失败</strong></p><p>为避免疏散失败，请考虑以下选项。</p><ul><li>增加堆大小<br>​     增加<strong>-XX:G1ReservePercent=n</strong>，默认值为10。<br>​     G1通过尝试释放保留存储器来创建假天花板，以防需要更多“空间”。</li><li>提前开始标记周期</li><li>使用<strong>-XX:ConcGCThreads=n</strong>选项增加标记线程的数量。</li></ul></li></ol><h4 id="G1-GC开关完整列表"><a href="#G1-GC开关完整列表" class="headerlink" title="G1 GC开关完整列表"></a>G1 GC开关完整列表</h4><p>这是G1 GC开关的完整列表，请记住使用上面列出的最佳实践。</p><table><thead><tr><th>Option and Default Value</th><th>Description</th></tr></thead><tbody><tr><td>-XX:+UseG1GC</td><td>Use the Garbage First (G1) Collector</td></tr><tr><td>-XX:MaxGCPauseMillis=n</td><td>Sets a target for the maximum GC pause time. This is a soft goal, and the JVM will make its best effort to achieve it.</td></tr><tr><td>-XX:InitiatingHeapOccupancyPercent=n</td><td>Percentage of the (entire) heap occupancy to start a  concurrent GC cycle. It is used by GCs that trigger a concurrent GC  cycle based on the occupancy of the entire heap, not just one of the  generations (e.g., G1). A value of 0 denotes ‘do constant GC cycles’.  The default value is 45.</td></tr><tr><td>-XX:NewRatio=n</td><td>Ratio of new/old generation sizes. The default value is 2.</td></tr><tr><td>-XX:SurvivorRatio=n</td><td>Ratio of eden/survivor space size. The default value is 8.</td></tr><tr><td>-XX:MaxTenuringThreshold=n</td><td>Maximum value for tenuring threshold. The default value is 15.</td></tr><tr><td>-XX:ParallelGCThreads=n</td><td>Sets the number of threads used during parallel  phases of the garbage collectors. The default value varies with the  platform on which the JVM is running.</td></tr><tr><td>-XX:ConcGCThreads=n</td><td>Number of threads concurrent garbage collectors  will use. The default value varies with the platform on which the JVM is  running.</td></tr><tr><td>-XX:G1ReservePercent=n</td><td>Sets the amount of heap that is reserved as a false  ceiling to reduce the possibility of promotion failure. The default  value is 10.</td></tr><tr><td>-XX:G1HeapRegionSize=n</td><td>With G1 the Java heap is subdivided into uniformly  sized regions. This sets the size of the individual sub-divisions. The  default value of this parameter is determined ergonomically based upon  heap size. The minimum value is 1Mb and the maximum value is 32Mb.</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;本文对G1GC官方文档进行了翻译，原文地址：&lt;a href=&quot;https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Getting Started with the G1 Garbage Collector&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="GC" scheme="http://yoursite.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot集成RocketMQ的设计与实现</title>
    <link href="http://yoursite.com/2019/03/28/Spring%20Boot%E9%9B%86%E6%88%90RocketMQ%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/03/28/Spring Boot集成RocketMQ的设计与实现/</id>
    <published>2019-03-28T02:10:19.653Z</published>
    <updated>2019-03-29T02:50:52.136Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/03/28/5c9c80dda5387.png" alt="RocketMQ.png"></p><h2 id="文章概要"><a href="#文章概要" class="headerlink" title="文章概要"></a>文章概要</h2><p>最近看了阿里中间件团队的几篇技术博客，详情见：<a href="http://jm.taobao.org/" target="_blank" rel="noopener">阿里中间件团队博客</a>，其中有关RocketMQ的几篇文章写得很好。还是那句话，学习本身就是一个不断获取知识然后投入实践的过程，本文就组内项目中使用的RocketMQ集成Spring Boot框架来实现消息发送消费的解决方案进行一个简单的梳理。鉴于自身当前对中间件优化方面还没有太深的接触，文中有可能会出现一些理解错误，难免不贻笑大方，所以权当成个人的学习笔记，方便记忆和以后的深入学习。</p><a id="more"></a><h2 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>为什么选择 Spring Boot集成RocketMQ作为行情组合计算服务的消息队列解决方案？迫于排版限制，其原因我放在了文章最后的补充目录下，下面是跳转链接：</p><p><a href="#jumpSpringAbout">关于Spring Boot</a></p><p><a href="#jumpCompare">Kafka、RocketMQ、RabbitMQ的比较</a></p><p>同时你也可以获取一些RocketMQ的简单介绍：</p><p><a href="#jumpRocketmqConcept">关于RocketMQ的一些概念</a></p><p>下面我将开门见山地对其实现细节进行介绍：</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ol><li>配置pom.xml文件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;rocketmq.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>spring-boot应用中对应的配置文件：src/main/resources/application.properties.</li></ol><p>生产端的配置文件application.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 定义name-server地址</span><br><span class="line">rocketmq.cluster.nameServer.addr=localhost:9876</span><br><span class="line"># 定义发布者组名</span><br><span class="line">rocketmq.message.producerGroup=result-message-producer</span><br><span class="line"># 定义要发送的topic</span><br><span class="line">rocketmq.message.producer.topic=result-topic</span><br></pre></td></tr></table></figure><p>消费端的配置文件application.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 定义name-server地址</span><br><span class="line">rocketmq.cluster.nameServer.addr=localhost:9876</span><br><span class="line"># 定义发布者组名</span><br><span class="line">rocketmq.message.result.consumerGroup=result-message-consumer</span><br><span class="line"># 定义要发送的topic</span><br><span class="line">rocketmq.message.result.topic=result-topic</span><br></pre></td></tr></table></figure><h3 id="消息生产端的设计实现"><a href="#消息生产端的设计实现" class="headerlink" title="消息生产端的设计实现"></a>消息生产端的设计实现</h3><p>生产端的Java代码如下：</p><p><strong>消息生产者类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQPushProducer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MQPushProducer</span><span class="params">(String nameServers, String producerGroup, String topic, String tag, <span class="keyword">int</span> maxMessageSize)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        producer = <span class="keyword">new</span> DefaultMQProducer(producerGroup);</span><br><span class="line">        producer.setNamesrvAddr(nameServers);</span><br><span class="line">        producer.setMaxMessageSize(maxMessageSize);</span><br><span class="line">        producer.setRetryTimesWhenSendFailed(retryTimesWhenSendFailed);</span><br><span class="line">        producer.setSendMsgTimeout(sendMsgTimeout);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            producer.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(String tag, Collection&lt;T&gt; msgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (producer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SendResult result = producer.send(<span class="keyword">new</span> Message(topic, tag, JSONObject.toJSONString(msgs).getBytes()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Collection&lt;T&gt; msgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (producer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SendResult result = producer.send(<span class="keyword">new</span> Message(topic, tag, JSONObject.toJSONString(msgs).getBytes()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RocketMQ通过轮询所有队列的方式来确定消息被发送到哪一个队列（负载均衡策略）。可以根据业务实现自己的MessageQueueSelector()发送顺序消息。</p><p>MQPushProducerOrderly类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQPushProducerOrderly</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">MQPushProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MQPushProducerOrderly</span><span class="params">(String nameServers, String producerGroup, String topic, String tag, <span class="keyword">int</span> maxMessageSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(nameServers, producerGroup, topic, tag, maxMessageSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Collection&lt;T&gt; msgs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (producer != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">for</span> (T msg : msgs)&#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] msgBytes = JSONObject.toJSONString(msg).getBytes();</span><br><span class="line">                    <span class="comment">// RocketMQ通过MessageQueueSelector中实现的算法来确定消息发送到哪一个队列上</span></span><br><span class="line"><span class="comment">// RocketMQ默认提供了两种MessageQueueSelector实现：随机/Hash</span></span><br><span class="line"><span class="comment">// 可以根据业务实现自己的MessageQueueSelector来决定消息按照何种策略发送到消息队列中</span></span><br><span class="line">                    SendResult result = producer.send(<span class="keyword">new</span> Message(topic, tag, msgBytes), <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">                            Integer id = (Integer) arg;</span><br><span class="line">        <span class="keyword">int</span> index = id % mqs.size();</span><br><span class="line">        <span class="keyword">return</span> mqs.get(index);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消息生产端启动类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="comment">/*packages...*/</span>&#125;,</span><br><span class="line">        excludeFilters = &#123;<span class="meta">@ComponentScan</span>.Filter(type = FilterType.CUSTOM, classes = ApplicationExcludeFilter.class)&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerApplication</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用application.properties里定义的topic属性</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.cluster.nameServer.addr&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String nameServers;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.message.producer.topic&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String resultTopic;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.message.producerGroup&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String resultConsumerGroupName;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.setProperty(CLIENT_LOG_USESLF4J,<span class="string">"true"</span>);</span><br><span class="line">        SpringApplication.run(ProducerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... strings)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//初始化发送生产者队列</span></span><br><span class="line">MQPushProducerOrderly&lt;...&gt; producer = <span class="keyword">new</span> MQPushProducerOrderly(nameServers, producerGroup, topic, tag, maxMessageSize);</span><br><span class="line">        <span class="comment">//整个应用生命周期内，只需要初始化1次</span></span><br><span class="line">        producer.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//启动消息计算发送主线程</span></span><br><span class="line">        ...</span><br><span class="line">            producer.push(msgs);</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//清理资源，关闭网络连接，注销自己</span></span><br><span class="line">        producer.shutdown(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于@SpringBootApplication注解相关参见：<a href="#jumpSpringBootApplication">@SpringBootApplication 注解简析</a></p><p>在整个应用生命周期内，生产者需要调用一次start方法来初始化，初始化主要完成的任务有：</p><ol><li>如果没有指定namesrv地址，将会自动寻址；</li><li>启动定时任务：更新namesrv地址、从namsrv更新topic路由信息、清理已经挂掉的broker、向所有broker发送心跳等；</li><li>启动负载均衡的服务。</li></ol><p>如果Producer发送消息失败，会自动重试，重试的策略：</p><ol><li><p>重试次数 &lt; retryTimesWhenSendFailed（可配置）；</p></li><li><p>总的耗时（包含重试n次的耗时） &lt; sendMsgTimeout（发送消息时传入的参数）；</p></li><li><p>同时满足上面两个条件后，Producer会选择另外一个队列发送消息。</p></li></ol><h3 id="消息消费端设计实现"><a href="#消息消费端设计实现" class="headerlink" title="消息消费端设计实现"></a>消息消费端设计实现</h3><p>消息消费端代码如下：</p><p><strong>消息消费者类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MQPushConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MQPushConsumer</span><span class="params">(String nameServers, String consumerGroup, String topic, String tag, <span class="keyword">int</span> consumeMessageBatchMaxSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> consumeThreadMin, <span class="keyword">int</span> consumeThreadMax, <span class="keyword">int</span> pullBatchSize, MessageModel messageModel, ConsumeFromWhere offset)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(consumerGroup);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            consumer.setNamesrvAddr(nameServers);</span><br><span class="line">            consumer.subscribe(topic, tag);<span class="comment">//可订阅多个tag，但是一个消息只能有一个tag</span></span><br><span class="line">            consumer.setConsumeThreadMin(consumeThreadMin);</span><br><span class="line">            consumer.setConsumeThreadMax(consumeThreadMax);</span><br><span class="line">            consumer.setConsumeFromWhere(offset);</span><br><span class="line">            consumer.setConsumeMessageBatchMaxSize(consumeMessageBatchMaxSize);</span><br><span class="line">            consumer.setPullBatchSize(pullBatchSize);</span><br><span class="line">            consumer.setMessageModel(messageModel);</span><br><span class="line">            consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!poll(list))&#123;</span><br><span class="line">                        <span class="keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            consumer.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MQPushConsumerOrderly类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MQPushConsumerOrderly</span> <span class="keyword">extends</span> <span class="title">MQPushConsumer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MQPushConsumerOrderly</span><span class="params">(String nameServers, String consumerGroup, String topic, String tag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> consumeMessageBatchMaxSize, <span class="keyword">int</span> consumeThreadMin, <span class="keyword">int</span> consumeThreadMax,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> pullBatchSize, MessageModel messageModel, ConsumeFromWhere offset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(nameServers, consumerGroup, topic, tag, consumeMessageBatchMaxSize, consumeThreadMin, consumeThreadMax, pullBatchSize, messageModel, offset);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(consumerGroup);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            consumer.setNamesrvAddr(nameServers);</span><br><span class="line">            consumer.subscribe(topic, tag);<span class="comment">//可订阅多个tag，但是一个消息只能有一个tag</span></span><br><span class="line">            consumer.setConsumeThreadMin(consumeThreadMin);</span><br><span class="line">            consumer.setConsumeThreadMax(consumeThreadMax);</span><br><span class="line">            consumer.setConsumeFromWhere(offset);</span><br><span class="line">            consumer.setConsumeMessageBatchMaxSize(consumeMessageBatchMaxSize);</span><br><span class="line">            consumer.setPullBatchSize(pullBatchSize);</span><br><span class="line">            consumer.setMessageModel(messageModel);</span><br><span class="line">            <span class="comment">//注册监听类的时候，不能使用匿名内部类。不然的话只消费一次消费者就挂了, 监听类要单独写。</span></span><br><span class="line">            MQMessageListenerOrderly listener = <span class="keyword">new</span> MQMessageListenerOrderly(<span class="keyword">this</span>);</span><br><span class="line">            consumer.registerMessageListener(listener);</span><br><span class="line">            consumer.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册监听类的时候，不能使用匿名内部类。不然的话只消费一次消费者就挂了, 监听类要单独写。</p><p><strong>自定义监听类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQMessageListenerOrderly</span> <span class="keyword">implements</span>  <span class="title">MessageListenerOrderly</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置自动提交</span></span><br><span class="line">        context.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">            System.out.println(msg + <span class="string">",内容："</span> + <span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消息消费端启动类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="comment">/*packages...*/</span>&#125;,</span><br><span class="line">        excludeFilters = &#123;<span class="meta">@ComponentScan</span>.Filter(type = FilterType.CUSTOM, classes = ApplicationExcludeFilter.class)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerApplication</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用application.properties里定义的topic属性</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.cluster.nameServer.addr&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String nameServers;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.message.result.topic&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String resultTopic;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.message.result.consumerGroup&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String resultConsumerGroupName;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.setProperty(CLIENT_LOG_USESLF4J,<span class="string">"true"</span>);</span><br><span class="line">        SpringApplication.run(ConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... strings)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//从MQ队列消费计算结果</span></span><br><span class="line">        consumer = <span class="keyword">new</span> MQPushConsumerOrderly(nameServers, consumerGroup, topic, tag, consumeMessageBatchMaxSize, consumeThreadMin,</span><br><span class="line">                consumeThreadMax, pullBatchSize, messageModel, offset) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">poll</span><span class="params">(List&lt;MessageExt&gt; messageExts)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : messageExts) &#123;</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是一个简单的使用Spring Boot框架集成RocketMQ实现基本的消息发送和接收的实例，在以后的工作中对RocketMQ的事务消费、消息存储有深入的理解再另行整理。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h4 id="关于Spring-Boot"><a href="#关于Spring-Boot" class="headerlink" title="关于Spring Boot"></a><span id="jumpSpringAbout">关于Spring Boot</span></h4><p>Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot 致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。</p><p>Spring Boot基于“约定大于配置”（Convention over configuration)这一理念来快速地开发、测试、运行和部署Spring应用，并能通过简单地与各种启动器(如 spring-boot-web-starter)结合，让应用直接以命令行的方式运行，不需再部署到独立容器中。这种简便直接快速构建和开发应用的过程，可以使用约定的配置并且简化部署，受到越来越多的开发者的欢迎。</p><h4 id="Kafka、RocketMQ、RabbitMQ的比较"><a href="#Kafka、RocketMQ、RabbitMQ的比较" class="headerlink" title="Kafka、RocketMQ、RabbitMQ的比较"></a><span id="jumpCompare">Kafka、RocketMQ、RabbitMQ的比较</span></h4><ul><li><p>Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache顶级项目。Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。</p><p>大型公司建议可以选用，如果有日志采集功能，肯定是首选kafka了。</p></li><li><p>RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。</p><p>结合erlang语言本身的并发优势，性能较好，社区活跃度也比较高，但是不利于做二次开发和维护。不过，RabbitMQ的社区十分活跃，可以解决开发过程中遇到的bug。</p><p>如果你的数据量没有那么大，小公司优先选择功能比较完备的RabbitMQ。</p></li><li><p>RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景。</p><p>天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。</p><p>RoketMQ在稳定性上可能更值得信赖，这些业务场景在阿里双11已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择RocketMQ。</p></li></ul><h4 id="关于RocketMQ的一些概念"><a href="#关于RocketMQ的一些概念" class="headerlink" title="关于RocketMQ的一些概念"></a><span id="jumpRocketmqConcept">关于RocketMQ的一些概念</span></h4><p><strong>Producer</strong>：消息生产者，生产者的作用就是将消息发送到 MQ，生产者本身既可以产生消息，如读取文本信息等。也可以对外提供接口，由外部应用来调用接口，再由生产者将收到的消息发送到 MQ。</p><p><strong>Producer Group</strong>：生产者组，简单来说就是多个发送同一类消息的生产者称之为一个生产者组。在这里可以不用关心，只要知道有这么一个概念即可。</p><p><strong>Consumer</strong>：消息消费者，简单来说，消费 MQ 上的消息的应用程序就是消费者，至于消息是否进行逻辑处理，还是直接存储到数据库等取决于业务需要。</p><p><strong>Consumer Group</strong>：消费者组，和生产者类似，消费同一类消息的多个 consumer 实例组成一个消费者组。</p><p><strong>Topic</strong>：Topic 是一种消息的逻辑分类，比如说你有订单类的消息，也有库存类的消息，那么就需要进行分类，一个是订单 Topic 存放订单相关的消息，一个是库存 Topic 存储库存相关的消息。</p><p><strong>Message</strong>：Message 是消息的载体。一个 Message 必须指定 topic，相当于寄信的地址。Message 还有一个可选的 tag 设置，以便消费端可以基于 tag 进行过滤消息。也可以添加额外的键值对，例如你需要一个业务 key 来查找 broker 上的消息，方便在开发过程中诊断问题。</p><p><strong>Tag</strong>：标签可以被认为是对 Topic 进一步细化。一般在相同业务模块中通过引入标签来标记不同用途的消息。</p><p><strong>Broker</strong>：Broker 是 RocketMQ 系统的主要角色，其实就是前面一直说的 MQ。Broker 接收来自生产者的消息，储存以及为消费者拉取消息的请求做好准备。</p><p><strong>Name Server</strong>：Name Server 为 producer 和 consumer 提供路由信息。</p><p><strong>RocketMQ的概念模型如下：</strong> </p><p><img src="https://i.loli.net/2019/03/28/5c9c7b4c6f381.jpg" alt="RocketMQModel.jpg"></p><p><strong>RocketMQ的部署模型如下：</strong> </p><p><img src="https://i.loli.net/2019/03/28/5c9c7b4c651ee.jpg" alt="RocketMQBuild.jpg"></p><h4 id="SpringBootApplication-注解简析"><a href="#SpringBootApplication-注解简析" class="headerlink" title="@SpringBootApplication 注解简析"></a><span id="jumpSpringBootApplication">@SpringBootApplication 注解简析</span></h4><p>@SpringBootApplication = @SpringBootConfiguration + @EnableAutoConfiguration + @ComponentScan。</p><p>因为@SpringBootConfiguration ,@EnableAutoConfiguration,@ComponentScan这些注解一般都是一起使用来注解mian()方法所在的类，所以Spring Boot提供了一个统一的注解@SpringBootApplication。</p><ul><li><code>@SpringBootConfiguration</code>继承自<code>@Configuration</code>，二者功能也一致，标注当前类是配置类，并会将当前类内声明的一个或多个以<code>@Bean</code>注解标记的方法的实例纳入到Spring容器中，并且实例名就是方法名。</li><li>@EnableAutoConfiguration的作用启动自动的配置，@EnableAutoConfiguration注解的意思就是Springboot根据你添加的jar包来配置你项目的默认配置，比如根据spring-boot-starter-web，来判断你的项目是否需要添加了webmvc和tomcat，就会自动的帮你配置web项目中所需要的默认配置。在下面博客会具体分析这个注解，快速入门的demo实际没有用到该注解。</li><li>@ComponentScan，扫描当前包及其子包下被@Component，@Controller，@Service，@Repository注解标记的类并纳入到spring容器中进行管理。是以前的<code>&lt;context:component-scan&gt;</code>（以前使用在xml中使用的标签，用来扫描包配置的平行支持）。所以本demo中的User为何会被spring容器管理。</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="http://jm.taobao.org/2018/11/28/%E6%88%91%E7%94%A8%E8%BF%99%E7%A7%8D%E6%96%B9%E6%B3%95/#more" target="_blank" rel="noopener">如何在优雅地Spring 中实现消息的发送和消费</a></li><li><a href="http://jm.taobao.org/2018/11/06/%E6%BB%B4%E6%BB%B4%E5%87%BA%E8%A1%8C%E5%9F%BA%E4%BA%8ERocketMQ%E6%9E%84%E5%BB%BA%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%9E%E8%B7%B5/#more" target="_blank" rel="noopener">滴滴出行基于RocketMQ构建企业级消息队列服务的实践</a></li><li><a href="http://www.10tiao.com/html/683/201811/2650718577/1.html" target="_blank" rel="noopener">一文讲透Apache RocketMQ技术精华</a></li><li><a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">分布式开放消息系统(RocketMQ)的原理与实践</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/28/5c9c80dda5387.png&quot; alt=&quot;RocketMQ.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章概要&quot;&gt;&lt;a href=&quot;#文章概要&quot; class=&quot;headerlink&quot; title=&quot;文章概要&quot;&gt;&lt;/a&gt;文章概要&lt;/h2&gt;&lt;p&gt;最近看了阿里中间件团队的几篇技术博客，详情见：&lt;a href=&quot;http://jm.taobao.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阿里中间件团队博客&lt;/a&gt;，其中有关RocketMQ的几篇文章写得很好。还是那句话，学习本身就是一个不断获取知识然后投入实践的过程，本文就组内项目中使用的RocketMQ集成Spring Boot框架来实现消息发送消费的解决方案进行一个简单的梳理。鉴于自身当前对中间件优化方面还没有太深的接触，文中有可能会出现一些理解错误，难免不贻笑大方，所以权当成个人的学习笔记，方便记忆和以后的深入学习。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="中间件" scheme="http://yoursite.com/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="Spring Boot" scheme="http://yoursite.com/tags/Spring-Boot/"/>
    
      <category term="RocketMQ" scheme="http://yoursite.com/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>OpenJDK12的新特性（下）</title>
    <link href="http://yoursite.com/2019/03/26/OpenJDK12%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2019/03/26/OpenJDK12的新特性（下）/</id>
    <published>2019-03-26T07:27:18.412Z</published>
    <updated>2019-04-03T06:09:24.942Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/03/28/5c9c829850beb.jpg" alt="OpenJDK.jpg"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>OpenJDK 12是由JSR 386在Java Community Process中指定的Java SE平台的版本12的开源参考实现，于2019年3月19日达到General Availability版本。GPL(General Public License)协议下的生产就绪二进制文件可从Oracle获得；其他供应商的二进制文件很快就会出现。</p><p>该版本的功能和时间表是通过JEP流程提出和跟踪的，并由JEP 2.0提案进行了修订。该版本使用JDK Release Process（JEP 3）生成发布。</p><p>本文根据OpenJDK 12的官方文档：<a href="http://openjdk.java.net/projects/jdk/12/" target="_blank" rel="noopener">OpenJDK 12</a>，对其新特性进行整理，受本人翻译水平所限，难免有翻译或理解错误，望不吝指正。上篇看这里：<a href="https://f8f-1bearcat.github.io/2019/03/26/OpenJDK12%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/#jump334" target="_blank" rel="noopener">OpenJDK12的新特性（上）</a>。</p><a id="more"></a><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><table><thead><tr><th>JEP</th><th>Features</th></tr></thead><tbody><tr><td>189:</td><td><a href="#jump189">Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)</a></td></tr><tr><td>230:</td><td><a href="#jump230">Microbenchmark Suite</a></td></tr><tr><td>325:</td><td><a href="#jump325">Switch Expressions (Preview)</a></td></tr><tr><td>334:</td><td><a href="#jump334">JVM Constants API</a></td></tr><tr><td>340:</td><td><a href="#jump340">One AArch64 Port, Not Two</a></td></tr><tr><td>341:</td><td><a href="#jump341">Default CDS Archives</a></td></tr><tr><td>344:</td><td><a href="#jump344">Abortable Mixed Collections for G1</a></td></tr><tr><td>346:</td><td><a href="#jump346">Promptly Return Unused Committed Memory from G1</a></td></tr></tbody></table><h4 id="JEP340-One-AArch64-Port-Not-Two"><a href="#JEP340-One-AArch64-Port-Not-Two" class="headerlink" title="JEP340: One AArch64 Port, Not Two"></a><span id="jump340">JEP340: One AArch64 Port, Not Two</span></h4><p><strong>摘要</strong>：</p><p>删除与arm64端口相关的所有源，同时保留32位ARM端口和64位aarch64端口。</p><p><strong>动机</strong>：</p><p>删除此端口将允许所有贡献者将他们的精力集中在单个64位ARM实现上，并消除维护两个端口所需的重复工作。</p><p><strong>描述</strong>：</p><p>JDK中存在两个64位ARM端口。 这些的主要来源是<code>src/hotspot/cpu/arm</code>和<code>open/src/hotspot/cpu/aarch64</code>目录。虽然这两个端口都产生了aarch64实现，但是为了这个JEP，我们将引用前者arm64，它由Oracle提供，后者是aarch64。</p><p>以下是将作为此JEP的一部分完成的任务：</p><ul><li>在<code>open/src/hotspot/cpu/arm</code>中删除所有与<code>arm64-specific</code>的源和与64位而不是32位构建相关的<code>#ifdefs</code>；</li><li>扫描与此端口相关的<code>#ifdefs</code>的剩余JDK源；</li><li>删除构建此端口的build option，使aarch64端口成为64位ARM体系结构的默认构建；</li><li>验证剩余的32位ARM端口是否继续构建并运行一致性测试。</li></ul><h4 id="JEP341-Default-CDS-Archives"><a href="#JEP341-Default-CDS-Archives" class="headerlink" title="JEP341: Default CDS Archives"></a><span id="jump341">JEP341: Default CDS Archives</span></h4><p><strong>摘要</strong>：</p><p>在64位平台上使用默认类列表，增强JDK build process以生成 class data-sharing（CDS）存档。</p><p><strong>目标</strong>：</p><ul><li>改善开箱即用的启动时间</li><li>消除用户运行<code>-Xshare:dump</code>以从CDS中受益的需要</li></ul><p><strong>非目标</strong>：</p><ul><li>我们将仅为native builds生成默认存档，而不是针对交叉编译的构建。</li><li>我们将仅为64位版本生成默认存档，稍后可能会添加对32位版本的支持。</li></ul><p><strong>动机</strong>：</p><p>自JDK 8u40以来，许多增强功能被添加到基本CDS特性中。启用CDS提供的启动时间和内存共享优势显着增加。 使用JDK 11早期访问版本14在Linux/x64上完成的测量显示运行HelloWorld的启动时间缩短了32％。 在其他64位平台上，已观察到类似或更高的启动性能增益。</p><p>目前，JDK映像包括在lib目录中构建时生成的默认类列表。想要利用CDS的用户，即使只使用JDK中提供的默认类列表，也必须运行<code>java -Xshare:dump</code>作为额外步骤。此选项已记录在案，但许多用户并未意识到这一点。</p><p><strong>描述</strong>：</p><p>修改JDK构建以在链接图像后运行<code>java -Xshare:dump</code>，（可以包括附加的命令行选项以微调GC堆大小等，以便为常见情况获得更好的内存布局）将生成的CDS存档保留在<code>lib/server</code>目录中。</p><p>用户将自动受益于CDS功能，因为默认情况下为JDK 11（JDK-8197967）中的服务VM启用了<code>-Xshare:auto</code>。 要禁用CDS，请使用<code>-Xshare:off</code>运行。</p><p>具有更高级要求的用户（例如，使用包括应用程序类、不同GC配置等的自定义类列表）仍然可以像以前一样创建自定义CDS存档。</p><p><strong>选择</strong>：略</p><p><strong>测试</strong>：</p><p>启用CDS的现有自动化测试已足够。</p><h4 id="JEP344-Abortable-Mixed-Collections-for-G1"><a href="#JEP344-Abortable-Mixed-Collections-for-G1" class="headerlink" title="JEP344: Abortable Mixed Collections for G1"></a><span id="jump344">JEP344: Abortable Mixed Collections for G1</span></h4><p><strong>摘要</strong>：</p><p>如果G1 mixed 收集可能超过停顿目标，则使其可以中止。</p><p><strong>非目标</strong>：</p><p>使G1中的所有停顿都可以中止。</p><p><strong>动机</strong>：</p><p>G1的目标之一是满足用户提供的暂停时间目标的条件的时候暂停其收集。G1使用高级分析引擎来选择在收集期间要完成的工作（这部分基于应用程序行为），此选择的结果是一组称为<em>collection set</em>的区域。一旦确定了collection set并且已经开始收集工作，则G1必须不停地收集collection set的所有region中的所有存活的对象。如果heuristics选择过大的collection set，则此行为可能导致G1超过停顿时间目标，例如，如果应用程序的行为发生变化，使得heuristics选择在”陈旧“数据进行处理，则可能发生这种情况。特别是在mixed收集期间可以观察到这种情况，期间collection set通常会包含很多old region。需要一种机制来检测heuristics何时反复为收集选择错误的工作量，如果此现象存在的话，则让G1逐步递增地执行收集工作，并且可以在每个步骤之后中止收集。这种机制将允许G1更易于满足停顿时间目标。</p><p><strong>描述</strong>：</p><p>如果G1发现collection set选择heuristics重复选择错误的区域数，则切换到更复杂的方式来执行mixed收集：将collection set拆分为两个部分：强制部分和可选部分。强制性部分包括G1不能递增地处理的collection set的部分（例如young regions），但也可以包含old region以提高效率。例如，预计的collection set的80％构成强制性部分，剩余的20％（仅由old region组成）构成可选部分。</p><p>G1完成强制部分的收集后，如果还有剩余时间，G1会以更细粒度的级别开始收集可选部分。此可选部分的集合粒度取决于剩余的时间量，一次最多只能到一个region。完成对可选collection set所有部分的收集后，G1可以根据剩余时间决定停止收集。</p><p>随着预测再次变得更准确，一次收集的可选部分变得越来越小，直到强制部分再次包括所有collection set（即，G1完全依赖于其heuristics）。如果预测再次变得不准确，则下一次收集将再次包含强制和可选部分。</p><p><strong>选择</strong>：</p><ul><li><p>改进分析引擎和heuristics，以便他们不会做出错误的预测。由于heuristics方法依赖于之前应用程序的行为，因此无法获得100％准确的heuristics方法。但是，改进的heuristics方法将自动减少对此机制的需求。</p></li><li><p>始终使用与预测有关的“安全边际”。例如，如果预测返回x，则始终使用0.8 * x（20％的安全范围）。这可能在大多数情况下都有效，但是当预测有效时会导致sub-optimal 性能，因为这意味着G1只会使用80％的停顿目标。</p></li><li><p>重用现有的疏散失败机制来中止mixed收集。这已被拒绝作为替代方案，因为在这样的中止时，不能保证该次收集释放任何region。我们提出的机制通过回收region基础（G1的空间回收粒度）上的collection set的空间来保证空间回收的进展。</p></li></ul><p><strong>测试</strong>：</p><p>构成实现的各个C++部分应该使用C++单元测试进行测试。由于可中止的mixed收集代码将是G1 GC的组成部分，因此只需运行现有测试即可执行代码。</p><p><strong>风险和假设</strong>：</p><ul><li><p>将collection set拆分为必需和可选部分时，需要为可选collection set部分维护一些其他数据。 这会产生轻微的CPU开销，小于1％，并且仅适用于使用可选collection set部分的mixed收集。</p></li><li><p>使用可选collection set部分的mixed收集期间的本机内存使用量也可能增加。这是因为在mixed收集期间必须跟踪到可选部分中的区域的一些附加传入指针。</p></li></ul><h4 id="JEP346-Promptly-Return-Unused-Committed-Memory-from-G1"><a href="#JEP346-Promptly-Return-Unused-Committed-Memory-from-G1" class="headerlink" title="JEP346: Promptly Return Unused Committed Memory from G1"></a><span id="jump346">JEP346: Promptly Return Unused Committed Memory from G1</span></h4><p><strong>摘要</strong>：</p><p>增强G1垃圾收集器，以便在空闲时自动将Java堆内存返回给操作系统。</p><p><strong>非目标</strong>：</p><ul><li><p>在Java进程之间共享已提交但空的页面。应将内存返回（未提交）到操作系统。</p></li><li><p>回馈内存的过程不需要节省CPU资源，也不需要是瞬时的。</p></li><li><p>使用不同的方法返回除可用内存以外的内存。</p></li><li><p>支持除G1之外的其他收集器。</p></li></ul><p><strong>成功标准</strong>：</p><p>如果应用程序活动非常低，G1应该在合理的时间段内释放未使用的Java堆内存。</p><p><strong>动机</strong>：</p><p>目前G1垃圾收集器可能无法及时将已提交的Java堆内存返回给操作系统。G1仅在full GC或并发周期内从Java堆返回内存。由于G1很难完全避免full GC，并且只触发基于Java堆占用和分配活动的并发周期，因此除非在外部强制执行，否则在许多情况下它不会返回Java堆内存。</p><p>在使用资源支付的容器环境中，这种行为特别不利。即使在VM由于不活动而仅使用其分配的内存资源的一小部分的阶段，G1也将保留所有Java堆。这导致客户始终为所有资源付费，云提供商无法充分利用其硬件。</p><p>如果VM能够检测到Java堆的利用率不足（“空闲”阶段），并在此期间自动减少其堆使用量，则两者都将受益。</p><p>Shenandoah和OpenJ9的GenCon收集器已经提供了类似的功能。</p><p>在<a href="http://www.gsd.inesc-id.pt/~rbruno/publications/rbruno-ismm18.pdf" target="_blank" rel="noopener">Bruno et al., section 5.5</a>中使用原型进行的测试表明，基于在白天为HTTP请求提供服务的Tomcat服务器的实际利用情况（夜间大部分空闲），此解决方案可以将Java VM提交的内存量减少85％。</p><p><strong>描述</strong>：</p><p>为了实现向操作系统返回最大内存量的目标，G1将在应用程序不活动期间定期尝试继续或触发并发周期以确定整体Java堆使用情况。这将导致它自动将Java堆的未使用部分返回给操作系统。（可选）在用户控制下，可以执行full GC以最大化返回的内存量。</p><p>如果以下两者都发生，应用程序将被视为非活动状态，并且G1会触发定期垃圾收集：</p><ul><li><p>自任何先前的垃圾收集停顿以来已超过<code>G1PeriodicGCInterval</code>毫秒，此时没有正在进行的并发周期。值为零表示禁用快速回收内存的定期垃圾收集。</p></li><li><p>JVM主机系统（例如容器）上的<code>getloadavg()</code>调用返回的平均一分钟系统负载值低于<code>G1PeriodicGCSystemLoadThreshold</code>。如果<code>G1PeriodicGCSystemLoadThreshold</code>为零，则忽略此条件。</p></li></ul><p>如果不满足这些条件中的任何一个，则取消当前的预期定期垃圾收集。下次<code>G1PeriodicGCInterval</code>时间过去时，将重新考虑定期垃圾收集。</p><p>周期性垃圾收集的类型由<code>G1PeriodicGCInvokesConcurrent</code>选项的值确定：如果设置，G1继续或启动并发周期，否则G1执行full GC。在任一收集过程的末尾，G1调整当前的Java堆大小，可能会将内存返回给操作系统。新的Java堆大小由用于调整Java堆大小的现有配置确定，包括但不限于<code>MinHeapFreeRatio</code>，<code>MaxHeapFreeRatio</code>以及最小和最大堆大小配置。</p><p>默认情况下，G1在此定期垃圾回收期间启动或继续并发循环。这最大限度地减少了应用程序的中断，但与完整收集相比，最终可能无法返回尽可能多的内存。</p><p>由此机制触发的任何垃圾收集都使用<code>G1 Periodic Collection</code>进行标记。此类日志示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(1) [6.084s][debug][gc,periodic ] Checking for periodic GC.</span><br><span class="line">    [6.086s][info ][gc          ] GC(13) Pause Young (Concurrent Start) (G1 Periodic Collection) 37M-&gt;36M(78M) 1.786ms</span><br><span class="line">(2) [9.087s][debug][gc,periodic ] Checking for periodic GC.</span><br><span class="line">    [9.088s][info ][gc          ] GC(15) Pause Young (Prepare Mixed) (G1 Periodic Collection) 9M-&gt;9M(32M) 0.722ms</span><br><span class="line">(3) [12.089s][debug][gc,periodic ] Checking for periodic GC.</span><br><span class="line">    [12.091s][info ][gc          ] GC(16) Pause Young (Mixed) (G1 Periodic Collection) 9M-&gt;5M(32M) 1.776ms</span><br><span class="line">(4) [15.092s][debug][gc,periodic ] Checking for periodic GC.</span><br><span class="line">    [15.097s][info ][gc          ] GC(17) Pause Young (Mixed) (G1 Periodic Collection) 5M-&gt;1M(32M) 4.142ms</span><br><span class="line">(5) [18.098s][debug][gc,periodic ] Checking for periodic GC.</span><br><span class="line">    [18.100s][info ][gc          ] GC(18) Pause Young (Concurrent Start) (G1 Periodic Collection) 1M-&gt;1M(32M) 1.685ms</span><br><span class="line">(6) [21.101s][debug][gc,periodic ] Checking for periodic GC.</span><br><span class="line">    [21.102s][info ][gc          ] GC(20) Pause Young (Concurrent Start) (G1 Periodic Collection) 1M-&gt;1M(32M) 0.868ms</span><br><span class="line">(7) [24.104s][debug][gc,periodic ] Checking for periodic GC.</span><br><span class="line">    [24.104s][info ][gc          ] GC(22) Pause Young (Concurrent Start) (G1 Periodic Collection) 1M-&gt;1M(32M) 0.778ms</span><br></pre></td></tr></table></figure><p>在上面的示例中，使用<code>G1PeriodicGCInterval</code>为3000ms运行，在步骤（1）G1中，在应用程序不活动之后，启动并发周期，如（<code>Concurrent Start</code>）和（<code>G1 Periodic Collection</code>）所示。 该并发周期最初返回一些内存，通过从（1）到（2）的容量数（78M）和（32M）的减少来表示。 在（2）到（4）之间的间隔中，触发更多的周期性收集，这次触发mixed collection以对堆进行整理。（5）到（7）启动并发周期，因为G1策略确定当时在老年代中没有足够的垃圾来启动mixed GC阶段。在这种情况下，定期垃圾收集（5）到（7）不会进一步缩小堆，因为已经达到最小堆大小。</p><p>在应用程序不活动期间对对象活跃性的改变（例如，由于软引用到期）可以在空闲期间触发进一步缩小已提交的Java堆。</p><p><strong>选择</strong>：</p><p>可以从VM外部实现类似的功能，例如，通过jcmd工具或注入VM的一些代码。这有隐藏的成本：假设使用cron-based任务执行检查，如果节点上有数百或数千个容器，这可能意味着堆压缩操作由许多这些容器同时执行， 导致主机上出现非常大的CPU峰值。</p><p>另一种替代方法是Java代理，它自动附加到每个Java进程。然后，当容器在不同的时间开始时，检查的时间会自然分配，而且由于没有启动任何新进程，因此在CPU上的成本更低。然而，这种方法为用户增加了显著的复杂性，这可能会阻碍采用。</p><p>给定的用例，及时缩小Java堆，被认为是一个相当常见的用例，需要在VM中提供特殊支持。</p><p><strong>风险和假设</strong>：</p><p>在配置的默认值中，我们禁用此功能。 这导致延迟或吞吐量敏感应用程序的VM行为没有意外更改。启用后，我们假设通常需要将Java堆内存返回给操作系统，并且所产生的并发周期或其继续对应用程序吞吐量的影响可以忽略不计。</p><p>启用此功能后，VM将在上述条件下运行这些定期收集，而不管其他option如何。 例如，VM可以假设如果用户将<code>-Xms</code>设置为-<code>Xmx</code>和其他（组合）选项以获得最小且一致的垃圾收集暂停。出于一致性原因，情况并非如此。</p><p>如果定期垃圾收集仍然会太干扰程序执行，我们提供控制以让决策考虑整个系统CPU负载，或让用户完全禁用定期垃圾收集。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/28/5c9c829850beb.jpg&quot; alt=&quot;OpenJDK.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;OpenJDK 12是由JSR 386在Java Community Process中指定的Java SE平台的版本12的开源参考实现，于2019年3月19日达到General Availability版本。GPL(General Public License)协议下的生产就绪二进制文件可从Oracle获得；其他供应商的二进制文件很快就会出现。&lt;/p&gt;
&lt;p&gt;该版本的功能和时间表是通过JEP流程提出和跟踪的，并由JEP 2.0提案进行了修订。该版本使用JDK Release Process（JEP 3）生成发布。&lt;/p&gt;
&lt;p&gt;本文根据OpenJDK 12的官方文档：&lt;a href=&quot;http://openjdk.java.net/projects/jdk/12/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OpenJDK 12&lt;/a&gt;，对其新特性进行整理，受本人翻译水平所限，难免有翻译或理解错误，望不吝指正。上篇看这里：&lt;a href=&quot;https://f8f-1bearcat.github.io/2019/03/26/OpenJDK12%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/#jump334&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OpenJDK12的新特性（上）&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="OpenJDK" scheme="http://yoursite.com/tags/OpenJDK/"/>
    
  </entry>
  
  <entry>
    <title>OpenJDK12的新特性（上）</title>
    <link href="http://yoursite.com/2019/03/26/OpenJDK12%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://yoursite.com/2019/03/26/OpenJDK12的新特性（上）/</id>
    <published>2019-03-26T07:27:06.771Z</published>
    <updated>2019-04-03T06:09:27.158Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/03/28/5c9c829850beb.jpg" alt="OpenJDK.jpg"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>OpenJDK 12是由JSR 386在Java Community Process中指定的Java SE平台的版本12的开源参考实现，于2019年3月19日达到General Availability版本。GPL(General Public License)协议下的生产就绪二进制文件可从Oracle获得；其他供应商的二进制文件很快就会出现。</p><p>该版本的功能和时间表是通过JEP流程提出和跟踪的，并由JEP 2.0提案进行了修订。该版本使用JDK Release Process（JEP 3）生成发布。</p><p>本文根据OpenJDK 12的官方文档：<a href="http://openjdk.java.net/projects/jdk/12/" target="_blank" rel="noopener">OpenJDK 12</a>，对其新特性进行整理，受本人翻译水平所限，难免有翻译或理解错误，望不吝指正。</p><a id="more"></a><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><table><thead><tr><th>JEP</th><th>Features</th></tr></thead><tbody><tr><td>189:</td><td><a href="#jump189">Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)</a></td></tr><tr><td>230:</td><td><a href="#jump230">Microbenchmark Suite</a></td></tr><tr><td>325:</td><td><a href="#jump325">Switch Expressions (Preview)</a></td></tr><tr><td>334:</td><td><a href="#jump334">JVM Constants API</a></td></tr><tr><td>340:</td><td><a href="#jump340">One AArch64 Port, Not Two</a></td></tr><tr><td>341:</td><td><a href="#jump341">Default CDS Archives</a></td></tr><tr><td>344:</td><td><a href="#jump344">Abortable Mixed Collections for G1</a></td></tr><tr><td>346:</td><td><a href="#jump346">Promptly Return Unused Committed Memory from G1</a></td></tr></tbody></table><p><strong>注意</strong>：因篇幅限制，下文将对OpenJDK 12的新特性：189、230、325、334进行整理，剩余特性的整理请见下篇：<a href="https://f8f-1bearcat.github.io/2019/03/26/OpenJDK12%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8B%EF%BC%89/#more" target="_blank" rel="noopener">OpenJDK12的新特性（下）</a>。</p><h4 id="JEP189-Shenandoah-A-Low-Pause-Time-Garbage-Collector-Experimental"><a href="#JEP189-Shenandoah-A-Low-Pause-Time-Garbage-Collector-Experimental" class="headerlink" title="JEP189: Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)"></a><span id="jump189">JEP189: Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)</span></h4><p>低GC停顿的垃圾收集器(Experimental版本)</p><p><strong>摘要</strong>：</p><p>添加一个名为Shenandoah的新垃圾收集（GC）算法，在执行GC动作时可以通过并发的方式让Java程序继续执行，从而缩短Stop_The_World的时间。使用Shenandoah的停顿时间与堆大小无关，这意味着无论堆是200 MB还是200 GB，都将具有相同的稳定停顿时间。</p><p><strong>非目标</strong>：</p><p>这个GC算法并不是万能的，还有其他的垃圾收集算法会优先考虑吞吐量或者内存占用，而不是响应性。Shenandoah算法适用于那些注重响应性和可预测的停顿时间的应用，它并不能解决所有的JVM停顿问题，那些由于GC之外的其他原因，如达到安全点的时间（TTSP）或者监控通胀，导致的停顿时间超出了此JEP的范围。</p><p><strong>成功标准</strong>：</p><p>保持一致的较短的GC停顿时间。</p><p><strong>描述</strong>：</p><p>现代机器拥有比以往更多的内存和更多的处理器。服务水平协议（SLA）应用程序保证响应时间为10-500毫秒。为了满足该目标的低端，我们需要足够高效垃圾收集算法以允许程序在可用内存中运行，而且也要能做到永远不会中断正在运行的程序超过几毫秒。 Shenandoah是OpenJDK开源的低停顿收集器，旨在让我们更接近这些目标。</p><p>Shenandoah通过牺牲并发cpu周期和空间以优化停顿时间。我们为每个Java对象添加了一个间接指针，使得GC线程进行Java堆整理时能够与用户线程并发执行。由于整个GC过程中耗时最长的并发标记和整理过程收集器线程与用户线程可以一起工作，所以只需要在扫描线程堆栈以枚举根节点时停顿Java执行线程。</p><p>Shenandoah算法在<a href="https://www.researchgate.net/publication/306112816_Shenandoah_An_open-source_concurrent_compacting_garbage_collector_for_OpenJDK" target="_blank" rel="noopener">this PPPJ2016 paper</a>中有详细描述。</p><p>Shenandoah已经应用并且将由Red Hat提供aarch64和amd64支持。</p><p>在OpenJDK Shenandoah项目中的Shenandoah开发已经完成。在<a href="https://wiki.openjdk.java.net/display/shenandoah/Main" target="_blank" rel="noopener">Shenandoah wiki page</a>页面上查看有关当前开发流程，实现细节和可用性的更多详细信息。</p><p><strong>选择</strong>：</p><p>Zing/Azul有一个更低停顿的收集器，但是这项工作还没有贡献给OpenJDK。</p><p>ZGC有基于彩色指针的低停顿收集器， 我们期待比较两种策略的表现。</p><p>G1执行一些平行和并发工作，但它不执行并发回收（编者注：G1的筛选回收阶段，从Sun公司透漏出的信息来看，其实是支持与用户线程并发执行的，但是由于只会有一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率）。</p><p>CMS执行并发标记，但它在停顿时执行年轻代复制，并且从不整理老年代， 这导致花费更多时间来管理老年代中的可用空间以及碎片问题（编者注：CMS是基于“标记-清除”算法实现的收集器，这就意味着收集结束的时候将有大量的空间碎片产生）。</p><p><strong>建立和调用</strong>：</p><p>作为实验性功能，Shenandoah要求在命令行中配置<code>-XX:+UnlockExperimentalVMOptions</code>参数，构建系统会自动禁用不受支持的配置。下游构建者可以选择在其他支持的平台上使用<code>--with-jvm-features = -shenandoahgc</code>禁用构建Shenandoah。</p><p>要启用/使用Shenandoah GC，需要使用以下JVM选项：<code>-XX:+UnlockExperimentalVMOptions</code>                                <code>-XX:+UseShenandoahGC</code>。</p><p>想要获取有关如何设置和调整Shenandoah GC的更多信息，请参阅<a href="https://wiki.openjdk.java.net/display/shenandoah/Main" target="_blank" rel="noopener">Shenandoah wiki</a>页面。</p><p><strong>测试</strong>：</p><p>Red Hat已经为我们的重要应用程序进行了大量测试。我们开发了许多Shenandoah特定的jtreg测试。Shenandoah从Fedora 24开始在Fedora中传送，并在Rhel 7.4中作为技术预览。使用<code>-XX:+UseShenandoahGC</code>运行标准的OpenJDK测试就足够了。</p><p><strong>风险和假设</strong>：</p><p>GC接口（JEP 304）已集成在JDK 11中，之后对GC接口进行了许多扩展和改进，这样可以最大限度地降低将Shenanodah添加到OpenJDK源代码库的风险。除此之外，任何无法合理编址的Shenandoah-specific代码路径都将受到<code>#ifdef INCLUDE_SHENANDOAHGC</code>或类似机制的保护。Shenandoah GC最初将被标记为实验性功能，因此在配置参数方面除<code>-XX:+UseShenandoahGC</code>之外还需要<code>-XX:+UnlockExperimentalVMOptions</code>。</p><h4 id="JEP230-Microbenchmark-Suite"><a href="#JEP230-Microbenchmark-Suite" class="headerlink" title="JEP230: Microbenchmark Suite"></a><span id="jump230">JEP230: Microbenchmark Suite</span></h4><p>Microbenchmark 套件</p><p><strong>摘要</strong>：</p><p>在JDK源代码中添加一套基本的microbenchmarks ，使开发人员可以轻松运行现有的microbenchmarks 并创建新的microbenchmarks 。</p><p><strong>目标</strong>：</p><ul><li>基于[Java Microbenchmark Harness（JMH）];<a href="http://openjdk.java.net/projects/code-tools/jmh" target="_blank" rel="noopener">[1]</a></li><li>稳定且经过调整的benchmarks，针对持续性能测试<br> ​    ​    - 在feature release以及non-feature releases的Feature Complete milestone之后提供稳定且不移动的套件<br> ​    ​    - 支持与先前JDK版本的适用测试比较</li><li>简易<ul><li>轻松添加新benchmarks</li><li>在APIs和options更改、不推荐使用或在开发期间删除时，可以轻松更新测试</li><li>易于构建</li><li>易于查找和运行benchmark</li></ul></li><li>支持JMH更新</li><li>在组件中包含大约一百个benchmarks的初始集</li></ul><p><strong>非目标</strong>：</p><ul><li><p>为新的JDK功能提供benchmarks不是目标，为新功能添加benchmarks是这些项目的一部分。</p></li><li><p>创建一套完整的benchmarks来覆盖JDK中所有内容不是目标。随着时间的推移，该套件将继续通过新编写的benchmarks，或通过专门针对扩展其覆盖范围的协作进行扩展。</p></li><li><p>为处理microbenchmarks中的二进制依赖提供解决方案不是目标，稍后可能会添加对此的支持。</p></li></ul><p><strong>描述</strong>：</p><p>microbenchmark套件将与JDK源代码位于一个目录下，并且在构建时将生成单个JAR文件。协同定位将简化在开发期间添加和定位benchmarks。在运行benchmarks时，JMH提供强大的过滤功能，允许用户仅运行当前感兴趣的benchmarks，确切的位置仍有待确定。</p><p>Benchmarking 通常需要与早期build甚至release版本进行比较，因此microbenchmarks 必须支持JDK（N），用于针对新JDK和JDK（N-1）中的特性，以及存在于早期release版本中的特性的benchmarks 。 这意味着，对于JDK 12，结构和构建脚本必须支持JDK 12和JDK 11的编译benchmarks 。benchmarks 将进一步使用描述他们正在测试的JDK区域的Java包名称进行划分。</p><p>建议使用以下目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jdk/jdk</span><br><span class="line">   .../make/test (Shared folder for Makefiles)</span><br><span class="line">   .../test (Shared folder for functional tests)</span><br><span class="line">      .../micro/org/openjdk/bench</span><br><span class="line">         .../java (subdirectories similar to JDK packages and modules)</span><br><span class="line">         .../vm (subdirectories similar to HotSpot components)</span><br></pre></td></tr></table></figure><p>microbenchmark套件的构建将与普通的JDK构建系统集成。它将是一个单独的目标，在正常的JDK构建期间不会执行，以便为开发人员和其他对构建微基准套件不感兴趣的人保持较低的构建时间。要构建微基准套件，用户必须专门运行make build-microbenchmark或类似工具。另外，将支持使用<code>make test TEST =“micro：regexp”</code>运行基准测试。有关如何设置本地环境的说明将记录在<code>docs / testing.md | html</code>中。</p><p>benchmark将完全依赖于JMH，就像某些单元测试依赖于TestNG或jtreg一样，所以虽然对JMH的依赖是新的，但是构建的其他部分具有相似的依赖性。与jtreg相比的一个区别是JMH在构建期间都被使用，并且被打包为生成的JAR文件的一部分。</p><p>microbenchmark套件中的benchmark集将从<code>JMH JDK Microbenchmarks</code>项目中导入。这些构成了一组已在内部使用的经过调整和测试的microbenchmark。一个悬而未决的问题是，是将整个独立项目整体迁移到共处套件，还是将其作为更长寿命回归测试的stabilization forest。</p><p>但是，任何用户仍然希望确保其他参数（例如执行机器和JDK）在进行分析时是稳定且可比较的。在通常情况下，我们希望benchmark能够在不到一分钟的时间内完成整个运行。这不是大型或长期运行benchmark的包装框架；目标是提供一套快速且有针对性的benchmark。在某些特殊情况下，benchmark可能需要更长时间的预热或运行时间才能获得稳定的结果，但应尽可能避免这种情况。套件的目标不是充当大型工作负载的通用包装器；相反，意图是从更大的benchmark中提取关键组件或方法，并仅将该部分强调为microbenchmark。</p><p>作为该项目的一部分，将创建<a href="https://wiki.openjdk.java.net" target="_blank" rel="noopener">wiki.openjdk.java.net</a>上的新页面，以帮助解释如何开发新benchmarks并描述添加benchmark的要求。这些要求将要求遵守编码标准、可重现的性能，以及明确的benchmark测量文档及其测量内容。</p><p><strong>选择</strong>：</p><p>继续将microbenchmark套件维护为一个单独的项目<a href="http://openjdk.java.net/projects/code-tools/jmh-jdk-microbenchmarks/" target="_blank" rel="noopener">[2]</a>。</p><p>协同定位简化了为新功能添加benchmark，特别是在所有新功能开发的大部分在项目存储库（Valhalla，Amber等）中完成的世界中。 在单独的项目模型中被证明特别复杂的情况是测试对javac本身的更改，需要使用每个相应的JDK显式重建benchmark套件。 协同定位可以更优雅地解决这个特定用例，同时不禁止使用预先构建的benchmark捆绑包来在较长时间段内对稳定测试进行性能跟踪。</p><p><strong>测试</strong>：</p><p>作为常规性能测试的一部分，性能团队将验证microbenchmark测试，以确保仅添加稳定、调整好的和准确的microbenchmark测试。 还将根据具体情况对基准进行评估和分析，以确保其测试预期的功能。所有测试必须在所有适用的平台上运行多次，以确保它们稳定。</p><h4 id="JEP325-Switch-Expressions-Preview"><a href="#JEP325-Switch-Expressions-Preview" class="headerlink" title="JEP325:  Switch Expressions (Preview)"></a><span id="jump325">JEP325:  Switch Expressions (Preview)</span></h4><p><strong>摘要</strong>：</p><p>扩展switch语句，以便它可以用作语句或表达式，并且这两种形式都可以使用“traditional”或“simplified”的作用域，都可以实现对程序的流程控制。 这些更改将简化日常编码，并为在switch语句中使用模式匹配（JEP 305）做好准备。 </p><p><strong>动机</strong>：</p><p>当我们准备增强Java编程语言以支持模式匹配（JEP 305）时，现有switch语句的一些不规则性（长期以来一直是用户的烦恼）成为我们工作的障碍。这包括switch blocks的默认控制流行为（fall through），switch blocks的默认作用域，还包括对switch使用时仅作为语句，尽管作为表达式的话实现multi-way conditionals通常更自然。</p><p>当前Java的switch语句设计紧随C和C++等语言，并且默认支持fall-through语义。虽然这种传统的控制流通常用于编写low-level代码（例如用于二进制编码的解析器），但随着switch用于higher-level的contexts，其error-prone的性质开始超过其灵活性。</p><p>例如，在下面的代码中，许多break语句使它不必要地冗长，并且这种视觉干扰经常掩盖难以debug的错误，比如缺少break语句将导致发生意外的fall-through错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY:</span><br><span class="line">    <span class="keyword">case</span> FRIDAY:</span><br><span class="line">    <span class="keyword">case</span> SUNDAY:</span><br><span class="line">        System.out.println(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TUESDAY:</span><br><span class="line">        System.out.println(<span class="number">7</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> THURSDAY:</span><br><span class="line">    <span class="keyword">case</span> SATURDAY:</span><br><span class="line">        System.out.println(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY:</span><br><span class="line">        System.out.println(<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将引入一种新形式的switch label，写成“case L  - &gt;”，用来表示如果标签匹配则只执行标签右侧的代码。 例如， 前面的代码现在可以写成下面这种形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">case</span> TUESDAY                -&gt; System.out.println(<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">case</span> THURSDAY, SATURDAY     -&gt; System.out.println(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY              -&gt; System.out.println(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（此示例还使用多个case 标签：我们支持在单个switch label中多个标签以逗号分隔开。）</p><p>“case L  - &gt;”开关标签右侧的代码仅限于表达式、块或（为方便起见）throw语句。 这具有令人满意的结果，如果一条分支（arm）引入局部变量，则它必须包含在该分支的块中，不在 switch block中的任何其他分支的作用域内。 这消除了“traditional”作用域的switch block的另一个烦恼，即局部变量的范围是整个switch block。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY:</span><br><span class="line">    <span class="keyword">case</span> TUESDAY:</span><br><span class="line">        <span class="keyword">int</span> temp = ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY:</span><br><span class="line">    <span class="keyword">case</span> THURSDAY:</span><br><span class="line">        <span class="keyword">int</span> temp2 = ...     <span class="comment">// Why can't I call this temp?</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">int</span> temp3 = ...     <span class="comment">// Why can't I call this temp?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>许多现有的switch语句本质上是switch表达式的模拟，其中每个arm分配给一个公共目标变量或返回一个值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numLetters;</span><br><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY:</span><br><span class="line">    <span class="keyword">case</span> FRIDAY:</span><br><span class="line">    <span class="keyword">case</span> SUNDAY:</span><br><span class="line">        numLetters = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TUESDAY:</span><br><span class="line">        numLetters = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> THURSDAY:</span><br><span class="line">    <span class="keyword">case</span> SATURDAY:</span><br><span class="line">        numLetters = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY:</span><br><span class="line">        numLetters = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Wat: "</span> + day);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种作为语句进行表述是拐弯抹角的、重复的、并且容易出错。上面的代码旨在每天为numLetters赋一个值。直说的话，使用一个switch表达式将更清晰、更安全：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numLetters = <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY, FRIDAY, SUNDAY -&gt; <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">case</span> TUESDAY                -&gt; <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">case</span> THURSDAY, SATURDAY     -&gt; <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY              -&gt; <span class="number">9</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>反过来，将switch扩展到支持表达式会引发一些额外的需求，例如扩展流分析（表达式必须始终计算值或突然完成），并允许switch表达式的某些case arm抛出异常而不是产生值。</p><p><strong>描述</strong>：</p><p>除了“traditional”的switch block之外，我们还建议添加一个新的“simplified”形式，使用新的“case L  - &gt;”switch标签。如果标签匹配，则只执行箭头标签右侧的表达式或语句，并且没有fall through。例如，给定方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">howMany</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (k) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> -&gt; System.out.println(<span class="string">"one"</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span> -&gt; System.out.println(<span class="string">"two"</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span> -&gt; System.out.println(<span class="string">"many"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">howMany(<span class="number">1</span>);</span><br><span class="line">howMany(<span class="number">2</span>);</span><br><span class="line">howMany(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>得到以下输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">many</span><br></pre></td></tr></table></figure><p>我们将扩展switch语句，以便它可以另外作为表达式来使用。 在常见情况下，switch表达式如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T result = <span class="keyword">switch</span> (arg) &#123;</span><br><span class="line">    <span class="keyword">case</span> L1 -&gt; e1;</span><br><span class="line">    <span class="keyword">case</span> L2 -&gt; e2;</span><br><span class="line">    <span class="keyword">default</span> -&gt; e3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>switch表达式是多边表达式，如果目标类型已知，则将此类型下推到每个arm中。如果已知，switch表达式的类型是其目标类型；如果未知，则通过组合每个case arm的类型来计算独立的类型。</p><p>大多数switch表达式在“case L  - &gt;”开关标签的右侧都有一个表达式。 如果需要一个完整的块，我们扩展了break语句以获取一个参数，该参数成为封闭的switch表达式的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int j = switch (day) &#123;</span><br><span class="line">    case MONDAY  -&gt; 0;</span><br><span class="line">    case TUESDAY -&gt; 1;</span><br><span class="line">    default      -&gt; &#123;</span><br><span class="line">        int k = day.toString().length();</span><br><span class="line">        int result = f(k);</span><br><span class="line">        break result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与switch语句一样，switch表达式也可以使用带有“case L:”switch标签的“traditional”switch block。在这种情况下，将使用break with value语句生成值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = <span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Foo"</span>: </span><br><span class="line">        <span class="keyword">break</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Bar"</span>:</span><br><span class="line">        <span class="keyword">break</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">"Neither Foo nor Bar, hmmm..."</span>);</span><br><span class="line">        <span class="keyword">break</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两种形式的break（有值和无值）类似于方法中return的两种形式。两种形式的return都会立即终止方法的执行；在非void方法中，还必须提供一个值，该值被赋予方法的调用者。</p><p>switch表达式的case必须是详尽的，对于任何可能的值，必须有匹配的switch标签。实际上，这通常意味着只需要一个default子句；但是，如果枚举switch表达式涵盖了所有已知情况，default子句可以由编译器插入，即枚举定义在编译时和运行时之间发生了变化。</p><p>此外，switch表达式必须正常使用值完成，或抛出异常。编译器检查每个switch标签是否匹配，然后可以产生一个值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"Monday"</span>); </span><br><span class="line">        <span class="comment">// ERROR! Block doesn't contain a break with value</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line">i = <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY, TUESDAY, WEDNESDAY: </span><br><span class="line">        <span class="keyword">break</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">        System.out.println(<span class="string">"Second half of the week"</span>);</span><br><span class="line">        <span class="comment">// ERROR! Group doesn't contain a break with value</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>控制语句、break、return和continue不能跳过switch表达式，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">z: </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_VALUE; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="keyword">switch</span> (e) &#123; </span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:  </span><br><span class="line">                <span class="keyword">break</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">default</span>: </span><br><span class="line">                <span class="keyword">continue</span> z; </span><br><span class="line">                <span class="comment">// ERROR! Illegal jump through a switch expression </span></span><br><span class="line">        &#125;;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>同时，我们可以扩展switch以支持先前不允许的原始类型（及其装箱类型），例如float，double和long。</p><h4 id="JEP334-JVM-Constants-API"><a href="#JEP334-JVM-Constants-API" class="headerlink" title="JEP334: JVM Constants API"></a><span id="jump334">JEP334: JVM Constants API</span></h4><p><strong>摘要</strong>：</p><p>引入API来规范key class-file和run-time artifacts（特别是可从常量池加载的常量）的标称描述。</p><p><strong>动机</strong>：</p><p>每个Java类文件都有一个常量池，用于存储类中字节码指令的操作数。从广义上讲，常量池中的条目描述了运行时构件（如类和方法）或简单值（如字符串和整数）。所有这些条目都称为可加载常量，因为它们可以作为ldc指令的操作数（“加载常量”）。它们也可能出现在invokedynamic指令的bootstrap方法的静态参数列表中。执行ldc或invokedynamic指令会将可装入常量解析为标准Java类型的“实时”值，例如Class，String或int。</p><p>操作类文件的程序需要对字节码指令进行建模，然后再加载可加载的常量。但是，使用标准Java类型来规范可加载常量是不合适的。描述字符串（CONSTANT_String_info条目）的可加载常量可能是可以接受的，因为生成“实时”String对象很简单，但是对于描述类（CONSTANT_Class_info条目）的可加载常量是有问题的，因为生成“实时”类对象依赖于类加载的正确性和一致性。不幸的是，类加载有许多环境依赖和失败模式：所需的类不存在或者请求者可能无法访问；类加载的结果因上下文而异；装载类有副作用；有时类加载可能根本不可能（例如当所描述的类尚不存在或者不可加载时，如在编译那些相同的类期间，或在jlink-time转换期间）。</p><p>因此，处理可加载常量的程序如果能够以纯粹的名义符号形式操作类和方法，以及不太知名的构件（如方法句柄和动态计算常量），则会更简单：</p><ul><li><p>字节码解析和生成库必须以符号形式描述类和方法句柄。如果没有标准机制，它们必须求助于ad-hoc机制，无论是描述符类型（如ASM的Handle）还是字符串元组（方法所有者，方法名称，方法描述符），或者ad-hoc（和容易出错）的编码成一个字符串。</p></li><li><p>如果可以在符号域中工作而不是使用“实时”类和方法句柄，则通过旋转字节码（例如LambdaMetafactory）操作的invokedynamic的bootstraps会更简单。</p></li><li><p>编译器和脱机转换器（例如jlink插件）需要描述无法加载到正在运行的VM的类的类和成员。编译器插件（例如注释处理器）同样需要用符号术语来描述程序元素。</p></li></ul><p>这些类型的库和工具都将受益于使用单一，标准的方式来描述可加载常量。</p><p><strong>描述</strong>：</p><p>我们在新的java.lang.invoke.constant包中定义了一系列基于值的符号引用（JVMS 5.1）类型，能够描述每种可加载常量。符号引用描述了纯粹标称形式的可加载常量，与类加载或可访问性上下文分开。 有些类可以作为自己的符号引用（例如String）；对于可链接常量，我们定义了一系列符号引用类型（ClassDesc，MethodTypeDesc，MethodHandleDesc和DynamicConstantDesc），它们包含描述这些常量的标称信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/28/5c9c829850beb.jpg&quot; alt=&quot;OpenJDK.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;OpenJDK 12是由JSR 386在Java Community Process中指定的Java SE平台的版本12的开源参考实现，于2019年3月19日达到General Availability版本。GPL(General Public License)协议下的生产就绪二进制文件可从Oracle获得；其他供应商的二进制文件很快就会出现。&lt;/p&gt;
&lt;p&gt;该版本的功能和时间表是通过JEP流程提出和跟踪的，并由JEP 2.0提案进行了修订。该版本使用JDK Release Process（JEP 3）生成发布。&lt;/p&gt;
&lt;p&gt;本文根据OpenJDK 12的官方文档：&lt;a href=&quot;http://openjdk.java.net/projects/jdk/12/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OpenJDK 12&lt;/a&gt;，对其新特性进行整理，受本人翻译水平所限，难免有翻译或理解错误，望不吝指正。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="OpenJDK" scheme="http://yoursite.com/tags/OpenJDK/"/>
    
  </entry>
  
  <entry>
    <title>日志分析接口协议的设计与实现</title>
    <link href="http://yoursite.com/2019/03/25/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E6%8E%A5%E5%8F%A3%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/03/25/日志分析接口协议设计与实现/</id>
    <published>2019-03-25T09:35:20.701Z</published>
    <updated>2019-03-26T03:26:54.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p><img src="https://cdn2.iconfinder.com/data/icons/productivity-social-vol-2/512/checkmark_approve-128.png" alt="Choice"><br>通过日志信息对RPC服务调用的用户进行监控，提高系统的稳定性。本文简要记录了一下日志分析接口协议的设计与实现.<br><a id="more"></a></p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="HTTP接口"><a href="#HTTP接口" class="headerlink" title="HTTP接口"></a>HTTP接口</h3><p>请求方式： <code>post</code><br>请求参数： </p><ul><li>HTTP header<br><code>Content-Type=application/json    （必须）</code></li><li><p>HTTP body</p><pre><code>{</code></pre><p>  ​        “log_project_name”:”testhttp”,<br>  ​        “log_message_type”:”request”,<br>  ​        “log_format”:”default”,<br>  ​        “log_from”:”172.0.0.1”,<br>  ​        “log_content”:”2017-06-28 22:39:44,959 [P58,] communicationInfo - {\”cid\”:\”1111\”,\”clientIP\”:\”10.10.10.10\”,\”request\”:\”simpleSearch\”,\”timeAll\”:107,\”respLength\”:55555}”<br>  ​    }<br>  ​    </p></li></ul><p>body中为JSON字符串<br>JSON参数</p><blockquote><p>log_project_name：项目名称 同一个项目使用同一个名称<br>log_message_type：日志类型request (请求日志),error(错误日志)<br>log_format：日志格式default<br>log_from：日志来源机器每台机器写自己的IP作为一个标示<br>log_content：根据日志类型发送的日志内容（日志内容格式请见下文）</p></blockquote><h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><p>读取日志文件（日志内容格式请见下文）</p><h3 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h3><p>日志格式为两种</p><h4 id="日志格式为-request-解析类型为-default-日志为一行"><a href="#日志格式为-request-解析类型为-default-日志为一行" class="headerlink" title="日志格式为 request 解析类型为 default 日志为一行"></a>日志格式为 <code>request</code> 解析类型为 <code>default</code> 日志为一行</h4><p>示例:</p><pre><code>2017-06-21 22:37:44,959  -  {&quot;cid&quot;:&quot;1111&quot;,&quot;clientIP&quot;:&quot;10.10.10.10&quot;,&quot;request&quot;:&quot;simpleSearch&quot;,&quot;timeAll&quot;:107, &quot;respLength&quot;:55555}</code></pre><p>请求日志内容格式 分为3块</p><ol><li>时间开头格式必须为 <code>yyyy-MM-dd HH:mm:ss,SSS</code></li><li>分隔符 <code>-</code></li><li>JSON内容<blockquote><p>cid：用户ID<br> clientIP：客户端IP<br> request：请求业务类型<br> timeAll：耗时<br> respLength：返回大小</p></blockquote></li></ol><p><strong>注意：json中字段为必填字段若没有值则使用空字符串</strong></p><h4 id="日志格式为-error-解析类型为-default-日志可以为多行"><a href="#日志格式为-error-解析类型为-default-日志可以为多行" class="headerlink" title="日志格式为 error 解析类型为 default 日志可以为多行"></a>日志格式为 <code>error</code> 解析类型为 <code>default</code> 日志可以为多行</h4><p>示例</p><pre><code>2017-06-19 22:54:58,151  InfoThreadPool requestInfo http://www.eastmoney.com/ open error</code></pre><p>错误日志内容格式 分为2块</p><ol><li>时间开头格式必须为<code>yyyy-MM-dd HH:mm:ss,SSS</code></li><li>错误内容<br>注意:错误日志读取时，只匹配日志开头是否为此格式的时间，最多读取500行，当行中出现<code>eastmoney</code>关键字时，停止读取。</li></ol><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><h4 id="每一台服务器的访问情况"><a href="#每一台服务器的访问情况" class="headerlink" title="每一台服务器的访问情况"></a>每一台服务器的访问情况</h4><ul><li><code>LoginHandler</code>每次登录输出日志</li><li>日志内容字段<blockquote><p>cid：用户ID<br>  clientIP：客户端IP<br>  request：请求业务类型<br>  timeAll：耗时<br>  respLength：返回大小</p></blockquote></li></ul><h4 id="每个用户所做的操作"><a href="#每个用户所做的操作" class="headerlink" title="每个用户所做的操作"></a>每个用户所做的操作</h4><ul><li>调用Handler的doHandle()时输出日志<blockquote><p>cid：用户ID<br>  clientIP：客户端IP<br>  request：请求业务类型<br>  timeAll：耗时<br>  respLength：返回大小</p></blockquote></li></ul><p>count_info</p><pre><code>机房，服务器类型，服务器ip，服务器端口，用户数，时间，备注area,server_type,server_ip,server_port,count,time,desc</code></pre><p>user_log</p><pre><code>用户id,客户端ip,客户端端口,服务器ip，服务器端口，请求id，时间，备注clientid,remote_server,remote_port,server_ip,server_port,request_id,time,desc</code></pre><h4 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h4><p><strong>LIST_10.10.10.10_80-1818-443_sys.2017110620.log</strong></p><ul><li><p>request_id为 <strong>-1</strong>，预留位desc赋值为当前用户数（链接数），每分钟打印一次</p><blockquote><p>2017-10-30 13:26:00.574 - {“clientid”:””,”remote_server”:””,”remote_port”:””,”server_port”:””,”request_id”:-1,”desc”:”500”}</p></blockquote></li><li><p>request_id为 <strong>-2</strong>，预留位desc赋值为链接断线原因</p><blockquote><p>2017-10-30 13:26:00.574 - {“clientid”:”22000000000”,”remote_server”:”10.10.10.10”,”remote_port”:”30040”,”server_port”:”1818”,”request_id”:-2,”desc”:0}</p></blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> UNKNOWN = <span class="number">0</span>;   <span class="comment">//未知</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> WRITE_WAITE_MANY_TIMES = <span class="number">1</span>;   <span class="comment">//写等待次数过多</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> FORCE_NO_CANCEL_REQUEST = <span class="number">2</span>;   <span class="comment">//强制去除，客户端没有发送取消请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> CHANNEL_GROUP_CHECK = <span class="number">3</span>;   <span class="comment">//ChannelGroup检查关闭</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> HANDLER_EXCEPTION = <span class="number">4</span>;   <span class="comment">//Handler exceptionCaught触发</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> HANDLER_CLOSED = <span class="number">5</span>;   <span class="comment">//Handler Closed触发</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> CHANNEL_EXCEPTION = <span class="number">6</span>;   <span class="comment">//Handler Closed触发</span></span><br></pre></td></tr></table></figure></li><li><p>正常打印请求信息</p><blockquote><p>2017-10-30 13:26:00.574 - {“clientid”:”22000000000”,”remote_server”:”10.10.10.10”,”remote_port”:”30040”,”server_port”:”1818”,”request_id”:16066,”desc”:””}</p></blockquote></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>logback的使用和logback.xml详解:<a href="http://www.cnblogs.com/warking/p/5710303.html" target="_blank" rel="noopener">http://www.cnblogs.com/warking/p/5710303.html</a><br>logback.xml配置:<a href="http://blog.csdn.net/qq173684423/article/details/53611906" target="_blank" rel="noopener">http://blog.csdn.net/qq173684423/article/details/53611906</a><br>logback配置详解<a href="http://blog.csdn.net/haidage/article/details/6794509" target="_blank" rel="noopener">http://blog.csdn.net/haidage/article/details/6794509</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn2.iconfinder.com/data/icons/productivity-social-vol-2/512/checkmark_approve-128.png&quot; alt=&quot;Choice&quot;&gt;&lt;br&gt;通过日志信息对RPC服务调用的用户进行监控，提高系统的稳定性。本文简要记录了一下日志分析接口协议的设计与实现.&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
      <category term="RPC" scheme="http://yoursite.com/tags/RPC/"/>
    
      <category term="logback" scheme="http://yoursite.com/tags/logback/"/>
    
  </entry>
  
  <entry>
    <title>同步、异步、阻塞、非阻塞IO</title>
    <link href="http://yoursite.com/2019/01/29/%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9EIO/"/>
    <id>http://yoursite.com/2019/01/29/同步、异步、阻塞、非阻塞IO/</id>
    <published>2019-01-29T06:58:00.260Z</published>
    <updated>2019-01-31T06:43:45.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近在整理过去一段时间内Netty性能调优的工作，涉及到了Netty的NIO/Epoll等异步非阻塞通信，索性复习一下常见的几种IO模型。看到CSDN上这篇文章写得很清晰易懂，<a href="https://blog.csdn.net/historyasamirror/article/details/5778378" target="_blank" rel="noopener">IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）</a>，在此基础上整理了一下，方便记忆及以后查看。</p><a id="more"></a><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>IO发生时会经历两个阶段：</p><ul><li><p>等待数据</p></li><li><p>将数据从内核复制到用户空间</p></li></ul><p>不同的IO模型就是根据在这两个阶段所做的处理不同进行区分的。</p><h3 id="Blocking-IO"><a href="#Blocking-IO" class="headerlink" title="Blocking IO"></a>Blocking IO</h3><p><img src="https://i.loli.net/2019/01/30/5c5151d73a80d.jpg" alt="blocking IO.jpg"></p><p><strong>阻塞IO模型（BIO）</strong>：应用进程调用recvfrom，kernel开始了IO的第一阶段：等待数据，等到数据准备好了，kernel开始第二阶段：将数据从内核复制到用户空间。在IO的这两个阶段执行期间，应用进程一直处于block状态，直到kernel返回结果，应用进程阻塞才解除。</p><p>举例：你在美团上点了一份外卖，下单后外卖小哥开始取餐（阶段一），取到餐后再进行配送（阶段二），期间你一直站在门口等（block状态），直到收到外卖才继续自己的事情。</p><h3 id="Nonblocking-IO"><a href="#Nonblocking-IO" class="headerlink" title="Nonblocking IO"></a>Nonblocking IO</h3><p><img src="https://i.loli.net/2019/01/30/5c5151d7b62f1.jpg" alt="non-blocking IO.jpg"></p><p><strong>非阻塞IO模型（NIO）</strong>：应用进程调用recvfrom，kernel开始了IO的第一阶段：等待数据，如果kernel中的数据还没有准备好，就返回应用进程EWOULDBLOCK，应用进程收到返回后会一直调用recvfrom询问kernel，直到数据准备好，在此期间应用进程处于非block状态；然后kernel将数据从内核复制到用户空间，并block应用进程，直到成功返回后阻塞状态解除。所以非阻塞IO和阻塞IO不是完全对立的，在IO第二阶段二者均处于block状态。</p><p>举例：你在美团上点了一份外卖，下单后外卖小哥开始取餐（阶段一），在取餐期间你坐在屋里一遍看剧一边不断打电话给外卖小哥询问取到了没，直到小哥说他拿到了；这时小哥取到餐后进行配送（阶段二），你也起身站在门口等（block状态），直到收到外卖。</p><h3 id="IO-multiplexing"><a href="#IO-multiplexing" class="headerlink" title="IO multiplexing"></a>IO multiplexing</h3><p><img src="https://i.loli.net/2019/01/30/5c5151d7af63b.jpg" alt="IO multiplexing.jpg"></p><p><strong>IO复用模型</strong>：应用进程调用select，通过select可以不断的轮询所负责的所有socket，当某个socket的数据准备好了，select就会返回信息，然后用户态进程调用recvfrom，将数据从内核复制到用户空间。对于每一个socket，一般都设置成为non-blocking，但是整个应用进程受阻于select调用；同样，在IO的第二阶段，应用进程也是出于block状态。</p><p>如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于单个process就可以同时处理多个网络连接的IO。</p><p>Linux关于IO复用的使用，有三种不同的API，select、poll和epoll，关于这三种API的实现分析，可以参考下这篇文章：<a href="https://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="noopener">select、poll、epoll之间的区别总结[整理]</a>。</p><p>举例：这次你在美团上一次点了好几份外卖，美团的消息系统（select等API调用）推给你说等有外卖取到了就发消息给你，让你留意消息（block状态），然后几个外卖小哥就到不同的店去取餐（阶段一）。等取到餐了，如果你用的是select或poll版本的美团，消息推给你说你有订单已经取到了，但是不告诉你是哪家；如果你用的是epoll版本的美团，消息推给你说你有订单已经取到了，而且还告诉你是碳烤羊排。收到消息之后你就到门口去等（block状态），外卖小哥进行配送（阶段二），直到收到外卖才继续自己的事情。</p><h3 id="Asynchronous-IO"><a href="#Asynchronous-IO" class="headerlink" title="Asynchronous IO"></a>Asynchronous IO</h3><p><img src="https://i.loli.net/2019/01/30/5c5151d704ff1.jpg" alt="Asynchronous IO.jpg"></p><p><strong>异步IO模型（AIO）</strong>：应用进程调用aio_read，kernel收到请求后会立刻返回，等数据准备好，并且复制到用户空间后执行事先指定好的函数，整个过程应用进程都处于非block状态。</p><p>举例：你发现自己出去等太大笨蛋了，在美团上点了一份外卖，看到下单成功后就去看剧了。外卖小哥开始取餐（阶段一），取到餐后再进行配送（阶段二），最后送到你门口，整个过程你都在干自己的事情，没有一直等着（非block状态）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="IO模型对比"><a href="#IO模型对比" class="headerlink" title="IO模型对比"></a>IO模型对比</h3><p><img src="https://i.loli.net/2019/01/30/5c5151d774bba.jpg" alt="IO Models.jpg"></p><p>因为信号驱动式IO（signal-driven I/O）使用较少，正文中没提及。</p><p><strong>阻塞IO和非阻塞IO</strong>：调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p><p><strong>同步IO和异步IO</strong>：synchronous IO做”IO operation”的时候会将process阻塞，blocking IO，non-blocking IO，IO multiplexing因为都阻塞于recvfrom调用，都属于synchronous IO。</p><p><strong>非阻塞IO和异步IO</strong>：在数据准备阶段，non-blocking IO中进程不会被block，但是它仍然要求进程去主动的check，而asynchronous IO中应用进程进程将整个IO操作交给kernel来完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;最近在整理过去一段时间内Netty性能调优的工作，涉及到了Netty的NIO/Epoll等异步非阻塞通信，索性复习一下常见的几种IO模型。看到CSDN上这篇文章写得很清晰易懂，&lt;a href=&quot;https://blog.csdn.net/historyasamirror/article/details/5778378&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）&lt;/a&gt;，在此基础上整理了一下，方便记忆及以后查看。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>读懂Young GC日志</title>
    <link href="http://yoursite.com/2018/12/18/%E8%AF%BB%E6%87%82Young%20GC%E6%97%A5%E5%BF%97/"/>
    <id>http://yoursite.com/2018/12/18/读懂Young GC日志/</id>
    <published>2018-12-18T06:46:08.526Z</published>
    <updated>2018-12-19T01:41:01.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>在进行JVM调优时我们经常需要通过日志信息来分析G1GC的性能，本文就日志中可供收集的数据和信息进行了简单介绍。<br><a id="more"></a></p><h2 id="Young-GC日志"><a href="#Young-GC日志" class="headerlink" title="Young GC日志"></a>Young GC日志</h2><p>下面选取了SZVPC线上报价服务的一段Young GC日志：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;Heap before GC invocations=<span class="number">38623</span> (full <span class="number">4</span>):</span><br><span class="line"> garbage-first heap   total <span class="number">25165824</span>K, used <span class="number">11321508</span>K [<span class="number">0x00000001c0000000</span>, <span class="number">0x00000001c040c000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  region size <span class="number">4096</span>K, <span class="number">307</span> young (<span class="number">1257472</span>K), <span class="number">26</span> survivors (<span class="number">106496</span>K)</span><br><span class="line"> Metaspace       used <span class="number">23093</span>K, capacity <span class="number">23236</span>K, committed <span class="number">29440</span>K, reserved <span class="number">1075200</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 2444<span class="title">K</span>, <span class="title">capacity</span> 2510<span class="title">K</span>, <span class="title">committed</span> 3328<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line">2018-12-18T11:19:27.084+0800: 671040.790: [GC pause (G1 Evacuation Pause) (young), 0.3639131 secs]</span><br><span class="line">   [Parallel Time: <span class="number">354.4</span> ms, GC Workers: <span class="number">13</span>]</span><br><span class="line">      [<span class="function">GC Worker <span class="title">Start</span> <span class="params">(ms)</span>: Min: 671040790.4, Avg: 671040790.6, Max: 671040790.8, Diff: 0.4]</span></span><br><span class="line"><span class="function">      [Ext Root <span class="title">Scanning</span> <span class="params">(ms)</span>: Min: 0.8, Avg: 1.0, Max: 1.2, Diff: 0.4, Sum: 13.0]</span></span><br><span class="line"><span class="function">      [Update <span class="title">RS</span> <span class="params">(ms)</span>: Min: 22.6, Avg: 23.0, Max: 23.6, Diff: 1.0, Sum: 299.6]</span></span><br><span class="line"><span class="function">         [Processed Buffers: Min: 24, Avg: 32.5, Max: 39, Diff: 15, Sum: 422]</span></span><br><span class="line"><span class="function">      [Scan <span class="title">RS</span> <span class="params">(ms)</span>: Min: 201.4, Avg: 202.0, Max: 202.4, Diff: 1.0, Sum: 2625.9]</span></span><br><span class="line"><span class="function">      [Code Root <span class="title">Scanning</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.0, Sum: 0.2]</span></span><br><span class="line"><span class="function">      [Object <span class="title">Copy</span> <span class="params">(ms)</span>: Min: 126.9, Avg: 127.2, Max: 127.8, Diff: 0.9, Sum: 1653.5]</span></span><br><span class="line"><span class="function">      [<span class="title">Termination</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.6, Max: 0.9, Diff: 0.9, Sum: 8.3]</span></span><br><span class="line"><span class="function">         [Termination Attempts: Min: 1, Avg: 278.6, Max: 349, Diff: 348, Sum: 3622]</span></span><br><span class="line"><span class="function">      [GC Worker <span class="title">Other</span> <span class="params">(ms)</span>: Min: 0.0, Avg: 0.1, Max: 0.3, Diff: 0.2, Sum: 1.6]</span></span><br><span class="line"><span class="function">      [GC Worker <span class="title">Total</span> <span class="params">(ms)</span>: Min: 353.8, Avg: 354.0, Max: 354.2, Diff: 0.4, Sum: 4602.1]</span></span><br><span class="line"><span class="function">      [GC Worker <span class="title">End</span> <span class="params">(ms)</span>: Min: 671041144.5, Avg: 671041144.6, Max: 671041144.7, Diff: 0.2]</span></span><br><span class="line"><span class="function">   [Code Root Fixup: 0.0 ms]</span></span><br><span class="line"><span class="function">   [Code Root Purge: 0.0 ms]</span></span><br><span class="line"><span class="function">   [Clear CT: 1.7 ms]</span></span><br><span class="line"><span class="function">   [Other: 7.8 ms]</span></span><br><span class="line"><span class="function">      [Choose CSet: 0.0 ms]</span></span><br><span class="line"><span class="function">      [Ref Proc: 0.6 ms]</span></span><br><span class="line"><span class="function">      [Ref Enq: 0.0 ms]</span></span><br><span class="line"><span class="function">      [Redirty Cards: 2.5 ms]</span></span><br><span class="line"><span class="function">      [Humongous Register: 0.2 ms]</span></span><br><span class="line"><span class="function">      [Humongous Reclaim: 0.1 ms]</span></span><br><span class="line"><span class="function">      [Free CSet: 3.0 ms]</span></span><br><span class="line"><span class="function">   [Eden: 1124.0<span class="title">M</span><span class="params">(<span class="number">1124.0</span>M)</span>-&gt;0.0<span class="title">B</span><span class="params">(<span class="number">1132.0</span>M)</span> Survivors: 104.0M-&gt;96.0M Heap: 10.8<span class="title">G</span><span class="params">(<span class="number">24.0</span>G)</span>-&gt;9968.2<span class="title">M</span><span class="params">(<span class="number">24.0</span>G)</span>]</span></span><br><span class="line"><span class="function">Heap after GC invocations</span>=<span class="number">38624</span> (full <span class="number">4</span>):</span><br><span class="line"> garbage-first heap   total <span class="number">25165824</span>K, used <span class="number">10207396</span>K [<span class="number">0x00000001c0000000</span>, <span class="number">0x00000001c040c000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  region size <span class="number">4096</span>K, <span class="number">24</span> young (<span class="number">98304</span>K), <span class="number">24</span> survivors (<span class="number">98304</span>K)</span><br><span class="line"> Metaspace       used <span class="number">23093</span>K, capacity <span class="number">23236</span>K, committed <span class="number">29440</span>K, reserved <span class="number">1075200</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 2444<span class="title">K</span>, <span class="title">capacity</span> 2510<span class="title">K</span>, <span class="title">committed</span> 3328<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"> [Times: user=4.64 sys=0.00, real=0.36 secs]</span><br></pre></td></tr></table></figure></p><h4 id="日志信息详解："><a href="#日志信息详解：" class="headerlink" title="日志信息详解："></a>日志信息详解：</h4><ul><li><p><strong>garbage-first heap   total 25165824K, used 11321508K [0x00000001c0000000, 0x00000001c040c000, 0x00000007c0000000)</strong></p><p>可以看出GC的类型为G1，Heap的总大小为25165824K，已使用11321508K。</p></li><li><p><strong>region size 4096K, 307 young (1257472K), 26 survivors (106496K)</strong></p><p>每个region的大小为4096K，新生代307个region，survivor区26个region。</p></li><li><p><strong>Metaspace       used 23093K, capacity 23236K, committed 29440K, reserved 1075200K<br> class space    used 2444K, capacity 2510K, committed 3328K, reserved 1048576K</strong></p><p>java8去掉了永久区（Permanent），新增元数据区（Metaspace）。</p></li><li><p><strong>671040.790: [GC pause (G1 Evacuation Pause) (young), 0.3639131 secs]</strong></p><p>G1停顿清理(young) regions，即新生代minor GC。本次停顿在JVM启动后671040.790 s后触发，且停顿持续时间为0.3639131 s，根据系统时间（wall clock time）测定。</p></li><li><p><strong>[Parallel Time: 354.4 ms, GC Workers: 13]</strong></p><p>收集过程是多线程并发执行的，日志表明在354.4ms（real time）时间内，下面的活动是由13个线程并行完成的：</p><ol><li><p><code>GC Worker Start (ms)</code></p><p>收集线程开始的时间，匹配停顿开始时的时间戳。使用的是相对时间，Min是最早开始时间，Avg是平均开始时间，Max是最晚开始时间，Diff是Max-Min。 如果Min和Max差别很大，那么可能表明使用了太多线程或者机器上的其他进程正在从JVM内部的垃圾收集进程中窃取CPU时间。</p></li><li><p><code>Ext Root Scanning (ms)</code></p><p>扫描外部（非heap）roots如类加载器、JNI引用、JVM 系统roots等的耗时，Sum是Cpu time。</p></li><li><p><code>Update RS (ms)</code></p><p>每个线程更新Remembered Set的耗时。</p></li><li><p><code>Scan RS (ms)</code></p><p>扫描CS中的region对应的RSet，因为RSet是points-into，所以这样实现避免了扫描old generadion region，但是会产生float garbage。</p></li><li><p><code>Code Root Scanning (ms)</code></p><p>扫描code roots如本地变量的耗时。code roots指的是经过JIT编译后的代码里，引用了heap中的对象。引用关系保存在RSet中。</p></li><li><p><code>Object Copy (ms)</code></p><p>从收集region拷贝存活的对象到新region的耗时。</p></li><li><p><code>Termination (ms)</code></p><p>工作线程确保它们能够安全地停止并且没有更多的工作要做最终终止所用的耗时。在结束前，它会检查其他线程是否还有未扫描完的引用，如果有，则”偷”过来，完成后再申请结束，这个时间是线程之前互相同步所花费的时间。</p><ul><li><p><code>Termination Attempts</code></p><p>工作线程尝试终止的次数，如果实际还有更多的工作要做，那么尝试就会失败，现在终止还为时过早。</p></li></ul></li><li><p><code>GC Worker Other (ms)</code></p><p>花费在其他杂项（不值得在日志中单独占用一个部分）上的时间。</p></li><li><p><code>GC Worker Total (ms)</code></p><p>所用工作线程耗时之和。</p></li><li><p><code>GC Worker End (ms)</code></p><p>每个线程结束的时间戳，通常它们应该大致相等。</p></li></ol></li><li><p><strong>[Code Root Fixup: 0.0 ms]</strong></p><p>用来将code root修正到正确的evacuate之后的对象位置所花费的时间。</p></li><li><p><strong>[Code Root Purge: 0.0 ms]</strong></p><p>清除code root的耗时，code root中的引用已经失效，不再指向Region中的对象，所以需要被清除。</p></li><li><p><strong>[Clear CT: 1.7 ms]</strong></p><p>清除RSet的card table的耗时，这个任务在serial模式下执行。</p></li><li><p><strong>[Other: 7.8 ms]</strong></p><p>下面所列的其他事项共耗时7.8ms：</p><ol><li><p><code>[Choose CSet: 0.0 ms]</code></p><p>查找Collection Set的region的耗时；</p></li><li><p><code>[Ref Proc: 0.6 ms]</code></p><p>Reference Process， 处理引用对象的耗时；</p></li><li><p><code>[Ref Enq: 0.0 ms]</code></p><p>Reference enqueue，引用对象排队到引用队列的耗时；</p></li><li><p><code>[Redirty Cards: 2.5 ms]</code>略</p></li><li><p><code>[Humongous Register: 0.2 ms]</code>略</p></li><li><p><code>[Humongous Reclaim: 0.1 ms]</code>略</p></li><li><p><code>[Free CSet: 3.0 ms]</code></p><p>清理Collection Set数据结构的耗时；</p></li></ol></li><li><p><strong>[Eden: 1124.0M(1124.0M)-&gt;0.0B(1132.0M) Survivors: 104.0M-&gt;96.0M Heap: 10.8G(24.0G)-&gt;9968.2M(24.0G)]</strong></p><p>分别代表：停顿前后Eden区已用内存和容量；停顿前后Survivor区使用的内存；停顿前后整个Heap已用内存和容量。</p></li><li><p><strong>[Times: user=4.64 sys=0.00, real=0.36 secs]</strong></p><p>整个GC事件的持续时间，从以下不同的类别来测量：</p><ol><li><p><strong>user</strong> - 本次垃圾收集中GC线程所消耗的总体CPU时间；</p></li><li><p><strong>sys</strong> - OS调用或等待系统事件的耗时；</p></li><li><p><strong>real</strong> - 应用程序停止的时间（Clock time）。在GC活动可并行执行的情况下，这个数值理想上应为：（user时间 + sys时间）/ GC所用的线程数，在这个case里线程数是13。要注意的是，有些活动不能并行执行，因此该数值总会超过这个比例一定数量。</p></li></ol></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html" target="_blank" rel="noopener">Getting Started with the G1 Garbage Collector</a></p><p><a href="https://blogs.oracle.com/poonam/understanding-g1-gc-logs" target="_blank" rel="noopener">Understanding G1 GC Logs</a></p><p><a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations/g1/evacuation-pause-fully-young" target="_blank" rel="noopener">JAVA GARBAGE COLLECTION HANDBOOK</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;在进行JVM调优时我们经常需要通过日志信息来分析G1GC的性能，本文就日志中可供收集的数据和信息进行了简单介绍。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="G1GC" scheme="http://yoursite.com/tags/G1GC/"/>
    
  </entry>
  
  <entry>
    <title>JDK命令行工具</title>
    <link href="http://yoursite.com/2018/12/13/JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/12/13/JDK命令行工具/</id>
    <published>2018-12-13T02:10:02.308Z</published>
    <updated>2019-01-31T09:11:08.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>前一阵接口服务性能调优的时候，零零星星地用到一些JDK自带的命令行工具。当服务部署到生产环境时，有一些性能诊断工具因为环境原因可能会受到限制，但是通过使用这些JDK自带的监控工具，我问可以直接在应用程序中实现强大的监控分析功能。这些工具在<strong>《深入理解Java虚拟机》</strong>和<strong>《Java性能权威指南》</strong>中都有系统性的介绍，本文也权当是一篇学习笔记，顺便对之前调优过程中的使用做一下梳理。</p><a id="more"></a><h2 id="常用的JDK命令行工具"><a href="#常用的JDK命令行工具" class="headerlink" title="常用的JDK命令行工具"></a>常用的JDK命令行工具</h2><table><thead><tr><th style="text-align:left">请求ID</th><th style="text-align:left">主要作用</th></tr></thead><tbody><tr><td style="text-align:left">jps</td><td style="text-align:left">JVM Process Status Tool，显示指定系统内所有的HotSpot虚拟机进程</td></tr><tr><td style="text-align:left">jstat</td><td style="text-align:left">JVM Statistics Monitoring Tool，用于收集Hotspot虚拟机各方面的运行数据</td></tr><tr><td style="text-align:left">jinfo</td><td style="text-align:left">Configuration Info for Java，显示虚拟机配置信息</td></tr><tr><td style="text-align:left">jmap</td><td style="text-align:left">JVM Memory Map，生成虚拟机的内存转储快照，生成heapdump文件</td></tr><tr><td style="text-align:left">jhat</td><td style="text-align:left">JVM Heap Dump Browser，用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户在浏览器上查看分析结果</td></tr><tr><td style="text-align:left">jstack</td><td style="text-align:left">JVM Stack Trace，显示虚拟机的线程快照</td></tr><tr><td style="text-align:left">jcmd</td><td style="text-align:left">打印Java进程所涉及的基本类、线程和VM信息</td></tr><tr><td style="text-align:left">jconsole</td><td style="text-align:left">提供JVM活动的图形化视图，包括线程的使用、类的使用和GC活动</td></tr><tr><td style="text-align:left">jvisualvm</td><td style="text-align:left">监控JVM的GUI工具，可用来剖析运行的应用，分析JVM堆转储</td></tr></tbody></table><p>这些工具可以广泛用于以下领域：</p><ul><li>基本的VM信息</li><li>线程信息</li><li>类信息</li><li>实时GC分析</li><li>堆转储的事后处理</li><li>JVM的性能分析</li></ul><h2 id="常用命令介绍"><a href="#常用命令介绍" class="headerlink" title="常用命令介绍"></a>常用命令介绍</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p><strong>命令格式</strong>：</p><p><code>jps [ options ] [ hostid ]</code></p><p><strong>options</strong>：</p><p><code>-q</code> 只输出本地虚拟机进程ID，省略主类名 </p><p><code>-m</code> 输出虚拟机进程启动时传递给main()函数的参数</p><p><code>-l</code> 输出进程执行的主类的全名 </p><p><code>-v</code> 输出虚拟机进程启动时的JVM参数 </p><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p><strong>命令格式</strong>：</p><p><code>jstat [ option vmid [interval[s|ms] [count]] ]</code></p><p><strong>options</strong>：</p><p><code>-class</code>监视类装载，卸载数量，总空间以及类装载所耗费的时间</p><p><code>-gc</code> 监视Java堆状况，包括Eden区，两个survivor区，老年代，永久代的容量，已用空间，GC时间合计等信息</p><p><code>-gccapacity</code> 内容与-gc基本相同，但主要输出Java堆各个区域的最大最小空间</p><p><code>-gcutil</code> 内容与-gc基本相同，但主要关注已使用空间占总空间的百分比</p><p><code>-gccause</code> 内容与-gcutil基本相同，但主要关注已使用空间占总空间的百分比,并输出导致上一次GC的原因</p><p><code>-gcnew</code> 监视新生代GC情况</p><p><code>-gcnewcapacity</code> 内容与-gcnew基本相同，但主要输出使用到的最大最小空间</p><p><code>-gcold</code> 监视老年代GC情况</p><p><code>-gcoldcapacity</code> 内容与-gcnew基本相同，但主要输出使用到的最大最小空间</p><p><code>-gcpermcapacity</code> 输出永久代使用到的最大最小空间</p><p><code>-complier</code> 输出JIT 编译器编译过的方法耗时的信息</p><p><code>-printcompliter</code> 输出已经被JIT编译的方法</p><h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p><strong>命令格式</strong>：</p><p><code>jinfo [ option ] pid</code></p><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p><strong>命令格式</strong>：</p><p><code>jinfo [ option ] vmid</code></p><p><strong>options</strong>：</p><p><code>-dump</code> 生成Java堆转储快照，格式为： -dump:[live , ]format=b , file=,其中live子参数 说明只dump出存活的对象</p><p><code>-finalizerinfo</code> 显示在F-Queue中等待Finalizer线程执行finalize方法的对象</p><p><code>-heap</code> 显示Java堆详细信息，如使用哪种回收器，参数配置，分代状况等 </p><h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p><strong>命令格式</strong>：</p><p><code>jhat heapdumpFileName</code></p><h3 id="jatack"><a href="#jatack" class="headerlink" title="jatack"></a>jatack</h3><p><strong>命令格式</strong>：</p><p><code>jstack [ option ] vmid</code></p><p><strong>options</strong>：</p><p><code>-F</code> 当正常输出的请求不被响应时，强制输出线程堆栈</p><p><code>-l</code> 除堆栈外，显示关于锁的附加信息</p><p><code>-m</code> 如果调用到本地方法的话，可以显示C/C++的堆栈</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;前一阵接口服务性能调优的时候，零零星星地用到一些JDK自带的命令行工具。当服务部署到生产环境时，有一些性能诊断工具因为环境原因可能会受到限制，但是通过使用这些JDK自带的监控工具，我问可以直接在应用程序中实现强大的监控分析功能。这些工具在&lt;strong&gt;《深入理解Java虚拟机》&lt;/strong&gt;和&lt;strong&gt;《Java性能权威指南》&lt;/strong&gt;中都有系统性的介绍，本文也权当是一篇学习笔记，顺便对之前调优过程中的使用做一下梳理。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>线上服务CPU负载高问题排查（一）</title>
    <link href="http://yoursite.com/2018/12/06/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1CPU%E8%B4%9F%E8%BD%BD%E9%AB%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/12/06/线上服务CPU负载高问题排查（一）/</id>
    <published>2018-12-06T05:49:15.410Z</published>
    <updated>2019-03-25T06:37:16.984Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>使用Arthas定位CPU占用率过高的问题，</p><p>挖坑待填…</p><a id="more"></a><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p><img src="https://i.loli.net/2018/12/06/5c08d11e024ef.png" alt="top.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;使用Arthas定位CPU占用率过高的问题，&lt;/p&gt;
&lt;p&gt;挖坑待填…&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>线上服务CPU负载高问题排查（二）</title>
    <link href="http://yoursite.com/2018/12/06/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1CPU%E8%B4%9F%E8%BD%BD%E9%AB%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/12/06/线上服务CPU负载高问题排查（二）/</id>
    <published>2018-12-06T05:49:15.410Z</published>
    <updated>2019-03-25T08:29:53.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在进行接口服务优化，前面对处理大量数据的线程进行了优化，具体见：<a href="https://f8f-1bearcat.github.io/2018/12/06/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1CPU%E8%B4%9F%E8%BD%BD%E9%AB%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">线上服务CPU负载高问题排查（一）</a> 。当优化后的版本部署到灰度服务器上时，原以为CPU占用率会明显地降低，然而事实却狠狠地打了脸，非但该服务的CPU占用及负载没有降低，反而远远差于上次优化之前版本及线上的服务。是优化方向错了，还是引入了新的问题？<br><a id="more"></a></p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>通过运维中心<code>zabbix</code>面板查看该机房上所有的报价服务负载情况，新部署接口服务的负载情况如下图红线所示：<br><img src="https://i.loli.net/2018/12/06/5c08d1299cb5d.png" alt="load_before.png"><br>可以发现在上午11:00~14:00时间段内，该接口服务的负载明显高于其他几台服务。CPU利用率的情况与负载类似。</p><h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><h3 id="一、比较用户数量"><a href="#一、比较用户数量" class="headerlink" title="一、比较用户数量"></a>一、比较用户数量</h3><p>5个服务都部署在SZVPC机房，并且可以确定服务运行环境是相同的，那么首先需要确认是否是该服务用户量过大导致的。</p><p>登录CRT，通过<code>netstat -antp|grep &#39;port&#39;|wc -l</code>命令查看服务器上的实时用户连接数。对比该机房的5个报价服务发现，所有服务的实时用户连接数大体相等，不存在优化版本服务用户连接远大于其他几台服务的情况。到这里可以得出结论是新部署的服务本身有问题。</p><h3 id="二、定位高CPU占用线程"><a href="#二、定位高CPU占用线程" class="headerlink" title="二、定位高CPU占用线程"></a>二、定位高CPU占用线程</h3><p>1、在上一篇的CPU高负载排查过程中，我们定位到是组合和账户的数据处理线程CPU占用率高。那首先，可以确定下上次优化有没有解决这两个线程的CPU占用问题。</p><p>通过Arthas进入到当前服务进程，执行<code>thread -n 5 -i 1000</code>命令来查看当前CPU占用最高的几个线程。分析堆栈信息，可以看到改完之后的服务组合账户线程的CPU占用率已经降低了，至少前5个线程里面不见他们的踪影。</p><p><img src="https://i.loli.net/2018/12/13/5c11f7ed83ec2.png" alt="thread5.png"></p><p>2、排除了组合账户线程的影响，下一步就要定位到底是什么线程占用CPU最高。通过<code>$ top</code>命令，查看CPU实时使用情况（注：图为后面补加的，数据可能有出入）：<br><img src="https://i.loli.net/2018/12/07/5c09d1aa96940.png" alt="top_load.png"><br>可以看出pid为26810的进程CPU占用率竟然达到了1000%，而这个进程就是接口服务的进程。</p><p>3、经典的命令行工具，如<em>ps</em>或<em>top</em>，都可以用来显示线程级别的信息，下面列举了这两种方法的使用。</p><p>方法一：通过<code>$ ps -mp &lt;pid&gt; -o tid,THREAD,time</code>命令，查看线程列表。到这里确认tid为8592…的这三个线程CPU占用率最高，且占用CPU的时间也很长。</p><p><img src="https://i.loli.net/2018/12/07/5c09de2a7f8c5.png" alt="thread.png"></p><p>方法二：通过<code>$ top -H -p &lt;pid&gt;</code>命令，查看线程列表，得出的结论与方法一一致。</p><p>​            <img src="https://i.loli.net/2018/12/07/5c09de2511265.png" alt="top_thread.png"></p><p>4、定位到线程tid之后，就可以用<code>jstack</code>命令查看线程具体的堆栈信息了，不过<code>jstack</code>命令中线程id使用16进制，因而首先需要通过 <code>$ echo &quot;obase=16;&lt;tid&gt;&quot;|bc</code>或 <code>$ printf &quot;%x\n&quot; &lt;tid&gt;</code>命令将tid转为16进制。</p><p><img src="https://i.loli.net/2018/12/07/5c09de1cb3c4b.png" alt="16.png"></p><p>以tid8592为例，转为16进制后为2190，再通过<code>$ jstack &lt;pid&gt; |grep &lt;tid&gt; -C 20</code>命令查看该线程的堆栈信息。</p><p><img src="https://i.loli.net/2018/12/07/5c09de3041b0a.png" alt="thread_stack.png"></p><h3 id="三、分析"><a href="#三、分析" class="headerlink" title="三、分析"></a>三、分析</h3><p>Gang worker是JVM 用于做新生代垃圾回收（monir gc）的一个线程，#号后面是线程编号。从线程的堆栈信息可以看出是JVM的GC线程一直在占用大量CPU.定位到垃圾收集器的问题，可以通过<code>jstat -gcutil &lt;pid&gt; 1000 100</code>命令统计GC回收的情况（没发现有什么异常）。</p><p><img src="https://i.loli.net/2018/12/13/5c11f7d2e9c4d.png" alt="gcutil.png"></p><p>对应的参数如下：</p><ul><li><strong>S0：</strong>幸存1区当前使用比例</li><li><strong>S1：</strong>幸存2区当前使用比例</li><li><strong>E：</strong>伊甸园区使用比例</li><li><strong>O：</strong>老年代使用比例</li><li><strong>M：</strong>元数据区使用比例</li><li><strong>CCS：</strong>压缩使用比例</li><li><strong>YGC：</strong>年轻代垃圾回收次数</li><li><strong>FGC：</strong>老年代垃圾回收次数</li><li><strong>FGCT：</strong>老年代垃圾回收消耗时间</li><li><strong>GCT：</strong>垃圾回收消耗总时间</li></ul><p>通过<code>jinfo -flags &lt;pid&gt;</code>命令，查看该服务器上的JVM内存参数设置，看到了这一条配置：<code>-Xmx12g -XX:MaxDirectMemorySize=18g</code>，原来之前的服务版本中已经不使用直接内存，而是全都使用堆内存，而这里JVM配置却没有改过来，由此推测是服务的内存分配不够用导致频繁GC，进而引起CPU负载过高。</p><p><img src="https://i.loli.net/2018/12/13/5c11f7f40440c.png" alt="jinfo.png"></p><h3 id="四、后续"><a href="#四、后续" class="headerlink" title="四、后续"></a>四、后续</h3><p>修改JVM的配置，将最大堆内存设置为<code>-Xmx=24g</code>，重启服务运行一段时候后发现CPU负载迅速降了下来，并一直低于线上服务的负载。</p><p><img src="https://i.loli.net/2018/12/06/5c08d1312b7aa.png" alt="load_after.png"></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>1 有关JVM调优相关的可以参考这一系列博客，写的很详尽：<a href="https://www.cnblogs.com/wyb628/p/8566337.html" target="_blank" rel="noopener">Java内存泄露分析系列</a>。</p><p>2 这次问题解决也是凑巧去看了一眼JVM参数，本身GC回收具体什么地方占用了CPU，迫于时间关系实际上没有准确定位到，后面再研究吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在进行接口服务优化，前面对处理大量数据的线程进行了优化，具体见：&lt;a href=&quot;https://f8f-1bearcat.github.io/2018/12/06/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1CPU%E8%B4%9F%E8%BD%BD%E9%AB%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%EF%BC%88%E4%B8%80%EF%BC%89/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;线上服务CPU负载高问题排查（一）&lt;/a&gt; 。当优化后的版本部署到灰度服务器上时，原以为CPU占用率会明显地降低，然而事实却狠狠地打了脸，非但该服务的CPU占用及负载没有降低，反而远远差于上次优化之前版本及线上的服务。是优化方向错了，还是引入了新的问题？&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Netty源码之writeAndFlush()流程与异步</title>
    <link href="http://yoursite.com/2018/12/06/Netty%E6%BA%90%E7%A0%81%E4%B9%8BwriteAndFlush()%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%BC%82%E6%AD%A5/"/>
    <id>http://yoursite.com/2018/12/06/Netty源码之writeAndFlush()流程与异步/</id>
    <published>2018-12-06T01:14:11.376Z</published>
    <updated>2019-03-25T06:36:30.985Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf21c6726a92.png" alt="netty.png"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>挖坑待填…</p><p>本文旨在对Netty中writeAndFlush()方法的线程安全及并发问题简单谈下自己的理解，同时对channel.writeAndFlush()和ctx.writeAndFlush()两个方法通过阅读源码进行比较。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf21c6726a92.png&quot; alt=&quot;netty.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;挖坑待填…&lt;/p&gt;
&lt;p&gt;本文旨在对Netty中writeAndFlush()方法的线程安全及并发问题简单谈下自己的理解，同时对channel.writeAndFlush()和ctx.writeAndFlush()两个方法通过阅读源码进行比较。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Linux之sed用法</title>
    <link href="http://yoursite.com/2018/12/05/Linux%E4%B9%8Bsed%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2018/12/05/Linux之sed用法/</id>
    <published>2018-12-05T01:33:22.380Z</published>
    <updated>2019-02-01T06:16:32.856Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/02/01/5c53e438b7367.png" alt="Linux.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Linux sed命令是利用script来处理、编辑文本文件。</p><a id="more"></a><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>sed [OPTION]... {script-only-if-no-other-script} [input-file]...</code></p><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li>-n, –quiet, –silent<br>​                 suppress automatic printing of pattern space</li><li>-e script, –expression=script<br> ​                 add the script to the commands to be executed</li><li><p>-f script-file, –file=script-file<br> ​                 add the contents of script-file to the commands to be executed</p><p> –follow-symlinks<br>​                 follow symlinks when processing in place; hard links<br>​                 will still be broken.</p></li><li>-i[SUFFIX], –in-place[=SUFFIX]<br> ​                 edit files in place (makes backup if extension supplied).<br> ​                 The default operation mode is to break symbolic and hard links.<br> ​                 This can be changed with –follow-symlinks and –copy.</li><li>-c, –copy<br>​                 use copy instead of rename when shuffling files in -i mode.<br>​                 While this will avoid breaking links (symbolic or hard), the<br>​                 resulting editing operation is not atomic.  This is rarely<br>​                 the desired mode; –follow-symlinks is usually enough, and<br>​                 it is both faster and more secure.</li><li>-l N, –line-length=N<br>​                 specify the desired line-wrap length for the `l’ command<br>  –posix<br>​                 disable all GNU extensions.</li><li>-r, –regexp-extended<br>​                 use extended regular expressions in the script.</li><li>-s, –separate<br>​                 consider files as separate rather than as a single continuous<br>​                 long stream.</li><li>-u, –unbuffered<br>​                 load minimal amounts of data from the input files and flush<br>​                 the output buffers more often</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>查看某段时间的服务日志：<code>sed -n &#39;/1970-01-01 01:01/,$p&#39; 1.log |more</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/02/01/5c53e438b7367.png&quot; alt=&quot;Linux.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Linux sed命令是利用script来处理、编辑文本文件。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>浅谈OGNL表达式</title>
    <link href="http://yoursite.com/2018/11/30/%E6%B5%85%E8%B0%88OGNL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/11/30/浅谈OGNL表达式/</id>
    <published>2018-11-30T02:29:36.063Z</published>
    <updated>2018-11-30T02:33:36.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>挖坑…</p><p>OGNL特殊用法请参考：<a href="https://github.com/alibaba/arthas/issues/71" target="_blank" rel="noopener">https://github.com/alibaba/arthas/issues/71</a><br>OGNL表达式官方指南：<a href="https://commons.apache.org/proper/commons-ognl/language-guide.html" target="_blank" rel="noopener">https://commons.apache.org/proper/commons-ognl/language-guide.html</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;挖坑…&lt;/p&gt;
&lt;p&gt;OGNL特殊用法请参考：&lt;a href=&quot;https://github.com/alibaba/arthas/issues/71&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/alibaba/arthas/issues/71&lt;/a&gt;&lt;br&gt;OGNL表达式官方指南：&lt;a href=&quot;https://commons.apache.org/proper/commons-ognl/language-guide.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://commons.apache.org/proper/commons-ognl/language-guide.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="OGNL" scheme="http://yoursite.com/tags/OGNL/"/>
    
  </entry>
  
  <entry>
    <title>Logback以及Log4j2性能测试对比</title>
    <link href="http://yoursite.com/2018/11/28/Logback%E4%BB%A5%E5%8F%8ALog4j2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2018/11/28/Logback以及Log4j2性能测试对比/</id>
    <published>2018-11-28T01:06:32.907Z</published>
    <updated>2019-03-25T08:24:06.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>挖坑待填…</p><p>在进行RPC服务调优时，我们往往下意识地会从框架、JVM、业务代码等方向思考，但却往往会忽略线上服务日志打印对服务性能的影响。实际上，在某些情况下，选取合适的日志框架、有效的日志打印策略，将会给服务带来很大的性能提升。本文将尝试对常用的日志框架进行对比分析，从而服务于我们的服务性能调优工作。</p><a id="more"></a><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;挖坑待填…&lt;/p&gt;
&lt;p&gt;在进行RPC服务调优时，我们往往下意识地会从框架、JVM、业务代码等方向思考，但却往往会忽略线上服务日志打印对服务性能的影响。实际上，在某些情况下，选取合适的日志框架、有效的日志打印策略，将会给服务带来很大的性能提升。本文将尝试对常用的日志框架进行对比分析，从而服务于我们的服务性能调优工作。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Logback" scheme="http://yoursite.com/tags/Logback/"/>
    
      <category term="Log4j2" scheme="http://yoursite.com/tags/Log4j2/"/>
    
  </entry>
  
  <entry>
    <title>quartz定时任务时间设置</title>
    <link href="http://yoursite.com/2018/11/28/quartz%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/11/28/quartz定时任务时间设置/</id>
    <published>2018-11-28T01:03:26.828Z</published>
    <updated>2019-02-01T06:06:56.366Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/02/01/5c53b7b438ba0.png" alt="quartz.png"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>Quartz 是一个完全由 Java 编写的开源作业调度框架，为在 Java 应用程序中进行作业调度提供了简单却强大的机制。项目中的定时任务有使用到Quartz，这里就简单记录下其有关概念以及时间设置，方便记忆及以后查看。</p><a id="more"></a><h2 id="Quartz-的核心概念"><a href="#Quartz-的核心概念" class="headerlink" title="Quartz 的核心概念"></a>Quartz 的核心概念</h2><p><strong>Job</strong> 表示一个工作，要执行的具体内容。此接口中只有一个方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span></span></span><br></pre></td></tr></table></figure><p><strong>JobDetail</strong> 表示一个具体的可执行的调度程序，Job 是这个可执行程调度程序所要执行的内容，另外 JobDetail 还包含了这个任务调度的方案和策略。 </p><p><strong>Trigger</strong> 代表一个调度参数的配置，什么时候去调。</p><p><strong>Scheduler</strong> 代表一个调度容器，一个调度容器中可以注册多个 JobDetail 和 Trigger。当 Trigger 与 JobDetail 组合，就可以被 Scheduler 容器调度了。</p><h2 id="定时任务时间设置"><a href="#定时任务时间设置" class="headerlink" title="定时任务时间设置"></a>定时任务时间设置</h2><p><strong>时间格式:</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">星号： * * * * * * * </span><br><span class="line">格式： 秒 分 时 日 月 周 年</span><br></pre></td></tr></table></figure><table><thead><tr><th>时间域名</th><th style="text-align:center">允许填写的值</th><th style="text-align:center">允许的通配符</th><th>是否必填</th></tr></thead><tbody><tr><td>秒</td><td style="text-align:center">0-59</td><td style="text-align:center">, - * /</td><td>是</td></tr><tr><td>分</td><td style="text-align:center">0-59</td><td style="text-align:center">, - * /</td><td>是</td></tr><tr><td>时</td><td style="text-align:center">0-23</td><td style="text-align:center">, - * /</td><td>是</td></tr><tr><td>周</td><td style="text-align:center">1-31</td><td style="text-align:center">, - * ? / L W</td><td>是</td></tr><tr><td>月</td><td style="text-align:center">1-12 or JAN-DEC</td><td style="text-align:center">, - * /</td><td></td></tr><tr><td>周</td><td style="text-align:center">1-7 or SUN-SAT</td><td style="text-align:center">, - * ? / L  #</td><td>是</td></tr><tr><td>年</td><td style="text-align:center">1970-2099</td><td style="text-align:center">, - * /</td><td>否</td></tr></tbody></table><p><strong>通配符说明</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'*'</span> 表示所有值。例如:在分的字段上设置<span class="string">'*'</span>,表示每一分钟都会触发。</span><br><span class="line"></span><br><span class="line"><span class="string">'?'</span> 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的<span class="number">10</span>号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为<span class="string">'?'</span>具体设置为<span class="string">'00010*?'</span>。</span><br><span class="line"></span><br><span class="line"><span class="string">'-'</span> 表示区间。例如 在小时上设置<span class="string">'10-12'</span>,表示<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>点都会触发。<span class="string">','</span>表示指定多个值，例如在周字段上设置<span class="string">'MON,WED,FRI'</span>表示周一，周三和周五触发。</span><br><span class="line"></span><br><span class="line"><span class="string">'/'</span> 用于递增触发。如在秒上面设置<span class="string">'5/15'</span>表示从<span class="number">5</span>秒开始，每增<span class="number">15</span>秒触发(<span class="number">5</span>,<span class="number">20</span>,<span class="number">35</span>,<span class="number">50</span>)。在月字段上设置<span class="string">'1/3'</span>所示每月<span class="number">1</span>号开始，每隔三天触发一次。</span><br><span class="line"></span><br><span class="line"><span class="string">'L'</span> 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于<span class="string">'7'</span>或<span class="string">'SAT'</span>。如果在<span class="string">'L'</span>前加上数字，则表示该数据的最后一个。例如在周字段上设置<span class="string">'6L'</span>这样的格式,则表示<span class="string">"本月最后一个星期五"</span>。</span><br><span class="line"></span><br><span class="line"><span class="string">'W'</span> 表示离指定日期的最近那个工作日(周一至周五)。例如在日字段上设置<span class="string">'15W'</span>，表示离每月<span class="number">15</span>号最近的那个工作日触发。如果<span class="number">15</span>号正好是周六，则找最近的周五(<span class="number">14</span>号)触发, 如果<span class="number">15</span>号是周未，则找最近的下周一(<span class="number">16</span>号)触发.如果<span class="number">15</span>号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 <span class="string">'1W'</span>,它则表示每月<span class="number">1</span>号往后最近的工作日触发。如果<span class="number">1</span>号正是周六，则将在<span class="number">3</span>号下周一触发。(注，<span class="string">'W'</span>前只能设置具体的数字,不允许区间<span class="string">"-"</span>)。</span><br><span class="line"></span><br><span class="line"><span class="string">'L'</span>和<span class="string">'W'</span>可以一组合使用。如果在日字段上设置<span class="string">'LW'</span>,则表示在本月的最后一个工作日触发(一般指发工资 )序号(表示每月的第几个周几)，例如在周字段上设置<span class="string">'6#3'</span>表示在每月的第三个周六.注意如果指定<span class="string">'#5'</span>,正好第五周没有周六，则不会触发该配置(用在母亲节和父亲节再合适不过了)。</span><br><span class="line"></span><br><span class="line">周字段的设置，若使用英文字母是不区分大小写的，<span class="string">'MON'</span>与<span class="string">'mon'</span>相同。</span><br></pre></td></tr></table></figure><p><strong>常用示例</strong>：</p><p><code>0 0 12 * * ?</code> 每天12点触发<br><code>0 15 10 ? * *</code> 每天10点15分触发<br><code>0 15 10 * * ?</code> 每天10点15分触发<br><code>0 15 10 * * ? *</code> 每天10点15分触发<br><code>0 15 10 * * ? 2005</code> 2005年每天10点15分触发<br><code>0 * 14 * * ?</code> 每天下午的 2点到2点59分每分触发<br><code>0 0/5 14 * * ?</code> 每天下午的 2点到2点59分(整点开始，每隔5分触发)<br><code>0 0/5 14,18 * * ?</code> 每天下午的 18点到18点59分(整点开始，每隔5分触发)<br><code>0 0-5 14 * * ?</code> 每天下午的 2点到2点05分每分触发<br><code>0 10,44 14 ? 3 WED</code>     3月分每周三下午的 2点10分和2点44分触发 （特殊情况，在一个时间设置里，执行两次或两次以上的情况）<br><code>0 59 2 ? * FRI</code>    每周5凌晨2点59分触发；<br><code>0 15 10 ? * MON-FRI</code> 从周一到周五每天上午的10点15分触发<br><code>0 15 10 15 * ?</code> 每月15号上午10点15分触发<br><code>0 15 10 L * ?</code> 每月最后一天的10点15分触发<br><code>0 15 10 ? * 6L</code> 每月最后一周的星期五的10点15分触发<br><code>0 15 10 ? * 6L 2002-2005</code> 从2002年到2005年每月最后一周的星期五的10点15分触发<br><code>0 15 10 ? * 6#3</code> 每月的第三周的星期五开始触发<br><code>0 0 12 1/5 * ?</code> 每月的第一个中午开始每隔5天触发一次<br><code>0 11 11 11 11 ?</code> 每年的11月11号 11点11分触发(光棍节)</p><p>官方文档：<a href="http://www.quartz-scheduler.org/documentation/quartz-2.2.x/quick-start.html" target="_blank" rel="noopener">http://www.quartz-scheduler.org/documentation/quartz-2.2.x/quick-start.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/02/01/5c53b7b438ba0.png&quot; alt=&quot;quartz.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;Quartz 是一个完全由 Java 编写的开源作业调度框架，为在 Java 应用程序中进行作业调度提供了简单却强大的机制。项目中的定时任务有使用到Quartz，这里就简单记录下其有关概念以及时间设置，方便记忆及以后查看。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Quartz任务调度" scheme="http://yoursite.com/tags/Quartz%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>介绍一款开源Java诊断工具—Arthas</title>
    <link href="http://yoursite.com/2018/11/19/Arthas%E2%80%94%E5%BC%80%E6%BA%90Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/11/19/Arthas—开源Java诊断工具/</id>
    <published>2018-11-19T06:48:50.651Z</published>
    <updated>2019-06-24T03:01:29.425Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf2661ea96ae.png" alt="arthas.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Arthas（阿尔萨斯）是阿里巴巴开源的 Java 诊断工具，深受开发者喜爱。</p><p>当你遇到以下类似问题而束手无策时，Arthas 可以帮助你解决：</p><pre><code>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！是否有一个全局视角来查看系统的运行状况？有什么办法可以监控到JVM的实时运行状态？</code></pre><p>Arthas 采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。</p><a id="more"></a><h2 id="常用命令示例"><a href="#常用命令示例" class="headerlink" title="常用命令示例"></a>常用命令示例</h2><ul><li>实时显示当前服务的线程、JVM等信息：</li></ul><p><code>dashboard</code></p><ul><li>在指定采样时间间隔<code>i</code>内展示当前最忙的前<code>n</code>个线程并打印堆栈：</li></ul><p><code>thread -n 10 -i 1000</code></p><ul><li>展示方法内部调用路径，并输出方法路径上的每个节点上耗时，跟据调用耗时过滤：</li></ul><p><code>trace [class-pattern] [method-pattern] #cost&gt;100</code></p><ul><li>方法执行数据观测：</li></ul><p><code>watch [class-pattern] [method-pattern] returnObj</code><br><code>watch [class-pattern] getInstance &quot;returnObj.getReqList().size()&quot;</code></p><ul><li>反编译指定已加载类的源码：</li></ul><p><code>jad [class-pattern]</code></p><ul><li>打印出类的Field信息：</li></ul><p><code>sc -df io.netty.util.internal.PlatformDependent</code></p><p>安装和更多命令列表参见官方文档：<a href="https://alibaba.github.io/arthas/index.html" target="_blank" rel="noopener">Arthas 用户文档 — Arthas 3.0.5-SNAPSHOT 文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf2661ea96ae.png&quot; alt=&quot;arthas.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Arthas（阿尔萨斯）是阿里巴巴开源的 Java 诊断工具，深受开发者喜爱。&lt;/p&gt;
&lt;p&gt;当你遇到以下类似问题而束手无策时，Arthas 可以帮助你解决：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？

我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？

遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？

线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！

是否有一个全局视角来查看系统的运行状况？

有什么办法可以监控到JVM的实时运行状态？
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Arthas 采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。&lt;/p&gt;
    
    </summary>
    
      <category term="Open Source" scheme="http://yoursite.com/categories/Open-Source/"/>
    
    
      <category term="开发工具" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
      <category term="alibaba" scheme="http://yoursite.com/tags/alibaba/"/>
    
  </entry>
  
  <entry>
    <title>Netty引用计数对象</title>
    <link href="http://yoursite.com/2018/11/19/Netty%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/11/19/Netty引用计数对象/</id>
    <published>2018-11-19T05:42:35.208Z</published>
    <updated>2019-03-25T06:42:42.747Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/19/5bf21c6726a92.png" alt="netty.png"></p><h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>挖坑待填…</p><p>之前项目中怼Netty的高性能编程进行了实践，其中Netty 的接收和发送 ByteBuffer有用到堆外内存 DIRECT BUFFERS。使用堆外直接内存进行 Socket 读写，好处是不需要进行字节缓冲区的二次拷贝，实现了Netty的零拷贝。但是堆外内存不能被GC回收，必须遵循“谁分配，谁释放”的原则，在使用堆外内存后如果没有及时的释放，则很有可能导致OOM问题，具体可以参考这篇文章：<a href="https://f8f-1bearcat.github.io/2018/11/16/Netty%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/#more" target="_blank" rel="noopener">Netty直接内存泄露</a>；而如果对堆外内存进行了重复释放，服务则会抛出Netty引用计数异常问题。</p><p>本文旨在结合源码，对Netty的引用计数对象进行简析。</p><a id="more"></a><p>官方文档：<a href="https://netty.io/wiki/reference-counted-objects.html" target="_blank" rel="noopener">https://netty.io/wiki/reference-counted-objects.html</a></p><p>文档翻译：<a href="https://damacheng009.iteye.com/blog/2013657" target="_blank" rel="noopener">https://damacheng009.iteye.com/blog/2013657</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/19/5bf21c6726a92.png&quot; alt=&quot;netty.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;挖坑待填…&lt;/p&gt;
&lt;p&gt;之前项目中怼Netty的高性能编程进行了实践，其中Netty 的接收和发送 ByteBuffer有用到堆外内存 DIRECT BUFFERS。使用堆外直接内存进行 Socket 读写，好处是不需要进行字节缓冲区的二次拷贝，实现了Netty的零拷贝。但是堆外内存不能被GC回收，必须遵循“谁分配，谁释放”的原则，在使用堆外内存后如果没有及时的释放，则很有可能导致OOM问题，具体可以参考这篇文章：&lt;a href=&quot;https://f8f-1bearcat.github.io/2018/11/16/Netty%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/#more&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Netty直接内存泄露&lt;/a&gt;；而如果对堆外内存进行了重复释放，服务则会抛出Netty引用计数异常问题。&lt;/p&gt;
&lt;p&gt;本文旨在结合源码，对Netty的引用计数对象进行简析。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>线上服务性能调优：RPC可靠性设计</title>
    <link href="http://yoursite.com/2018/11/16/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%EF%BC%9ARPC%E5%8F%AF%E9%9D%A0%E6%80%A7%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2018/11/16/线上服务性能调优：RPC可靠性设计/</id>
    <published>2018-11-16T09:04:30.994Z</published>
    <updated>2019-03-26T07:53:18.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>本文以《Netty权威指南（第二版）》第23章<strong>可靠性</strong>为基础，结合实际项目中的应用，实现RPC框架的可靠性设计。当前权作为自己的学习笔记，后续慢慢填充自己在项目中的实践（如果懒癌没犯的话）。</p><a id="more"></a><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="RPC-框架的可靠性设计"><a href="#RPC-框架的可靠性设计" class="headerlink" title="RPC 框架的可靠性设计"></a>RPC 框架的可靠性设计</h3><h4 id="1-故障"><a href="#1-故障" class="headerlink" title="1. 故障"></a>1. 故障</h4><p>1.1 分布式调用引入的故障<br>​    1．消息的序列化和反序列化故障，例如，不支持的数据类型。<br>​    2．路由故障：包括服务的订阅、发布故障，服务实例故障之后没有及时刷新路由表，导致 RPC 调用仍然路由到故障节点。<br>​    3．网络通信故障，包括网络闪断、网络单通、丢包、客户端浪涌接入等。<br>1.2 第三方服务依赖<br>数据库服务、文件存储服务、缓存服务、消息队列服务<br>​    1．网络通信类故障, 如果采用 BIO 调用第三方服务，很有可能被阻塞。<br>​    2．“雪崩效用”导致的级联故障，例如服务端处理慢导致客户端线程被阻塞。<br>​    3．第三方不可用导致 RPC 调用失败。</p><h4 id="2-通信层的可靠性设计"><a href="#2-通信层的可靠性设计" class="headerlink" title="2. 通信层的可靠性设计"></a>2. 通信层的可靠性设计</h4><p>2.1 链路有效性检测<br>​    心跳检测机制分为三个层面：<br>​        1.TCP 层面的心跳检测，即 TCP 的 Keep-Alive 机制，它的作用域是整个 TCP 协议栈。<br>​        2. 协议层的心跳检测，主要存在于长连接协议中。例如 MQTT 协议。<br>​        3. 应用层的心跳检测，它主要由各业务产品通过约定方式定时给对方发送心跳消息实现。<br>​    心跳检测策略如下：<br>​        1．连续 N 次心跳检测都没有收到对方的 Pong 应答消息或者 Ping 请求消息，则认为链路已经发生逻辑失效，这被称作心跳超时。<br>​        2．读取和发送心跳消息的时候如何直接发生了 IO 异常，说明链路已经失效，这被称为心跳失败。​<br>  2.2 客户端断连重连<br>  ​    1．服务端因为某种原因，主动关闭连接，客户端检测到链路被正常关闭。<br>  ​    2．服务端因为宕机等故障，强制关闭连接，客户端检测到链路被 Rest 掉。<br>  ​    3．心跳检测超时，客户端主动关闭连接。<br>  ​    4．客户端因为其它原因（例如解码失败），强制关闭连接。<br>  ​    5．网络类故障，例如网络丢包、超时、单通等，导致链路中断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public int checkHealth() &#123;&#125;</span><br></pre></td></tr></table></figure><p>  2.3 缓存重发<br>  ​    消息队列中积压了部分消息，此时链路中断，这会导致部分消息并没有真正发送给通信对端<br>  ​        1．调用 Netty ChannelHandlerContext 的 write 方法时，返回 ChannelFuture 对象，我们在 ChannelFuture 中注册发送结果监听 Listener。<br>  ​        2．在 Listener 的 operationComplete 方法中判断操作结果，如果操作不成功，将之前发送的消息对象添加到重发队列中。<br>  ​        3．链路重连成功之后，根据策略，将缓存队列中的消息重新发送给通信对端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最终写入数据</span></span><br><span class="line">channel.writeAndFlush(byteBuf).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">         <span class="keyword">if</span> ((!dataQueue.isEmpty()) &amp;&amp; channel.isWritable() &amp;&amp; (!isWriting())) &#123;</span><br><span class="line">              dataProcessor();</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">               <span class="comment">//缓存重发</span></span><br><span class="line">  &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>  2.4 客户端超时保护</p><p>​    1. 在同步阻塞 I/O 模型中，连接操作是同步阻塞的，如果不设置超时时间，客户端 I/O 线程可能会被长时间阻塞，这会导致系统可用 I/O 线程数的减少。</p><p>​    2. 业务层需要：大多数系统都会对业务流程执行时间有限制，例如 WEB 交互类的响应时间要小于 3S。客户端设置连接超时时间是为了实现业务层的超时。</p><p>2.5 针对客户端的并发连接数流控<br>​    检查登录次数<br>​    目前简单判断一段时间内不允许再登录<br>2.6 内存保护<br>​    1. 链路总数的控制：每条链路都包含接收和发送缓冲区，链路个数太多容易导致内存溢出。<br>​    2. 单个缓冲区的上限控制：防止非法长度或者消息过大导致内存溢出。<br>​        缓冲区的创建方式通常有两种：<br>​            1. 容量预分配，在实际读写过程中如果不够再扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf byteBuf = com.eastmoney.quote.service.core.common.BufAllocator.newBuffer(resMinData.getByteData().length + <span class="number">28</span>);</span><br></pre></td></tr></table></figure><p>​            2. 根据协议消息长度创建缓冲区。    </p><p>​    3. 缓冲区内存释放：防止因为缓冲区使用不当导致的内存泄露。</p><p>​    4. NIO 消息发送队列的长度上限控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (buf.readableBytes() &gt;= ServerInfo.getInstance().getChunkSize()) &#123;</span><br><span class="line">    writeBuf(buf);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (batchBuf == <span class="keyword">null</span>) &#123;</span><br><span class="line">        batchBuf = BufAllocator.newBuffer();</span><br><span class="line">    &#125;</span><br><span class="line">    batchBuf.writeBytes(buf);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       buf.release();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       LOG.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-RPC-调用层的可靠性设计"><a href="#3-RPC-调用层的可靠性设计" class="headerlink" title="3. RPC 调用层的可靠性设计"></a>3. RPC 调用层的可靠性设计</h4><p>3.1 RPC 调用异常场景<br>​    3.1.1 服务路由失败<br>​    3.1.2 服务端超时<br>​    3.1.3 服务端调用失败<br>3.2 RPC 调用可靠性方案<br>​    3.2.1 注册中心与链路检测双保险机制<br>​    3.2.2 集群容错策略</p><h4 id="4-第三方服务依赖故障隔离"><a href="#4-第三方服务依赖故障隔离" class="headerlink" title="4. 第三方服务依赖故障隔离"></a>4. 第三方服务依赖故障隔离</h4><p>4.1 总体策略<br>4.2 异步化<br>4.3. 基于 Hystrix 的第三方依赖故障隔离</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;本文以《Netty权威指南（第二版）》第23章&lt;strong&gt;可靠性&lt;/strong&gt;为基础，结合实际项目中的应用，实现RPC框架的可靠性设计。当前权作为自己的学习笔记，后续慢慢填充自己在项目中的实践（如果懒癌没犯的话）。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
      <category term="RPC" scheme="http://yoursite.com/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>线上服务性能调优：Netty高性能编程</title>
    <link href="http://yoursite.com/2018/11/16/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%EF%BC%9ANetty%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/11/16/线上服务性能调优：Netty高性能编程/</id>
    <published>2018-11-16T03:28:20.479Z</published>
    <updated>2019-03-25T08:32:03.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>我的Netty通信框架学习是从李林峰老师的《Netty权威指南（第二版）》开始的，书中从原始的I/O模型到Netty的高性能、可靠性等高级特性进行了由浅入深的讲解。偶然的机会，发现了李林峰老师在InfoQ上的专栏：<a href="https://www.infoq.cn/profile/1278176" target="_blank" rel="noopener">InfoQ_李林峰</a>，当前还保持着不错的更新频率，大家感兴趣的可以关注一下。学习本身就是一个不断获取知识然后投入实践的过程，本文将简单记录下在我自己的项目中是如何实践Netty高性能编程的。</p><a id="more"></a><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>声明：本文将以《Netty权威指南（第二版）》第22章<strong>高性能之道</strong>为基础，对项目中的实际应用进行梳理，可以看做是自己的一份学习笔记，方便记忆及以后查看，不做其他用途。</p><h3 id="传统-RPC-调用性能差的三宗罪"><a href="#传统-RPC-调用性能差的三宗罪" class="headerlink" title="传统 RPC 调用性能差的三宗罪"></a>传统 RPC 调用性能差的三宗罪</h3><ul><li><p>网络传输方式问题：</p><p>传统的 RPC 框架或者基于 RMI 等方式的远程服务（过程）调用采用了同步阻塞 IO，当客户端的并发压力或者网络时延增大之后，同步阻塞 IO 会由于频繁的 wait 导致 IO 线程经常性的阻塞，由于线程无法高效的工作，IO 处理能力自然下降。</p></li><li><p>序列化方式问题：<br>Java 序列化存在如下几个典型问题：</p><ul><li>无法跨语言使用；</li><li>序列化后的码流太大，网络传输还是持久化到磁盘，都会导致额外的资源占用；</li><li>序列化性能差（CPU 资源占用高）；</li></ul></li><li><p>线程模型问题：<br>由于采用同步阻塞 IO，这会导致每个 TCP 连接都占用 1 个线程，当 IO 读写阻塞导致线程无法及时释放时，会导致系统性能急剧下降；</p></li></ul><h3 id="高性能的三个主题"><a href="#高性能的三个主题" class="headerlink" title="高性能的三个主题"></a>高性能的三个主题</h3><p>​    1) 传输：用什么样的通道将数据发送给对方，BIO、NIO 或者 AIO，IO 模型在很大程度上决定了框架的性能。<br>​    2) 协议：采用什么样的通信协议，HTTP 或者内部私有协议。协议的选择不同，性能模型也不同。相比于公有协议，内部私有协议的性能通常可以被设计的更优。<br>​    3) 线程：数据报如何读取？读取之后的编解码在哪个线程进行，编解码后的消息如何派发，Reactor 线程模型的不同，对性能的影响也非常大。</p><h3 id="Netty-高性能编程实践"><a href="#Netty-高性能编程实践" class="headerlink" title="Netty 高性能编程实践"></a>Netty 高性能编程实践</h3><h4 id="1-异步非阻塞通信"><a href="#1-异步非阻塞通信" class="headerlink" title="1. 异步非阻塞通信"></a>1. 异步非阻塞通信</h4><p>与 Socket 类和 ServerSocket 类相对应，NIO 也提供了 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">"Epoll"</span>.equals(ServerInfo.getInstance().getEventLoopGroup())) &#123;</span><br><span class="line">    bossGroup = <span class="keyword">new</span> EpollEventLoopGroup();</span><br><span class="line">    workerGroup = <span class="keyword">new</span> EpollEventLoopGroup();</span><br><span class="line">    serverBootstrap = serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">            .channel(EpollServerSocketChannel.class);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    serverBootstrap = serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">            .channel(NioServerSocketChannel.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-零拷贝"><a href="#2-零拷贝" class="headerlink" title="2. 零拷贝"></a>2. 零拷贝</h4><p>​    1) Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title">newBufferType</span><span class="params">(<span class="keyword">byte</span> type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (type == BYTEBUF_TYPE_POOLED_DIRECT) &#123;</span><br><span class="line"><span class="keyword">return</span> PooledByteBufAllocator.DEFAULT.directBuffer().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == BYTEBUF_TYPE_UNPOOLED_DIRECT) &#123;</span><br><span class="line"><span class="keyword">return</span> UnpooledByteBufAllocator.DEFAULT.directBuffer().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == BYTEBUF_TYPE_POOLED_HEAP) &#123;</span><br><span class="line"><span class="keyword">return</span> PooledByteBufAllocator.DEFAULT.buffer().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == BYTEBUF_TYPE_UNPOOLED_HEAP) &#123;</span><br><span class="line"><span class="keyword">return</span> UnpooledByteBufAllocator.DEFAULT.buffer().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> UnpooledByteBufAllocator.DEFAULT.buffer().order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    2) Netty 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompositeByteBuf <span class="title">compositeBuffer</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ServerInfo.getInstance().getByteBufType() == BYTEBUF_TYPE_POOLED_DIRECT) &#123;</span><br><span class="line"><span class="keyword">return</span> PooledByteBufAllocator.DEFAULT.compositeDirectBuffer();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ServerInfo.getInstance().getByteBufType() == BYTEBUF_TYPE_UNPOOLED_DIRECT) &#123;</span><br><span class="line"><span class="keyword">return</span> UnpooledByteBufAllocator.DEFAULT.compositeDirectBuffer();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ServerInfo.getInstance().getByteBufType() == BYTEBUF_TYPE_POOLED_HEAP) &#123;</span><br><span class="line"><span class="keyword">return</span> PooledByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ServerInfo.getInstance().getByteBufType() == BYTEBUF_TYPE_UNPOOLED_HEAP) &#123;</span><br><span class="line"><span class="keyword">return</span> UnpooledByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> UnpooledByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    3) Netty 的文件传输采用了 transferTo 方法，它可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。</p><p>​    在实际的开发项目中，没有使用文件传输方法，顾该特性没有使用到。</p><h4 id="3-内存池"><a href="#3-内存池" class="headerlink" title="3. 内存池"></a>3. 内存池</h4><p>为了尽量重用缓冲区，Netty 提供了基于内存池的缓冲区重用机制。Netty 提供了多种内存管理策略，通过在启动辅助类中配置相关参数，可以实现差异化的定制。<br>PooledDirectByteBuf 的 newInstance 方法实现：</p><ul><li>通过 RECYCLER 的 get 方法循环使用 ByteBuf 对象，如果是非内存池实现，则直接创建一个新的 ByteBuf 对象。</li><li>从缓冲池中获取 ByteBuf 之后，调用 AbstractReferenceCountedByteBuf 的 setRefCnt 方法设置引用计数器，用于对象的引用计数和内存回收（类似 JVM 垃圾回收机制）。</li></ul><p>在上面零拷贝的实例中，可以看到对内存池<strong>UnpooledByteBufAllocator</strong>的使用。</p><h4 id="4-高效的-Reactor-线程模型"><a href="#4-高效的-Reactor-线程模型" class="headerlink" title="4. 高效的 Reactor 线程模型"></a>4. 高效的 Reactor 线程模型</h4><p>Reactor 线程模型分为以下三种：</p><p>​    1) Reactor 单线程模型；<br>​    2) Reactor 多线程模型；<br>​    3) 主从 Reactor 多线程模型；</p><p>实际应用中，我们使用的是主从 Reactor 多线程模型，代码实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bossGroup = <span class="keyword">new</span> EpollEventLoopGroup();</span><br><span class="line">workerGroup = <span class="keyword">new</span> EpollEventLoopGroup();</span><br><span class="line">serverBootstrap = serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                        .channel(EpollServerSocketChannel.class);</span><br></pre></td></tr></table></figure><p>服务端启动时创建了两个NioEventLoopGroup，实际上他们是两个独立的Reactor线程池，BossGroup用于服务端处理客户端建立TCP连接的请求，WorkerGroup用于处理I/O相关的读写操作，或则执行系统的Task，定时Task。</p><p>BossGroup线程池具体作用：<br>1)接收客户端的连接，初始化Channel参数；<br>2)将链路状态变更时间通知给ChannelPipeline；</p><p>WorkerGroup线程池具体作用：<br>​    1)异步读取通信对端的数据报，发送读事件到ChannelPipeline；<br>​    2)异步发送消息到通信对端，调用ChannelPipeline的消息发送接口；<br>​    3)执行系统调用、定时任务Task；</p><h4 id="5-无锁化的串行设计理念"><a href="#5-无锁化的串行设计理念" class="headerlink" title="5. 无锁化的串行设计理念"></a>5. 无锁化的串行设计理念</h4><p>为了尽可能提升性能，Netty 采用了串行无锁化设计，在 IO 线程内部进行串行操作，避免多线程竞争导致的性能下降。表面上看，串行化设计似乎 CPU 利用率不高，并发程度不够。但是，通过调整 NIO 线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列 - 多个工作线程模型性能更优。<br>具体实现：</p><p>Netty 的 NioEventLoop 读取到消息之后，直接调用 ChannelPipeline 的 fireChannelRead(Object msg)，只要用户不主动切换线程，一直会由 NioEventLoop 调用到用户的 Handler，期间不进行线程切换。</p><h4 id="6-高效的并发编程"><a href="#6-高效的并发编程" class="headerlink" title="6. 高效的并发编程"></a>6. 高效的并发编程</h4><p>1) volatile 的大量、正确使用 ;<br>2) CAS 和原子类的广泛使用；<br>3) 线程安全容器的使用；</p><p>举例说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推送注册列表</span></span><br><span class="line"><span class="keyword">private</span> ConcurrentHashMap&lt;Short, ResPush&gt; pushList = <span class="keyword">new</span> ConcurrentHashMap&lt;Short, ResPush&gt;();</span><br><span class="line"><span class="comment">// 推送数据队列</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">private</span> ArrayBlockingQueue&lt;Object&gt; dataQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Object&gt;(QUEUE_SIZE_MAX);</span><br></pre></td></tr></table></figure><p>4) 通过读写锁提升并发性能。</p><p>举例说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock writeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!writeLock.tryLock(<span class="number">10</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//写入数据操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-高性能的序列化框架"><a href="#7-高性能的序列化框架" class="headerlink" title="7. 高性能的序列化框架"></a>7. 高性能的序列化框架</h4><p>1) 序列化后的码流大小（网络带宽的占用）；</p><p>首先通过定制私有协议：增量+FAST协议，有效缩减每次请求或推送的数据返回包的大小，然后通过gzip/zip压缩、控制每个返回包的大小等手段实现降低网络带宽的占用。</p><p>其中压缩代码实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ServerInfo.getInstance().isZip()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (header.getZip() == ResHeader.RES_HEADER_ZIP_TO_GZIP) &#123;</span><br><span class="line">        <span class="comment">//压缩写入out，压缩后长度</span></span><br><span class="line">        bodyLen = GZipUtils.compress(bodyBuf, out);</span><br><span class="line">        header.setZip(ResHeader.RES_HEADER_ZIP_GZIP);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (header.getZip() == ResHeader.RES_HEADER_ZIP_TO_ZIP) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[bodyBuf.readableBytes()];</span><br><span class="line">        bodyBuf.readBytes(bytes);</span><br><span class="line">        <span class="keyword">byte</span>[] compress = ZipUtil.compress(bytes);</span><br><span class="line">        out.writeBytes(compress);</span><br><span class="line">        header.setZip(ResHeader.RES_HEADER_ZIP_ZIP);</span><br><span class="line">        bodyLen = compress.length;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bodyLen = bodyBuf.readableBytes();</span><br><span class="line">        <span class="keyword">if</span> (bodyLen &gt;= ServerInfo.getInstance().getZipMaxLength()) &#123;</span><br><span class="line">             <span class="comment">//压缩写入out，压缩后长度</span></span><br><span class="line">             bodyLen = GZipUtils.compress(bodyBuf, out);</span><br><span class="line">             <span class="comment">//压缩</span></span><br><span class="line">             header.setZip(ResHeader.RES_HEADER_ZIP_GZIP);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             out.writeBytes(bodyBuf);</span><br><span class="line">             header.setZip(ResHeader.RES_HEADER_ZIP_UNZIP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2) 序列化 &amp; 反序列化的性能（CPU 资源占用）；</p><p>因为涉及到私有协议的定制，不适合展开细讲，这里大体提一下，在序列化优化这方面，我们使用了增量+FAST协议栈的方式，包体协议定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UINT[] dps; //标识每一字段数据精度</span><br><span class="line">UINT baseNum; //基准数据id (int)</span><br><span class="line">TmpData</span><br><span class="line">&#123;</span><br><span class="line">BIT_VECTOR flag;//数据二进制位</span><br><span class="line">UINT[] diff;//增量数据 (int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>依次读入数据，选取基准数据，后续读入数据根据基准数据做增量，减少返回包数据大小。</p></li><li><p>增量数据设置：</p><ul><li><p>flag：     </p><p>​    ①第一位如果设置（isSet(0)），表示是全量数据，后面n-1位没有设置；</p><pre><code>②第一位如果没有设置，表示增量，后面n-1位设置过的表示有增量数据，未设置过的表示该位数据与基准数据对应数据相同。</code></pre></li><li><p>增量数据返回的数据与flag位是否设置相对应。</p></li></ul></li><li><p>私有协议同时支持可配置的全量拉取、注册推送等模式，降低服务器压力；</p></li></ul><p>3) 是否支持跨语言（异构系统的对接和开发语言切换）。</p><p>本项目中通过定制化私有协议实现了RPC服务与不同的客户端：终端、API、Web服务、Excel等的跨语言通信。</p><h4 id="8-灵活的-TCP-参数配置能力"><a href="#8-灵活的-TCP-参数配置能力" class="headerlink" title="8. 灵活的 TCP 参数配置能力"></a>8. 灵活的 TCP 参数配置能力</h4><p>1) SO_RCVBUF 和 SO_SNDBUF：通常建议值为 128K 或者 256K；<br>2) SO_TCPNODELAY：NAGLE 算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法；<br>3) 软中断：如果 Linux 内核版本支持 RPS（2.6.35 以上版本），开启 RPS 后可以实现软中断，提升网络吞吐量。</p><p>TCP/Socket的设置，具体有 SO_REUSEADDR， TCP_NODELAY， SO_KEEPALIVE，SO_LINGER， SO_TIMEOUT， SO_BACKLOG，SO_SNDBUF， SO_RCVBUF。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>迫于篇幅限制，本文只是单纯的对Netty的高性能编程实践进行了简单的罗列，实际在开发过程中，每一项改动都需要结合JVM监控工具及运维监控平台进行大量的参数修改及压力测试，力求找到RPC服务性能的最优解。当然根据生产环境的不同，这些特性的使用也不完全一致，需要我们具体对待。</p><p>通过对Netty高性能编程的时间以及JVM调优，线上服务的性能其实是有了不小的提升：</p><p>​    内存占用方面，报价接口服务内存占用从 25G 降低到 21G，实时接口服务内存占用从 26G 降低到 13G；<br>​    CPU 占用方面，线上 RPC 服务的 CPU 占用率从高峰期 1100%降低到 600%左右，服务器负载从 16 降低到 11；<br>​    I/O 带宽方面，返回包数据大小减小了 30%～36%。</p><p>最后还是要感谢李林峰老师，给我RPC服务的Netty性能调优提供了清晰的思路。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章摘要&quot;&gt;&lt;a href=&quot;#文章摘要&quot; class=&quot;headerlink&quot; title=&quot;文章摘要&quot;&gt;&lt;/a&gt;文章摘要&lt;/h2&gt;&lt;p&gt;我的Netty通信框架学习是从李林峰老师的《Netty权威指南（第二版）》开始的，书中从原始的I/O模型到Netty的高性能、可靠性等高级特性进行了由浅入深的讲解。偶然的机会，发现了李林峰老师在InfoQ上的专栏：&lt;a href=&quot;https://www.infoq.cn/profile/1278176&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;InfoQ_李林峰&lt;/a&gt;，当前还保持着不错的更新频率，大家感兴趣的可以关注一下。学习本身就是一个不断获取知识然后投入实践的过程，本文将简单记录下在我自己的项目中是如何实践Netty高性能编程的。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
</feed>
