<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="JVM,OpenJDK,">





  <link rel="alternate" href="/atom.xml" title="Magical Cat" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/if_Cat.png?v=5.1.2">






<meta name="description" content="文章摘要OpenJDK 12是由JSR 386在Java Community Process中指定的Java SE平台的版本12的开源参考实现，于2019年3月19日达到General Availability版本。GPL(General Public License)协议下的生产就绪二进制文件可从Oracle获得；其他供应商的二进制文件很快就会出现。 该版本的功能和时间表是通过JEP流程提出和">
<meta name="keywords" content="JVM,OpenJDK">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenJDK12的新特性（上）">
<meta property="og:url" content="http://yoursite.com/2019/03/26/OpenJDK12的新特性（上）/index.html">
<meta property="og:site_name" content="Magical Cat">
<meta property="og:description" content="文章摘要OpenJDK 12是由JSR 386在Java Community Process中指定的Java SE平台的版本12的开源参考实现，于2019年3月19日达到General Availability版本。GPL(General Public License)协议下的生产就绪二进制文件可从Oracle获得；其他供应商的二进制文件很快就会出现。 该版本的功能和时间表是通过JEP流程提出和">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://i.loli.net/2019/03/28/5c9c829850beb.jpg">
<meta property="og:updated_time" content="2019-08-05T09:02:46.792Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OpenJDK12的新特性（上）">
<meta name="twitter:description" content="文章摘要OpenJDK 12是由JSR 386在Java Community Process中指定的Java SE平台的版本12的开源参考实现，于2019年3月19日达到General Availability版本。GPL(General Public License)协议下的生产就绪二进制文件可从Oracle获得；其他供应商的二进制文件很快就会出现。 该版本的功能和时间表是通过JEP流程提出和">
<meta name="twitter:image" content="https://i.loli.net/2019/03/28/5c9c829850beb.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/03/26/OpenJDK12的新特性（上）/">





<link href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" rel="stylesheet">

  <title>OpenJDK12的新特性（上） | Magical Cat</title>
  














</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>
<div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Magical Cat</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/26/OpenJDK12的新特性（上）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="F8F-1BearCat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Issac.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Magical Cat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">OpenJDK12的新特性（上）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-26T15:27:06+08:00">
                2019-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/译文/" itemprop="url" rel="index">
                    <span itemprop="name">译文</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="https://i.loli.net/2019/03/28/5c9c829850beb.jpg" alt="OpenJDK.jpg"></p>
<h2 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h2><p>OpenJDK 12是由JSR 386在Java Community Process中指定的Java SE平台的版本12的开源参考实现，于2019年3月19日达到General Availability版本。GPL(General Public License)协议下的生产就绪二进制文件可从Oracle获得；其他供应商的二进制文件很快就会出现。</p>
<p>该版本的功能和时间表是通过JEP流程提出和跟踪的，并由JEP 2.0提案进行了修订。该版本使用JDK Release Process（JEP 3）生成发布。</p>
<p>本文根据OpenJDK 12的官方文档：<a href="http://openjdk.java.net/projects/jdk/12/" target="_blank" rel="noopener">OpenJDK 12</a>，对其新特性进行整理，受本人翻译水平所限，难免有翻译或理解错误，望不吝指正。</p>
<a id="more"></a>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><table>
<thead>
<tr>
<th>JEP</th>
<th>Features</th>
</tr>
</thead>
<tbody>
<tr>
<td>189:</td>
<td><a href="#jump189">Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)</a></td>
</tr>
<tr>
<td>230:</td>
<td><a href="#jump230">Microbenchmark Suite</a></td>
</tr>
<tr>
<td>325:</td>
<td><a href="#jump325">Switch Expressions (Preview)</a></td>
</tr>
<tr>
<td>334:</td>
<td><a href="#jump334">JVM Constants API</a></td>
</tr>
<tr>
<td>340:</td>
<td><a href="#jump340">One AArch64 Port, Not Two</a></td>
</tr>
<tr>
<td>341:</td>
<td><a href="#jump341">Default CDS Archives</a></td>
</tr>
<tr>
<td>344:</td>
<td><a href="#jump344">Abortable Mixed Collections for G1</a></td>
</tr>
<tr>
<td>346:</td>
<td><a href="#jump346">Promptly Return Unused Committed Memory from G1</a></td>
</tr>
</tbody>
</table>
<p><strong>注意</strong>：因篇幅限制，下文将对OpenJDK 12的新特性：189、230、325、334进行整理，剩余特性的整理请见下篇：<a href="https://f8f-1bearcat.github.io/2019/03/26/OpenJDK12%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8B%EF%BC%89/#more" target="_blank" rel="noopener">OpenJDK12的新特性（下）</a>。</p>
<h4 id="JEP189-Shenandoah-A-Low-Pause-Time-Garbage-Collector-Experimental"><a href="#JEP189-Shenandoah-A-Low-Pause-Time-Garbage-Collector-Experimental" class="headerlink" title="JEP189: Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)"></a><span id="jump189">JEP189: Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)</span></h4><p>低GC停顿的垃圾收集器(Experimental版本)</p>
<p><strong>摘要</strong>：</p>
<p>添加一个名为Shenandoah的新垃圾收集（GC）算法，在执行GC动作时可以通过并发的方式让Java程序继续执行，从而缩短Stop_The_World的时间。使用Shenandoah的停顿时间与堆大小无关，这意味着无论堆是200 MB还是200 GB，都将具有相同的稳定停顿时间。</p>
<p><strong>非目标</strong>：</p>
<p>这个GC算法并不是万能的，还有其他的垃圾收集算法会优先考虑吞吐量或者内存占用，而不是响应性。Shenandoah算法适用于那些注重响应性和可预测的停顿时间的应用，它并不能解决所有的JVM停顿问题，那些由于GC之外的其他原因，如达到安全点的时间（TTSP）或者监控通胀，导致的停顿时间超出了此JEP的范围。</p>
<p><strong>成功标准</strong>：</p>
<p>保持一致的较短的GC停顿时间。</p>
<p><strong>描述</strong>：</p>
<p>现代机器拥有比以往更多的内存和更多的处理器。服务水平协议（SLA）应用程序保证响应时间为10-500毫秒。为了满足该目标的低端，我们需要足够高效垃圾收集算法以允许程序在可用内存中运行，而且也要能做到永远不会中断正在运行的程序超过几毫秒。 Shenandoah是OpenJDK开源的低停顿收集器，旨在让我们更接近这些目标。</p>
<p>Shenandoah通过牺牲并发cpu周期和空间以优化停顿时间。我们为每个Java对象添加了一个间接指针，使得GC线程进行Java堆整理时能够与用户线程并发执行。由于整个GC过程中耗时最长的并发标记和整理过程收集器线程与用户线程可以一起工作，所以只需要在扫描线程堆栈以枚举根节点时停顿Java执行线程。</p>
<p>Shenandoah算法在<a href="https://www.researchgate.net/publication/306112816_Shenandoah_An_open-source_concurrent_compacting_garbage_collector_for_OpenJDK" target="_blank" rel="noopener">this PPPJ2016 paper</a>中有详细描述。</p>
<p>Shenandoah已经应用并且将由Red Hat提供aarch64和amd64支持。</p>
<p>在OpenJDK Shenandoah项目中的Shenandoah开发已经完成。在<a href="https://wiki.openjdk.java.net/display/shenandoah/Main" target="_blank" rel="noopener">Shenandoah wiki page</a>页面上查看有关当前开发流程，实现细节和可用性的更多详细信息。</p>
<p><strong>选择</strong>：</p>
<p>Zing/Azul有一个更低停顿的收集器，但是这项工作还没有贡献给OpenJDK。</p>
<p>ZGC有基于彩色指针的低停顿收集器， 我们期待比较两种策略的表现。</p>
<p>G1执行一些平行和并发工作，但它不执行并发回收（编者注：G1的筛选回收阶段，从Sun公司透漏出的信息来看，其实是支持与用户线程并发执行的，但是由于只会有一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率）。</p>
<p>CMS执行并发标记，但它在停顿时执行年轻代复制，并且从不整理老年代， 这导致花费更多时间来管理老年代中的可用空间以及碎片问题（编者注：CMS是基于“标记-清除”算法实现的收集器，这就意味着收集结束的时候将有大量的空间碎片产生）。</p>
<p><strong>建立和调用</strong>：</p>
<p>作为实验性功能，Shenandoah要求在命令行中配置<code>-XX:+UnlockExperimentalVMOptions</code>参数，构建系统会自动禁用不受支持的配置。下游构建者可以选择在其他支持的平台上使用<code>--with-jvm-features = -shenandoahgc</code>禁用构建Shenandoah。</p>
<p>要启用/使用Shenandoah GC，需要使用以下JVM选项：<code>-XX:+UnlockExperimentalVMOptions</code>                                <code>-XX:+UseShenandoahGC</code>。</p>
<p>想要获取有关如何设置和调整Shenandoah GC的更多信息，请参阅<a href="https://wiki.openjdk.java.net/display/shenandoah/Main" target="_blank" rel="noopener">Shenandoah wiki</a>页面。</p>
<p><strong>测试</strong>：</p>
<p>Red Hat已经为我们的重要应用程序进行了大量测试。我们开发了许多Shenandoah特定的jtreg测试。Shenandoah从Fedora 24开始在Fedora中传送，并在Rhel 7.4中作为技术预览。使用<code>-XX:+UseShenandoahGC</code>运行标准的OpenJDK测试就足够了。</p>
<p><strong>风险和假设</strong>：</p>
<p>GC接口（JEP 304）已集成在JDK 11中，之后对GC接口进行了许多扩展和改进，这样可以最大限度地降低将Shenanodah添加到OpenJDK源代码库的风险。除此之外，任何无法合理编址的Shenandoah-specific代码路径都将受到<code>#ifdef INCLUDE_SHENANDOAHGC</code>或类似机制的保护。Shenandoah GC最初将被标记为实验性功能，因此在配置参数方面除<code>-XX:+UseShenandoahGC</code>之外还需要<code>-XX:+UnlockExperimentalVMOptions</code>。</p>
<h4 id="JEP230-Microbenchmark-Suite"><a href="#JEP230-Microbenchmark-Suite" class="headerlink" title="JEP230: Microbenchmark Suite"></a><span id="jump230">JEP230: Microbenchmark Suite</span></h4><p>Microbenchmark 套件</p>
<p><strong>摘要</strong>：</p>
<p>在JDK源代码中添加一套基本的microbenchmarks ，使开发人员可以轻松运行现有的microbenchmarks 并创建新的microbenchmarks 。</p>
<p><strong>目标</strong>：</p>
<ul>
<li>基于[Java Microbenchmark Harness（JMH）];<a href="http://openjdk.java.net/projects/code-tools/jmh" target="_blank" rel="noopener">[1]</a></li>
<li>稳定且经过调整的benchmarks，针对持续性能测试<br> ​    ​    - 在feature release以及non-feature releases的Feature Complete milestone之后提供稳定且不移动的套件<br> ​    ​    - 支持与先前JDK版本的适用测试比较</li>
<li>简易<ul>
<li>轻松添加新benchmarks</li>
<li>在APIs和options更改、不推荐使用或在开发期间删除时，可以轻松更新测试</li>
<li>易于构建</li>
<li>易于查找和运行benchmark</li>
</ul>
</li>
<li>支持JMH更新</li>
<li>在组件中包含大约一百个benchmarks的初始集</li>
</ul>
<p><strong>非目标</strong>：</p>
<ul>
<li><p>为新的JDK功能提供benchmarks不是目标，为新功能添加benchmarks是这些项目的一部分。</p>
</li>
<li><p>创建一套完整的benchmarks来覆盖JDK中所有内容不是目标。随着时间的推移，该套件将继续通过新编写的benchmarks，或通过专门针对扩展其覆盖范围的协作进行扩展。</p>
</li>
<li><p>为处理microbenchmarks中的二进制依赖提供解决方案不是目标，稍后可能会添加对此的支持。</p>
</li>
</ul>
<p><strong>描述</strong>：</p>
<p>microbenchmark套件将与JDK源代码位于一个目录下，并且在构建时将生成单个JAR文件。协同定位将简化在开发期间添加和定位benchmarks。在运行benchmarks时，JMH提供强大的过滤功能，允许用户仅运行当前感兴趣的benchmarks，确切的位置仍有待确定。</p>
<p>Benchmarking 通常需要与早期build甚至release版本进行比较，因此microbenchmarks 必须支持JDK（N），用于针对新JDK和JDK（N-1）中的特性，以及存在于早期release版本中的特性的benchmarks 。 这意味着，对于JDK 12，结构和构建脚本必须支持JDK 12和JDK 11的编译benchmarks 。benchmarks 将进一步使用描述他们正在测试的JDK区域的Java包名称进行划分。</p>
<p>建议使用以下目录结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jdk/jdk</span><br><span class="line">   .../make/test (Shared folder for Makefiles)</span><br><span class="line">   .../test (Shared folder for functional tests)</span><br><span class="line">      .../micro/org/openjdk/bench</span><br><span class="line">         .../java (subdirectories similar to JDK packages and modules)</span><br><span class="line">         .../vm (subdirectories similar to HotSpot components)</span><br></pre></td></tr></table></figure>
<p>microbenchmark套件的构建将与普通的JDK构建系统集成。它将是一个单独的目标，在正常的JDK构建期间不会执行，以便为开发人员和其他对构建微基准套件不感兴趣的人保持较低的构建时间。要构建微基准套件，用户必须专门运行make build-microbenchmark或类似工具。另外，将支持使用<code>make test TEST =“micro：regexp”</code>运行基准测试。有关如何设置本地环境的说明将记录在<code>docs / testing.md | html</code>中。</p>
<p>benchmark将完全依赖于JMH，就像某些单元测试依赖于TestNG或jtreg一样，所以虽然对JMH的依赖是新的，但是构建的其他部分具有相似的依赖性。与jtreg相比的一个区别是JMH在构建期间都被使用，并且被打包为生成的JAR文件的一部分。</p>
<p>microbenchmark套件中的benchmark集将从<code>JMH JDK Microbenchmarks</code>项目中导入。这些构成了一组已在内部使用的经过调整和测试的microbenchmark。一个悬而未决的问题是，是将整个独立项目整体迁移到共处套件，还是将其作为更长寿命回归测试的stabilization forest。</p>
<p>但是，任何用户仍然希望确保其他参数（例如执行机器和JDK）在进行分析时是稳定且可比较的。在通常情况下，我们希望benchmark能够在不到一分钟的时间内完成整个运行。这不是大型或长期运行benchmark的包装框架；目标是提供一套快速且有针对性的benchmark。在某些特殊情况下，benchmark可能需要更长时间的预热或运行时间才能获得稳定的结果，但应尽可能避免这种情况。套件的目标不是充当大型工作负载的通用包装器；相反，意图是从更大的benchmark中提取关键组件或方法，并仅将该部分强调为microbenchmark。</p>
<p>作为该项目的一部分，将创建<a href="https://wiki.openjdk.java.net" target="_blank" rel="noopener">wiki.openjdk.java.net</a>上的新页面，以帮助解释如何开发新benchmarks并描述添加benchmark的要求。这些要求将要求遵守编码标准、可重现的性能，以及明确的benchmark测量文档及其测量内容。</p>
<p><strong>选择</strong>：</p>
<p>继续将microbenchmark套件维护为一个单独的项目<a href="http://openjdk.java.net/projects/code-tools/jmh-jdk-microbenchmarks/" target="_blank" rel="noopener">[2]</a>。</p>
<p>协同定位简化了为新功能添加benchmark，特别是在所有新功能开发的大部分在项目存储库（Valhalla，Amber等）中完成的世界中。 在单独的项目模型中被证明特别复杂的情况是测试对javac本身的更改，需要使用每个相应的JDK显式重建benchmark套件。 协同定位可以更优雅地解决这个特定用例，同时不禁止使用预先构建的benchmark捆绑包来在较长时间段内对稳定测试进行性能跟踪。</p>
<p><strong>测试</strong>：</p>
<p>作为常规性能测试的一部分，性能团队将验证microbenchmark测试，以确保仅添加稳定、调整好的和准确的microbenchmark测试。 还将根据具体情况对基准进行评估和分析，以确保其测试预期的功能。所有测试必须在所有适用的平台上运行多次，以确保它们稳定。</p>
<h4 id="JEP325-Switch-Expressions-Preview"><a href="#JEP325-Switch-Expressions-Preview" class="headerlink" title="JEP325:  Switch Expressions (Preview)"></a><span id="jump325">JEP325:  Switch Expressions (Preview)</span></h4><p><strong>摘要</strong>：</p>
<p>扩展switch语句，以便它可以用作语句或表达式，并且这两种形式都可以使用“traditional”或“simplified”的作用域，都可以实现对程序的流程控制。 这些更改将简化日常编码，并为在switch语句中使用模式匹配（JEP 305）做好准备。 </p>
<p><strong>动机</strong>：</p>
<p>当我们准备增强Java编程语言以支持模式匹配（JEP 305）时，现有switch语句的一些不规则性（长期以来一直是用户的烦恼）成为我们工作的障碍。这包括switch blocks的默认控制流行为（fall through），switch blocks的默认作用域，还包括对switch使用时仅作为语句，尽管作为表达式的话实现multi-way conditionals通常更自然。</p>
<p>当前Java的switch语句设计紧随C和C++等语言，并且默认支持fall-through语义。虽然这种传统的控制流通常用于编写low-level代码（例如用于二进制编码的解析器），但随着switch用于higher-level的contexts，其error-prone的性质开始超过其灵活性。</p>
<p>例如，在下面的代码中，许多break语句使它不必要地冗长，并且这种视觉干扰经常掩盖难以debug的错误，比如缺少break语句将导致发生意外的fall-through错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY:</span><br><span class="line">    <span class="keyword">case</span> FRIDAY:</span><br><span class="line">    <span class="keyword">case</span> SUNDAY:</span><br><span class="line">        System.out.println(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TUESDAY:</span><br><span class="line">        System.out.println(<span class="number">7</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> THURSDAY:</span><br><span class="line">    <span class="keyword">case</span> SATURDAY:</span><br><span class="line">        System.out.println(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY:</span><br><span class="line">        System.out.println(<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将引入一种新形式的switch label，写成“case L  - &gt;”，用来表示如果标签匹配则只执行标签右侧的代码。 例如， 前面的代码现在可以写成下面这种形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">case</span> TUESDAY                -&gt; System.out.println(<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">case</span> THURSDAY, SATURDAY     -&gt; System.out.println(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY              -&gt; System.out.println(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（此示例还使用多个case 标签：我们支持在单个switch label中多个标签以逗号分隔开。）</p>
<p>“case L  - &gt;”开关标签右侧的代码仅限于表达式、块或（为方便起见）throw语句。 这具有令人满意的结果，如果一条分支（arm）引入局部变量，则它必须包含在该分支的块中，不在 switch block中的任何其他分支的作用域内。 这消除了“traditional”作用域的switch block的另一个烦恼，即局部变量的范围是整个switch block。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY:</span><br><span class="line">    <span class="keyword">case</span> TUESDAY:</span><br><span class="line">        <span class="keyword">int</span> temp = ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY:</span><br><span class="line">    <span class="keyword">case</span> THURSDAY:</span><br><span class="line">        <span class="keyword">int</span> temp2 = ...     <span class="comment">// Why can't I call this temp?</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">int</span> temp3 = ...     <span class="comment">// Why can't I call this temp?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>许多现有的switch语句本质上是switch表达式的模拟，其中每个arm分配给一个公共目标变量或返回一个值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numLetters;</span><br><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY:</span><br><span class="line">    <span class="keyword">case</span> FRIDAY:</span><br><span class="line">    <span class="keyword">case</span> SUNDAY:</span><br><span class="line">        numLetters = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TUESDAY:</span><br><span class="line">        numLetters = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> THURSDAY:</span><br><span class="line">    <span class="keyword">case</span> SATURDAY:</span><br><span class="line">        numLetters = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY:</span><br><span class="line">        numLetters = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Wat: "</span> + day);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种作为语句进行表述是拐弯抹角的、重复的、并且容易出错。上面的代码旨在每天为numLetters赋一个值。直说的话，使用一个switch表达式将更清晰、更安全：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numLetters = <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY, FRIDAY, SUNDAY -&gt; <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">case</span> TUESDAY                -&gt; <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">case</span> THURSDAY, SATURDAY     -&gt; <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY              -&gt; <span class="number">9</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>反过来，将switch扩展到支持表达式会引发一些额外的需求，例如扩展流分析（表达式必须始终计算值或突然完成），并允许switch表达式的某些case arm抛出异常而不是产生值。</p>
<p><strong>描述</strong>：</p>
<p>除了“traditional”的switch block之外，我们还建议添加一个新的“simplified”形式，使用新的“case L  - &gt;”switch标签。如果标签匹配，则只执行箭头标签右侧的表达式或语句，并且没有fall through。例如，给定方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">howMany</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (k) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> -&gt; System.out.println(<span class="string">"one"</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span> -&gt; System.out.println(<span class="string">"two"</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span> -&gt; System.out.println(<span class="string">"many"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">howMany(<span class="number">1</span>);</span><br><span class="line">howMany(<span class="number">2</span>);</span><br><span class="line">howMany(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>得到以下输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">many</span><br></pre></td></tr></table></figure>
<p>我们将扩展switch语句，以便它可以另外作为表达式来使用。 在常见情况下，switch表达式如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T result = <span class="keyword">switch</span> (arg) &#123;</span><br><span class="line">    <span class="keyword">case</span> L1 -&gt; e1;</span><br><span class="line">    <span class="keyword">case</span> L2 -&gt; e2;</span><br><span class="line">    <span class="keyword">default</span> -&gt; e3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>switch表达式是多边表达式，如果目标类型已知，则将此类型下推到每个arm中。如果已知，switch表达式的类型是其目标类型；如果未知，则通过组合每个case arm的类型来计算独立的类型。</p>
<p>大多数switch表达式在“case L  - &gt;”开关标签的右侧都有一个表达式。 如果需要一个完整的块，我们扩展了break语句以获取一个参数，该参数成为封闭的switch表达式的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int j = switch (day) &#123;</span><br><span class="line">    case MONDAY  -&gt; 0;</span><br><span class="line">    case TUESDAY -&gt; 1;</span><br><span class="line">    default      -&gt; &#123;</span><br><span class="line">        int k = day.toString().length();</span><br><span class="line">        int result = f(k);</span><br><span class="line">        break result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>与switch语句一样，switch表达式也可以使用带有“case L:”switch标签的“traditional”switch block。在这种情况下，将使用break with value语句生成值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = <span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Foo"</span>: </span><br><span class="line">        <span class="keyword">break</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Bar"</span>:</span><br><span class="line">        <span class="keyword">break</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">"Neither Foo nor Bar, hmmm..."</span>);</span><br><span class="line">        <span class="keyword">break</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>两种形式的break（有值和无值）类似于方法中return的两种形式。两种形式的return都会立即终止方法的执行；在非void方法中，还必须提供一个值，该值被赋予方法的调用者。</p>
<p>switch表达式的case必须是详尽的，对于任何可能的值，必须有匹配的switch标签。实际上，这通常意味着只需要一个default子句；但是，如果枚举switch表达式涵盖了所有已知情况，default子句可以由编译器插入，即枚举定义在编译时和运行时之间发生了变化。</p>
<p>此外，switch表达式必须正常使用值完成，或抛出异常。编译器检查每个switch标签是否匹配，然后可以产生一个值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"Monday"</span>); </span><br><span class="line">        <span class="comment">// ERROR! Block doesn't contain a break with value</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line">i = <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY, TUESDAY, WEDNESDAY: </span><br><span class="line">        <span class="keyword">break</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">        System.out.println(<span class="string">"Second half of the week"</span>);</span><br><span class="line">        <span class="comment">// ERROR! Group doesn't contain a break with value</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>控制语句、break、return和continue不能跳过switch表达式，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">z: </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_VALUE; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="keyword">switch</span> (e) &#123; </span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:  </span><br><span class="line">                <span class="keyword">break</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">default</span>: </span><br><span class="line">                <span class="keyword">continue</span> z; </span><br><span class="line">                <span class="comment">// ERROR! Illegal jump through a switch expression </span></span><br><span class="line">        &#125;;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>同时，我们可以扩展switch以支持先前不允许的原始类型（及其装箱类型），例如float，double和long。</p>
<h4 id="JEP334-JVM-Constants-API"><a href="#JEP334-JVM-Constants-API" class="headerlink" title="JEP334: JVM Constants API"></a><span id="jump334">JEP334: JVM Constants API</span></h4><p><strong>摘要</strong>：</p>
<p>引入API来规范key class-file和run-time artifacts（特别是可从常量池加载的常量）的标称描述。</p>
<p><strong>动机</strong>：</p>
<p>每个Java类文件都有一个常量池，用于存储类中字节码指令的操作数。从广义上讲，常量池中的条目描述了运行时构件（如类和方法）或简单值（如字符串和整数）。所有这些条目都称为可加载常量，因为它们可以作为ldc指令的操作数（“加载常量”）。它们也可能出现在invokedynamic指令的bootstrap方法的静态参数列表中。执行ldc或invokedynamic指令会将可装入常量解析为标准Java类型的“实时”值，例如Class，String或int。</p>
<p>操作类文件的程序需要对字节码指令进行建模，然后再加载可加载的常量。但是，使用标准Java类型来规范可加载常量是不合适的。描述字符串（CONSTANT_String_info条目）的可加载常量可能是可以接受的，因为生成“实时”String对象很简单，但是对于描述类（CONSTANT_Class_info条目）的可加载常量是有问题的，因为生成“实时”类对象依赖于类加载的正确性和一致性。不幸的是，类加载有许多环境依赖和失败模式：所需的类不存在或者请求者可能无法访问；类加载的结果因上下文而异；装载类有副作用；有时类加载可能根本不可能（例如当所描述的类尚不存在或者不可加载时，如在编译那些相同的类期间，或在jlink-time转换期间）。</p>
<p>因此，处理可加载常量的程序如果能够以纯粹的名义符号形式操作类和方法，以及不太知名的构件（如方法句柄和动态计算常量），则会更简单：</p>
<ul>
<li><p>字节码解析和生成库必须以符号形式描述类和方法句柄。如果没有标准机制，它们必须求助于ad-hoc机制，无论是描述符类型（如ASM的Handle）还是字符串元组（方法所有者，方法名称，方法描述符），或者ad-hoc（和容易出错）的编码成一个字符串。</p>
</li>
<li><p>如果可以在符号域中工作而不是使用“实时”类和方法句柄，则通过旋转字节码（例如LambdaMetafactory）操作的invokedynamic的bootstraps会更简单。</p>
</li>
<li><p>编译器和脱机转换器（例如jlink插件）需要描述无法加载到正在运行的VM的类的类和成员。编译器插件（例如注释处理器）同样需要用符号术语来描述程序元素。</p>
</li>
</ul>
<p>这些类型的库和工具都将受益于使用单一，标准的方式来描述可加载常量。</p>
<p><strong>描述</strong>：</p>
<p>我们在新的java.lang.invoke.constant包中定义了一系列基于值的符号引用（JVMS 5.1）类型，能够描述每种可加载常量。符号引用描述了纯粹标称形式的可加载常量，与类加载或可访问性上下文分开。 有些类可以作为自己的符号引用（例如String）；对于可链接常量，我们定义了一系列符号引用类型（ClassDesc，MethodTypeDesc，MethodHandleDesc和DynamicConstantDesc），它们包含描述这些常量的标称信息。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JVM/" rel="tag"><i class="fa fa-tag"></i> JVM</a>
          
            <a href="/tags/OpenJDK/" rel="tag"><i class="fa fa-tag"></i> OpenJDK</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/25/日志分析接口协议设计与实现/" rel="next" title="日志分析接口协议的设计与实现">
                <i class="fa fa-chevron-left"></i> 日志分析接口协议的设计与实现
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/26/OpenJDK12的新特性（下）/" rel="prev" title="OpenJDK12的新特性（下）">
                OpenJDK12的新特性（下） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/Issac.png" alt="F8F-1BearCat">
          <p class="site-author-name" itemprop="name">F8F-1BearCat</p>
           
              <p class="site-description motion-element" itemprop="description">今天除了皮，又啥也没干</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/F8F-1BearCat" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="fczlm88@outlook.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                    
                      E-Mail
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#文章摘要"><span class="nav-number">1.</span> <span class="nav-text">文章摘要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特性"><span class="nav-number">2.</span> <span class="nav-text">特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JEP189-Shenandoah-A-Low-Pause-Time-Garbage-Collector-Experimental"><span class="nav-number">2.0.1.</span> <span class="nav-text">JEP189: Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JEP230-Microbenchmark-Suite"><span class="nav-number">2.0.2.</span> <span class="nav-text">JEP230: Microbenchmark Suite</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JEP325-Switch-Expressions-Preview"><span class="nav-number">2.0.3.</span> <span class="nav-text">JEP325:  Switch Expressions (Preview)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JEP334-JVM-Constants-API"><span class="nav-number">2.0.4.</span> <span class="nav-text">JEP334: JVM Constants API</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">F8F-1BearCat</span>
</div>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
